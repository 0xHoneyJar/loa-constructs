# eval.yml — Loa Eval Sandbox CI Pipeline
# Runs eval suites on PRs that modify Loa framework files.
# Uses container sandboxing for secure execution.
name: Eval Sandbox

on:
  pull_request:
    types: [opened, synchronize, reopened]
    paths:
      - '.claude/skills/**'
      - '.claude/protocols/**'
      - '.claude/data/**'
      - '.loa.config.yaml'
      - 'evals/**'

# Prevent concurrent runs on same PR
concurrency:
  group: eval-${{ github.event.pull_request.number }}
  cancel-in-progress: true

permissions:
  contents: read
  pull-requests: write

jobs:
  eval:
    name: Run Eval Suites
    runs-on: ubuntu-latest
    # Do not run on fork PRs (security: forks could modify graders)
    if: >
      github.event.pull_request.head.repo.full_name == github.repository &&
      !contains(github.event.pull_request.labels.*.name, 'eval-skip')
    timeout-minutes: 30

    steps:
      # 1. Checkout base branch for trusted graders/harness
      - name: Checkout base branch (trusted)
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.base.ref }}
          path: base

      # 2. Checkout PR branch for code under test
      - name: Checkout PR branch
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha }}
          path: pr

      # 3. Copy trusted harness/graders from base to PR workspace
      - name: Copy trusted eval infrastructure
        run: |
          # Validate symlinks BEFORE any rm/cp to prevent traversal attacks
          echo "Checking for suspicious symlinks in PR workspace..."
          pr_root="$(realpath pr)"
          for check_path in pr/evals pr/evals/harness pr/evals/graders; do
            if [[ -L "$check_path" ]]; then
              echo "::error::Symlinked eval path detected: $check_path"
              exit 1
            fi
            if [[ -e "$check_path" ]]; then
              resolved="$(realpath "$check_path")"
              if [[ "$resolved" != "$pr_root/"* ]]; then
                echo "::error::Eval path escapes workspace: $check_path -> $resolved"
                exit 1
              fi
            fi
          done

          suspicious=$(find pr/ -type l -exec readlink -f {} \; 2>/dev/null | grep -v "^${pr_root}/" || true)
          if [[ -n "$suspicious" ]]; then
            echo "::error::Symlinks pointing outside workspace detected"
            echo "$suspicious"
            exit 1
          fi

          # Remove PR versions first to prevent injected extra scripts surviving
          rm -rf pr/evals/harness pr/evals/graders

          # Use graders and harness from BASE branch (tamper-proof)
          cp -a base/evals/harness/ pr/evals/harness/
          cp -a base/evals/graders/ pr/evals/graders/

      # 3a. Copy trusted suite definitions from base branch
      - name: Copy trusted suite definitions
        run: |
          if [[ -d "base/evals/suites/" ]]; then
            echo "Copying trusted suite definitions from base branch..."
            cp -a base/evals/suites/ pr/evals/suites/
          else
            echo "No suite definitions in base branch, skipping"
          fi

      # 3b. Detect new suite files introduced by PR
      - name: Checkout PR suites (for new-file detection)
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha }}
          path: pr-suites-check
          sparse-checkout: evals/suites

      - name: Detect new suite files from PR
        run: |
          new_files=()
          if [[ -d "pr-suites-check/evals/suites/" ]]; then
            while IFS= read -r -d '' f; do
              rel="${f#pr-suites-check/evals/suites/}"
              if [[ ! -f "base/evals/suites/$rel" ]]; then
                new_files+=("$rel")
              fi
            done < <(find pr-suites-check/evals/suites/ -type f \( -name '*.yaml' -o -name '*.yml' \) -print0 2>/dev/null)
          fi

          if [[ ${#new_files[@]} -gt 0 ]]; then
            echo "::error::PR introduces new eval suite files not in base branch: ${new_files[*]}. New suite files require explicit review before CI will run them."
            exit 1
          fi
          echo "No new suite files detected"

      # 3c. Validate suite paths (no traversal or absolute paths)
      - name: Validate suite paths
        run: |
          violations=0
          while IFS= read -r -d '' f; do
            # Check for path traversal
            if grep -qE '\.\.\/' "$f"; then
              echo "::error file=$f::Path traversal pattern '../' detected in suite file"
              violations=$((violations + 1))
            fi

            # Check for absolute paths
            if grep -qE '^[^#]*glob:\s*/' "$f"; then
              echo "::error file=$f::Absolute path in glob detected in suite file"
              violations=$((violations + 1))
            fi
          done < <(find pr/evals/suites/ -type f \( -name '*.yaml' -o -name '*.yml' \) -print0 2>/dev/null)

          if [[ $violations -gt 0 ]]; then
            echo "::error::Found $violations path violations in suite YAML files"
            exit 1
          fi
          echo "Suite path validation passed"

      # 3.5. Validate grader trust boundary
      #   Graders execute during eval and have access to the workspace.
      #   Ensure no grader/harness script sources files from outside the
      #   trusted eval tree or uses dynamic evaluation that could be
      #   influenced by PR content.
      - name: Validate grader trust boundary
        run: |
          echo "Scanning trusted eval scripts for source-injection vectors..."
          violations=0

          # Scan all .sh files in trusted eval directories (exclude tests/)
          for f in $(find pr/evals/graders/ pr/evals/harness/ -name '*.sh' -type f -not -path '*/tests/*' 2>/dev/null); do
            # Check for source/dot directives with variable expansion or paths outside evals/
            while IFS= read -r line; do
              # Skip comments
              [[ "$line" =~ ^[[:space:]]*# ]] && continue

              # Detect: source $VAR, . $VAR, source $(cmd), eval $(...), eval "$var"
              if printf '%s\n' "$line" | grep -qE '(^|[;&|])[[:space:]]*(source|\.)[ \t]+.{0,500}(\$|`)'; then
                echo "::error file=$f::Source directive with variable expansion: $line"
                violations=$((violations + 1))
              fi

              # Detect: eval with variable expansion
              if printf '%s\n' "$line" | grep -qE '(^|[;&|])[[:space:]]*eval[ \t]+.{0,500}(\$|`)'; then
                echo "::error file=$f::Eval with variable expansion: $line"
                violations=$((violations + 1))
              fi
            done < "$f"
          done

          if [[ $violations -gt 0 ]]; then
            echo "::error::Found $violations trust boundary violations in eval scripts"
            exit 1
          fi
          echo "Trust boundary check passed"

      # 4. Install dependencies
      - name: Install yq
        uses: mikefarah/yq@v4.40.5

      - name: Verify tools
        run: |
          bash --version
          jq --version
          yq --version
          git --version

      # 5. Download previous eval ledger (if exists)
      - name: Download eval ledger
        uses: actions/download-artifact@v4
        with:
          name: eval-ledger
          path: pr/evals/results/
        continue-on-error: true

      # 6. Validate downloaded ledger integrity (JSON + HMAC signature)
      - name: Validate ledger integrity
        env:
          EVAL_LEDGER_KEY: ${{ secrets.EVAL_LEDGER_KEY }}
        run: |
          validate_ledger_sig() {
            local entry="$1"
            local key="${EVAL_LEDGER_KEY:-}"
            if [[ -z "$key" ]]; then
              return 0  # Graceful degradation — no key, skip validation
            fi
            local sig
            sig=$(printf '%s\n' "$entry" | jq -r '.__sig // empty')
            if [[ -z "$sig" ]]; then
              echo "::warning::Unsigned ledger entry found"
              return 0  # Accept unsigned entries for backward compatibility
            fi
            local clean_entry
            clean_entry=$(printf '%s\n' "$entry" | jq -c 'del(.__sig)')
            local expected
            expected="hmac-sha256:$(echo -n "$clean_entry" | openssl dgst -sha256 -hmac "$key" -binary | xxd -p -c 256)"
            if [[ "$sig" != "$expected" ]]; then
              echo "::warning::Ledger entry signature mismatch — skipping entry"
              return 1
            fi
            return 0
          }

          ledger="pr/evals/results/eval-ledger.jsonl"
          if [[ -f "$ledger" ]]; then
            echo "Validating ledger JSONL integrity..."
            # Always validate line-by-line (JSON + optional HMAC) to catch tampered entries
            invalid_lines=0
            tampered_lines=0
            valid_tmp=$(mktemp)
            while IFS= read -r line; do
              if [[ -z "$line" ]]; then continue; fi
              if ! printf '%s\n' "$line" | jq -e . >/dev/null 2>&1; then
                invalid_lines=$((invalid_lines + 1))
                continue
              fi
              if ! validate_ledger_sig "$line"; then
                tampered_lines=$((tampered_lines + 1))
                continue
              fi
              printf '%s\n' "$line" >> "$valid_tmp"
            done < "$ledger"
            if [[ $invalid_lines -gt 0 || $tampered_lines -gt 0 ]]; then
              echo "::warning::Eval ledger: $invalid_lines invalid, $tampered_lines tampered lines removed."
              mv "$valid_tmp" "$ledger"
            else
              rm -f "$valid_tmp"
            fi
          fi

      # 7. Build sandbox container
      - name: Build sandbox container
        run: |
          if [[ -f "pr/evals/harness/Dockerfile.sandbox" ]]; then
            docker build -t loa-eval-sandbox -f pr/evals/harness/Dockerfile.sandbox pr/
          else
            echo "No Dockerfile.sandbox found, using local mode"
          fi
        continue-on-error: true

      # 8. Run framework suite
      - name: Run framework suite
        id: framework
        working-directory: pr
        run: |
          set +e
          output=$(./evals/harness/run-eval.sh \
            --suite framework \
            --trusted \
            --json \
            --no-color 2>&1)
          exit_code=$?
          echo "exit_code=$exit_code" >> "$GITHUB_OUTPUT"

          # Save results
          echo "$output" > evals/results/framework-output.json
          echo "Framework suite exit code: $exit_code"
          exit 0

      # 9. Run regression suite (if exists)
      - name: Run regression suite
        id: regression
        working-directory: pr
        run: |
          set +e
          if [[ -f "evals/suites/regression.yaml" ]]; then
            output=$(./evals/harness/run-eval.sh \
              --suite regression \
              --trusted \
              --json \
              --no-color 2>&1)
            exit_code=$?
          else
            echo "No regression suite found, skipping"
            exit_code=0
          fi
          echo "exit_code=$exit_code" >> "$GITHUB_OUTPUT"
          echo "Regression suite exit code: $exit_code"
          exit 0

      # 10. Post PR comment (one per suite)
      - name: Post eval results
        if: always()
        working-directory: pr
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          chmod +x evals/harness/pr-comment.sh

          # Post results for each run directory (one per suite)
          for run_dir in $(ls -td evals/results/run-* 2>/dev/null); do
            if [[ ! -f "$run_dir/run-meta.json" ]]; then
              continue
            fi

            comment_args=("--run-dir" "$run_dir")
            [[ -f "$run_dir/comparison.json" ]] && comment_args+=("--comparison" "$run_dir/comparison.json")
            comment_args+=("--pr" "${{ github.event.pull_request.number }}")
            comment_args+=("--repo" "${{ github.repository }}")

            ./evals/harness/pr-comment.sh "${comment_args[@]}" || true
          done

      # 11. Upload eval ledger as artifact
      - name: Upload eval ledger
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: eval-ledger
          path: pr/evals/results/eval-ledger.jsonl
          retention-days: 90
          if-no-files-found: ignore

      # 12. Upload run results
      - name: Upload run results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: eval-results-${{ github.event.pull_request.number }}
          path: pr/evals/results/run-*
          retention-days: 30
          if-no-files-found: ignore

      # 13. Check for regressions (final gate)
      - name: Check for regressions
        run: |
          framework_exit="${{ steps.framework.outputs.exit_code }}"
          regression_exit="${{ steps.regression.outputs.exit_code }}"

          if [[ "$framework_exit" == "1" || "$regression_exit" == "1" ]]; then
            echo "::error::Regressions detected in eval suites"
            exit 1
          elif [[ "$framework_exit" == "2" || "$regression_exit" == "2" ]]; then
            echo "::warning::Infrastructure errors in eval suites"
            # Don't block on infra errors
            exit 0
          else
            echo "All eval suites passed"
            exit 0
          fi
