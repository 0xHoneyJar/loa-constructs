name: Melange Resolution

on:
  issues:
    types: [closed]
  issue_comment:
    types: [created]
  pull_request:
    types: [closed]

jobs:
  # Handle direct Issue closure (T10.1)
  issue-closed:
    runs-on: ubuntu-latest
    if: |
      github.event_name == 'issues' &&
      github.event.action == 'closed' &&
      contains(github.event.issue.labels.*.name, 'melange')

    steps:
      - name: Process Issue Close
        uses: actions/github-script@v7
        env:
          DISCORD_WEBHOOK: ${{ secrets.MELANGE_DISCORD_WEBHOOK }}
        with:
          script: |
            const issue = context.payload.issue;
            const issueNumber = issue.number;
            const labels = issue.labels.map(l => l.name);

            // Skip if already resolved (via PR merge)
            if (labels.includes('status:resolved')) {
              console.log('Issue already marked as resolved, skipping');
              return;
            }

            // Skip if closed via PR merge - the PR handler will process this
            // Check for linked PRs that closed this issue
            try {
              const timeline = await github.rest.issues.listEventsForTimeline({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                per_page: 50
              });

              // Look for a cross-referenced PR that was merged and closed this issue
              const closedByPR = timeline.data.some(event => {
                if (event.event === 'cross-referenced' && event.source?.issue?.pull_request) {
                  // This is a PR that referenced this issue
                  const prState = event.source.issue.state;
                  const prMerged = event.source.issue.pull_request?.merged_at;
                  return prState === 'closed' && prMerged;
                }
                if (event.event === 'closed' && event.commit_id) {
                  // Closed via commit (PR merge)
                  return true;
                }
                return false;
              });

              if (closedByPR) {
                console.log('Issue was closed via PR merge, deferring to PR handler');
                return;
              }
            } catch (e) {
              console.log(`Could not check timeline: ${e.message}, proceeding with direct close handling`);
            }

            // Extract melange-metadata from Issue body
            const metadataMatch = issue.body?.match(/<!-- melange-metadata\n([\s\S]*?)\n-->/);
            let senderDiscord = null;
            let senderGithub = null;
            let senderConstruct = null;

            if (metadataMatch) {
              const metadata = metadataMatch[1];
              const discordMatch = metadata.match(/sender_discord:\s*(\d+)/);
              const githubMatch = metadata.match(/sender_github:\s*(\S+)/);
              const constructMatch = metadata.match(/sender_construct:\s*(\S+)/);

              if (discordMatch) senderDiscord = discordMatch[1];
              if (githubMatch) senderGithub = githubMatch[1];
              if (constructMatch) senderConstruct = constructMatch[1];
            }

            // Update labels: remove status:*, add status:resolved
            const newLabels = labels
              .filter(l => !l.startsWith('status:'))
              .concat(['status:resolved']);

            await github.rest.issues.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              labels: newLabels
            });

            console.log(`Marked Melange Issue #${issueNumber} as resolved`);

            // Send Discord notification to sender
            if (process.env.DISCORD_WEBHOOK && senderDiscord) {
              // Find target construct from labels
              const toLabel = labels.find(l => l.startsWith('to:'));
              const target = toLabel ? toLabel.replace('to:', '') : 'unknown';

              const embed = {
                title: `âœ… Thread Resolved: ${issue.title}`,
                description: `Your Melange thread to **${target}** has been resolved.`,
                color: 0x00FF00, // Green
                fields: [
                  { name: 'Issue', value: `[#${issueNumber}](${issue.html_url})`, inline: true },
                  { name: 'To', value: target, inline: true },
                  { name: 'Closed By', value: context.payload.sender.login, inline: true }
                ],
                footer: { text: 'Use /threads --pending-review to verify resolution' },
                timestamp: new Date().toISOString()
              };

              const payload = {
                content: `<@${senderDiscord}> Your Melange thread was resolved!`,
                embeds: [embed]
              };

              await fetch(process.env.DISCORD_WEBHOOK, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
              });

              console.log(`Discord notification sent to ${senderDiscord}`);
            } else if (!senderDiscord) {
              console.log('No sender_discord in metadata, skipping Discord notification');
              console.log('This may be an older Issue created before metadata embedding');
            }

  # Handle PR resolution linking via comments
  detect-resolution:
    runs-on: ubuntu-latest
    if: |
      (github.event_name == 'issue_comment' && contains(github.event.issue.labels.*.name, 'melange')) ||
      (github.event_name == 'pull_request' && github.event.pull_request.merged)

    steps:
      - name: Process Resolution
        uses: actions/github-script@v7
        env:
          DISCORD_WEBHOOK: ${{ secrets.MELANGE_DISCORD_WEBHOOK }}
        with:
          script: |
            const event = context.eventName;

            if (event === 'issue_comment') {
              // Detect resolution patterns in comments
              const body = context.payload.comment.body;
              const issueNumber = context.payload.issue.number;

              // Patterns to detect PR references
              const patterns = [
                /resolved?\s+(?:via|in|by)\s+(?:PR\s*)?#(\d+)/i,
                /fixed?\s+(?:via|in|by)\s+(?:PR\s*)?#(\d+)/i,
                /addressed?\s+(?:via|in|by)\s+(?:PR\s*)?#(\d+)/i,
                /implemented?\s+(?:via|in|by)\s+(?:PR\s*)?#(\d+)/i,
                /closes?\s+(?:PR\s*)?#(\d+)/i
              ];

              for (const pattern of patterns) {
                const match = body.match(pattern);
                if (match) {
                  const prNumber = match[1];

                  // Check if label already exists
                  const existingLabels = context.payload.issue.labels.map(l => l.name);
                  const resolutionLabel = `resolution:PR#${prNumber}`;

                  if (!existingLabels.includes(resolutionLabel)) {
                    // Add resolution label
                    await github.rest.issues.addLabels({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: issueNumber,
                      labels: [resolutionLabel]
                    });

                    console.log(`Linked PR #${prNumber} to Melange Issue #${issueNumber}`);

                    // Post confirmation comment
                    await github.rest.issues.createComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: issueNumber,
                      body: `ðŸ”— Linked to PR #${prNumber} for resolution tracking.`
                    });
                  }
                  break;
                }
              }
            }

            if (event === 'pull_request' && context.payload.pull_request.merged) {
              // Check if PR closes any Melange Issues
              const prBody = context.payload.pull_request.body || '';
              const prNumber = context.payload.pull_request.number;

              // Patterns for PR closing Issues
              const closesPatterns = [
                /closes?\s+#(\d+)/gi,
                /fixes?\s+#(\d+)/gi,
                /resolves?\s+#(\d+)/gi
              ];

              const closedIssues = new Set();

              for (const pattern of closesPatterns) {
                let match;
                while ((match = pattern.exec(prBody)) !== null) {
                  closedIssues.add(parseInt(match[1]));
                }
              }

              for (const issueNumber of closedIssues) {
                try {
                  // Check if it's a Melange Issue
                  const issue = await github.rest.issues.get({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issueNumber
                  });

                  const labels = issue.data.labels.map(l => l.name);

                  if (labels.includes('melange')) {
                    // Update status to resolved
                    const newLabels = labels
                      .filter(l => !l.startsWith('status:'))
                      .concat(['status:resolved', `resolution:PR#${prNumber}`]);

                    await github.rest.issues.update({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: issueNumber,
                      labels: newLabels
                    });

                    console.log(`Marked Melange Issue #${issueNumber} as resolved via PR #${prNumber}`);

                    // Post resolution comment
                    await github.rest.issues.createComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: issueNumber,
                      body: `âœ… Resolved via PR #${prNumber} (merged).`
                    });

                    // Extract sender info and send Discord notification
                    const metadataMatch = issue.data.body?.match(/<!-- melange-metadata\n([\s\S]*?)\n-->/);
                    if (metadataMatch && process.env.DISCORD_WEBHOOK) {
                      const metadata = metadataMatch[1];
                      const discordMatch = metadata.match(/sender_discord:\s*(\d+)/);

                      if (discordMatch) {
                        const senderDiscord = discordMatch[1];
                        const toLabel = labels.find(l => l.startsWith('to:'));
                        const target = toLabel ? toLabel.replace('to:', '') : 'unknown';

                        const embed = {
                          title: `âœ… Thread Resolved: ${issue.data.title}`,
                          description: `Your Melange thread to **${target}** has been resolved via PR #${prNumber}.`,
                          color: 0x00FF00,
                          fields: [
                            { name: 'Issue', value: `[#${issueNumber}](${issue.data.html_url})`, inline: true },
                            { name: 'PR', value: `[#${prNumber}](${context.payload.pull_request.html_url})`, inline: true },
                            { name: 'To', value: target, inline: true }
                          ],
                          footer: { text: 'Use /threads --pending-review to verify resolution' },
                          timestamp: new Date().toISOString()
                        };

                        const payload = {
                          content: `<@${senderDiscord}> Your Melange thread was resolved!`,
                          embeds: [embed]
                        };

                        await fetch(process.env.DISCORD_WEBHOOK, {
                          method: 'POST',
                          headers: { 'Content-Type': 'application/json' },
                          body: JSON.stringify(payload)
                        });

                        console.log(`Discord notification sent to ${senderDiscord}`);
                      }
                    }
                  }
                } catch (e) {
                  console.log(`Could not process Issue #${issueNumber}: ${e.message}`);
                }
              }
            }
