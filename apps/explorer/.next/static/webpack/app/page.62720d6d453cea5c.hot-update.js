"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/data/compute-layout.ts":
/*!************************************!*\
  !*** ./lib/data/compute-layout.ts ***!
  \************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   computeLayout: () => (/* binding */ computeLayout),\n/* harmony export */   scalePositions: () => (/* binding */ scalePositions)\n/* harmony export */ });\n// Domain cluster centers - arranged in a hexagonal pattern (spread out more)\nconst DOMAIN_CENTERS = {\n    gtm: {\n        x: -320,\n        y: 140\n    },\n    dev: {\n        x: 320,\n        y: 140\n    },\n    security: {\n        x: 0,\n        y: -280\n    },\n    ops: {\n        x: 320,\n        y: -140\n    },\n    docs: {\n        x: -320,\n        y: -140\n    },\n    analytics: {\n        x: 0,\n        y: 280\n    }\n};\nconst DEFAULT_CONFIG = {\n    width: 1000,\n    height: 700,\n    iterations: 50,\n    repulsionStrength: 12000,\n    attractionStrength: 0.05,\n    domainGravity: 0.03\n};\nfunction distance(a, b) {\n    const dx = a.x - b.x;\n    const dy = a.y - b.y;\n    return Math.sqrt(dx * dx + dy * dy);\n}\nfunction normalize(v) {\n    const len = Math.sqrt(v.x * v.x + v.y * v.y);\n    if (len === 0) return {\n        x: 0,\n        y: 0\n    };\n    return {\n        x: v.x / len,\n        y: v.y / len\n    };\n}\nfunction computeLayout(nodes, edges) {\n    let config = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : DEFAULT_CONFIG;\n    const positions = new Map();\n    const velocities = new Map();\n    // Initialize positions near domain centers with some randomness\n    for (const node of nodes){\n        const center = DOMAIN_CENTERS[node.domain] || {\n            x: 0,\n            y: 0\n        };\n        // Use node id hash for deterministic \"randomness\"\n        const hash = node.id.split('').reduce((a, c)=>a + c.charCodeAt(0), 0);\n        const angle = hash % 360 * (Math.PI / 180);\n        const radius = 60 + hash % 80;\n        positions.set(node.id, {\n            x: center.x + Math.cos(angle) * radius,\n            y: center.y + Math.sin(angle) * radius\n        });\n        velocities.set(node.id, {\n            x: 0,\n            y: 0\n        });\n    }\n    // Build edge lookup for faster access\n    const edgeMap = new Map();\n    for (const edge of edges){\n        if (!edgeMap.has(edge.source)) edgeMap.set(edge.source, []);\n        if (!edgeMap.has(edge.target)) edgeMap.set(edge.target, []);\n        edgeMap.get(edge.source).push(edge.target);\n        edgeMap.get(edge.target).push(edge.source);\n    }\n    // Run simulation\n    for(let iter = 0; iter < config.iterations; iter++){\n        const cooling = 1 - iter / config.iterations;\n        for (const node of nodes){\n            const pos = positions.get(node.id);\n            let fx = 0;\n            let fy = 0;\n            // Repulsion from all other nodes\n            for (const other of nodes){\n                if (other.id === node.id) continue;\n                const otherPos = positions.get(other.id);\n                const dist = Math.max(distance(pos, otherPos), 1);\n                const repulsion = config.repulsionStrength / (dist * dist);\n                const dir = normalize({\n                    x: pos.x - otherPos.x,\n                    y: pos.y - otherPos.y\n                });\n                fx += dir.x * repulsion;\n                fy += dir.y * repulsion;\n            }\n            // Attraction to connected nodes\n            const connected = edgeMap.get(node.id) || [];\n            for (const connectedId of connected){\n                const connectedPos = positions.get(connectedId);\n                if (!connectedPos) continue;\n                const dist = distance(pos, connectedPos);\n                const attraction = dist * config.attractionStrength;\n                const dir = normalize({\n                    x: connectedPos.x - pos.x,\n                    y: connectedPos.y - pos.y\n                });\n                fx += dir.x * attraction;\n                fy += dir.y * attraction;\n            }\n            // Domain gravity - pull toward cluster center\n            const center = DOMAIN_CENTERS[node.domain] || {\n                x: 0,\n                y: 0\n            };\n            const toCenterX = center.x - pos.x;\n            const toCenterY = center.y - pos.y;\n            fx += toCenterX * config.domainGravity;\n            fy += toCenterY * config.domainGravity;\n            // Packs get extra central gravity\n            if (node.type === 'pack') {\n                fx += -pos.x * 0.01;\n                fy += -pos.y * 0.01;\n            }\n            // Update velocity with damping\n            const vel = velocities.get(node.id);\n            vel.x = (vel.x + fx) * 0.5 * cooling;\n            vel.y = (vel.y + fy) * 0.5 * cooling;\n            // Update position\n            pos.x += vel.x;\n            pos.y += vel.y;\n            // Clamp to bounds\n            const margin = 50;\n            pos.x = Math.max(-config.width / 2 + margin, Math.min(config.width / 2 - margin, pos.x));\n            pos.y = Math.max(-config.height / 2 + margin, Math.min(config.height / 2 - margin, pos.y));\n        }\n    }\n    return positions;\n}\n// Scale positions for Three.js coordinate system\nfunction scalePositions(positions) {\n    let scale = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0.01;\n    const scaled = new Map();\n    for (const [id, pos] of positions){\n        scaled.set(id, {\n            x: pos.x * scale,\n            y: pos.y * scale\n        });\n    }\n    return scaled;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9kYXRhL2NvbXB1dGUtbGF5b3V0LnRzIiwibWFwcGluZ3MiOiI7Ozs7O0FBZ0JBLDZFQUE2RTtBQUM3RSxNQUFNQSxpQkFBMEM7SUFDOUNDLEtBQUs7UUFBRUMsR0FBRyxDQUFDO1FBQUtDLEdBQUc7SUFBSTtJQUN2QkMsS0FBSztRQUFFRixHQUFHO1FBQUtDLEdBQUc7SUFBSTtJQUN0QkUsVUFBVTtRQUFFSCxHQUFHO1FBQUdDLEdBQUcsQ0FBQztJQUFJO0lBQzFCRyxLQUFLO1FBQUVKLEdBQUc7UUFBS0MsR0FBRyxDQUFDO0lBQUk7SUFDdkJJLE1BQU07UUFBRUwsR0FBRyxDQUFDO1FBQUtDLEdBQUcsQ0FBQztJQUFJO0lBQ3pCSyxXQUFXO1FBQUVOLEdBQUc7UUFBR0MsR0FBRztJQUFJO0FBQzVCO0FBRUEsTUFBTU0saUJBQStCO0lBQ25DQyxPQUFPO0lBQ1BDLFFBQVE7SUFDUkMsWUFBWTtJQUNaQyxtQkFBbUI7SUFDbkJDLG9CQUFvQjtJQUNwQkMsZUFBZTtBQUNqQjtBQUVBLFNBQVNDLFNBQVNDLENBQVUsRUFBRUMsQ0FBVTtJQUN0QyxNQUFNQyxLQUFLRixFQUFFZixDQUFDLEdBQUdnQixFQUFFaEIsQ0FBQztJQUNwQixNQUFNa0IsS0FBS0gsRUFBRWQsQ0FBQyxHQUFHZSxFQUFFZixDQUFDO0lBQ3BCLE9BQU9rQixLQUFLQyxJQUFJLENBQUNILEtBQUtBLEtBQUtDLEtBQUtBO0FBQ2xDO0FBRUEsU0FBU0csVUFBVUMsQ0FBVTtJQUMzQixNQUFNQyxNQUFNSixLQUFLQyxJQUFJLENBQUNFLEVBQUV0QixDQUFDLEdBQUdzQixFQUFFdEIsQ0FBQyxHQUFHc0IsRUFBRXJCLENBQUMsR0FBR3FCLEVBQUVyQixDQUFDO0lBQzNDLElBQUlzQixRQUFRLEdBQUcsT0FBTztRQUFFdkIsR0FBRztRQUFHQyxHQUFHO0lBQUU7SUFDbkMsT0FBTztRQUFFRCxHQUFHc0IsRUFBRXRCLENBQUMsR0FBR3VCO1FBQUt0QixHQUFH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RjtZQUM3QmlCLElBQUl0RSxDQUFDLEdBQUcsQ0FBQ3NFLElBQUl0RSxDQUFDLEdBQUd3RCxFQUFDLElBQUssTUFBTUg7WUFFN0Isa0JBQWtCO1lBQ2xCQyxJQUFJdkQsQ0FBQyxJQUFJdUUsSUFBSXZFLENBQUM7WUFDZHVELElBQUl0RCxDQUFDLElBQUlzRSxJQUFJdEUsQ0FBQztZQUVkLGtCQUFrQjtZQUNsQixNQUFNdUUsU0FBUztZQUNmakIsSUFBSXZELENBQUMsR0FBR21CLEtBQUswQyxHQUFHLENBQUMsQ0FBQ2xDLE9BQU9uQixLQUFLLEdBQUcsSUFBSWdFLFFBQVFyRCxLQUFLc0QsR0FBRyxDQUFDOUMsT0FBT25CLEtBQUssR0FBRyxJQUFJZ0UsUUFBUWpCLElBQUl2RCxDQUFDO1lBQ3RGdUQsSUFBSXRELENBQUMsR0FBR2tCLEtBQUswQyxHQUFHLENBQUMsQ0FBQ2xDLE9BQU9sQixNQUFNLEdBQUcsSUFBSStELFFBQVFyRCxLQUFLc0QsR0FBRyxDQUFDOUMsT0FBT2xCLE1BQU0sR0FBRyxJQUFJK0QsUUFBUWpCLElBQUl0RCxDQUFDO1FBQzFGO0lBQ0Y7SUFFQSxPQUFPMkI7QUFDVDtBQUVBLGlEQUFpRDtBQUMxQyxTQUFTOEMsZUFDZDlDLFNBQStCO1FBQy9CK0MsUUFBQUEsaUVBQWdCO0lBRWhCLE1BQU1DLFNBQVMsSUFBSS9DO0lBQ25CLEtBQUssTUFBTSxDQUFDTSxJQUFJb0IsSUFBSSxJQUFJM0IsVUFBVztRQUNqQ2dELE9BQU9qQyxHQUFHLENBQUNSLElBQUk7WUFDYm5DLEdBQUd1RCxJQUFJdkQsQ0FBQyxHQUFHMkU7WUFDWDFFLEdBQUdzRCxJQUFJdEQsQ0FBQyxHQUFHMEU7UUFDYjtJQUNGO0lBQ0EsT0FBT0M7QUFDVCIsInNvdXJjZXMiOlsiL1VzZXJzL3prc29qdS9Eb2N1bWVudHMvR2l0SHViL2xvYS1jb25zdHJ1Y3RzL2FwcHMvZXhwbG9yZXIvbGliL2RhdGEvY29tcHV0ZS1sYXlvdXQudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBDb25zdHJ1Y3ROb2RlLCBDb25zdHJ1Y3RFZGdlLCBEb21haW4gfSBmcm9tICdAL2xpYi90eXBlcy9ncmFwaCc7XG5cbmludGVyZmFjZSBWZWN0b3IyIHtcbiAgeDogbnVtYmVyO1xuICB5OiBudW1iZXI7XG59XG5cbmludGVyZmFjZSBMYXlvdXRDb25maWcge1xuICB3aWR0aDogbnVtYmVyO1xuICBoZWlnaHQ6IG51bWJlcjtcbiAgaXRlcmF0aW9uczogbnVtYmVyO1xuICByZXB1bHNpb25TdHJlbmd0aDogbnVtYmVyO1xuICBhdHRyYWN0aW9uU3RyZW5ndGg6IG51bWJlcjtcbiAgZG9tYWluR3Jhdml0eTogbnVtYmVyO1xufVxuXG4vLyBEb21haW4gY2x1c3RlciBjZW50ZXJzIC0gYXJyYW5nZWQgaW4gYSBoZXhhZ29uYWwgcGF0dGVybiAoc3ByZWFkIG91dCBtb3JlKVxuY29uc3QgRE9NQUlOX0NFTlRFUlM6IFJlY29yZDxEb21haW4sIFZlY3RvcjI+ID0ge1xuICBndG06IHsgeDogLTMyMCwgeTogMTQwIH0sXG4gIGRldjogeyB4OiAzMjAsIHk6IDE0MCB9LFxuICBzZWN1cml0eTogeyB4OiAwLCB5OiAtMjgwIH0sXG4gIG9wczogeyB4OiAzMjAsIHk6IC0xNDAgfSxcbiAgZG9jczogeyB4OiAtMzIwLCB5OiAtMTQwIH0sXG4gIGFuYWx5dGljczogeyB4OiAwLCB5OiAyODAgfSxcbn07XG5cbmNvbnN0IERFRkFVTFRfQ09ORklHOiBMYXlvdXRDb25maWcgPSB7XG4gIHdpZHRoOiAxMDAwLFxuICBoZWlnaHQ6IDcwMCxcbiAgaXRlcmF0aW9uczogNTAsXG4gIHJlcHVsc2lvblN0cmVuZ3RoOiAxMjAwMCxcbiAgYXR0cmFjdGlvblN0cmVuZ3RoOiAwLjA1LFxuICBkb21haW5HcmF2aXR5OiAwLjAzLFxufTtcblxuZnVuY3Rpb24gZGlzdGFuY2UoYTogVmVjdG9yMiwgYjogVmVjdG9yMik6IG51bWJlciB7XG4gIGNvbnN0IGR4ID0gYS54IC0gYi54O1xuICBjb25zdCBkeSA9IGEueSAtIGIueTtcbiAgcmV0dXJuIE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZSh2OiBWZWN0b3IyKTogVmVjdG9yMiB7XG4gIGNvbnN0IGxlbiA9IE1hdGguc3FydCh2LnggKiB2LnggKyB2LnkgKiB2LnkpO1xuICBpZiAobGVuID09PSAwKSByZXR1cm4geyB4OiAwLCB5OiAwIH07XG4gIHJldHVybiB7IHg6IHYueCAvIGxlbiwgeTogdi55IC8gbGVuIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlTGF5b3V0KFxuICBub2RlczogQ29uc3RydWN0Tm9kZVtdLFxuICBlZGdlczogQ29uc3RydWN0RWRnZVtdLFxuICBjb25maWc6IExheW91dENvbmZpZyA9IERFRkFVTFRfQ09ORklHXG4pOiBNYXA8c3RyaW5nLCBWZWN0b3IyPiB7XG4gIGNvbnN0IHBvc2l0aW9ucyA9IG5ldyBNYXA8c3RyaW5nLCBWZWN0b3IyPigpO1xuICBjb25zdCB2ZWxvY2l0aWVzID0gbmV3IE1hcDxzdHJpbmcsIFZlY3RvcjI+KCk7XG5cbiAgLy8gSW5pdGlhbGl6ZSBwb3NpdGlvbnMgbmVhciBkb21haW4gY2VudGVycyB3aXRoIHNvbWUgcmFuZG9tbmVzc1xuICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZXMpIHtcbiAgICBjb25zdCBjZW50ZXIgPSBET01BSU5fQ0VOVEVSU1tub2RlLmRvbWFpbl0gfHwgeyB4OiAwLCB5OiAwIH07XG4gICAgLy8gVXNlIG5vZGUgaWQgaGFzaCBmb3IgZGV0ZXJtaW5pc3RpYyBcInJhbmRvbW5lc3NcIlxuICAgIGNvbnN0IGhhc2ggPSBub2RlLmlkLnNwbGl0KCcnKS5yZWR1Y2UoKGEsIGMpID0+IGEgKyBjLmNoYXJDb2RlQXQoMCksIDApO1xuICAgIGNvbnN0IGFuZ2xlID0gKGhhc2ggJSAzNjApICogKE1hdGguUEkgLyAxODApO1xuICAgIGNvbnN0IHJhZGl1cyA9IDYwICsgKGhhc2ggJSA4MCk7XG5cbiAgICBwb3NpdGlvbnMuc2V0KG5vZGUuaWQsIHtcbiAgICAgIHg6IGNlbnRlci54ICsgTWF0aC5jb3MoYW5nbGUpICogcmFkaXVzLFxuICAgICAgeTogY2VudGVyLnkgKyBNYXRoLnNpbihhbmdsZSkgKiByYWRpdXMsXG4gICAgfSk7XG4gICAgdmVsb2NpdGllcy5zZXQobm9kZS5pZCwgeyB4OiAwLCB5OiAwIH0pO1xuICB9XG5cbiAgLy8gQnVpbGQgZWRnZSBsb29rdXAgZm9yIGZhc3RlciBhY2Nlc3NcbiAgY29uc3QgZWRnZU1hcCA9IG5ldyBNYXA8c3RyaW5nLCBzdHJpbmdbXT4oKTtcbiAgZm9yIChjb25zdCBlZGdlIG9mIGVkZ2VzKSB7XG4gICAgaWYgKCFlZGdlTWFwLmhhcyhlZGdlLnNvdXJjZSkpIGVkZ2VNYXAuc2V0KGVkZ2Uuc291cmNlLCBbXSk7XG4gICAgaWYgKCFlZGdlTWFwLmhhcyhlZGdlLnRhcmdldCkpIGVkZ2VNYXAuc2V0KGVkZ2UudGFyZ2V0LCBbXSk7XG4gICAgZWRnZU1hcC5nZXQoZWRnZS5zb3VyY2UpIS5wdXNoKGVkZ2UudGFyZ2V0KTtcbiAgICBlZGdlTWFwLmdldChlZGdlLnRhcmdldCkhLnB1c2goZWRnZS5zb3VyY2UpO1xuICB9XG5cbiAgLy8gUnVuIHNpbXVsYXRpb25cbiAgZm9yIChsZXQgaXRlciA9IDA7IGl0ZXIgPCBjb25maWcuaXRlcmF0aW9uczsgaXRlcisrKSB7XG4gICAgY29uc3QgY29vbGluZyA9IDEgLSBpdGVyIC8gY29uZmlnLml0ZXJhdGlvbnM7XG5cbiAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZXMpIHtcbiAgICAgIGNvbnN0IHBvcyA9IHBvc2l0aW9ucy5nZXQobm9kZS5pZCkhO1xuICAgICAgbGV0IGZ4ID0gMDtcbiAgICAgIGxldCBmeSA9IDA7XG5cbiAgICAgIC8vIFJlcHVsc2lvbiBmcm9tIGFsbCBvdGhlciBub2Rlc1xuICAgICAgZm9yIChjb25zdCBvdGhlciBvZiBub2Rlcykge1xuICAgICAgICBpZiAob3RoZXIuaWQgPT09IG5vZGUuaWQpIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCBvdGhlclBvcyA9IHBvc2l0aW9ucy5nZXQob3RoZXIuaWQpITtcbiAgICAgICAgY29uc3QgZGlzdCA9IE1hdGgubWF4KGRpc3RhbmNlKHBvcywgb3RoZXJQb3MpLCAxKTtcbiAgICAgICAgY29uc3QgcmVwdWxzaW9uID0gY29uZmlnLnJlcHVsc2lvblN0cmVuZ3RoIC8gKGRpc3QgKiBkaXN0KTtcbiAgICAgICAgY29uc3QgZGlyID0gbm9ybWFsaXplKHsgeDogcG9zLnggLSBvdGhlclBvcy54LCB5OiBwb3MueSAtIG90aGVyUG9zLnkgfSk7XG4gICAgICAgIGZ4ICs9IGRpci54ICogcmVwdWxzaW9uO1xuICAgICAgICBmeSArPSBkaXIueSAqIHJlcHVsc2lvbjtcbiAgICAgIH1cblxuICAgICAgLy8gQXR0cmFjdGlvbiB0byBjb25uZWN0ZWQgbm9kZXNcbiAgICAgIGNvbnN0IGNvbm5lY3RlZCA9IGVkZ2VNYXAuZ2V0KG5vZGUuaWQpIHx8IFtdO1xuICAgICAgZm9yIChjb25zdCBjb25uZWN0ZWRJZCBvZiBjb25uZWN0ZWQpIHtcbiAgICAgICAgY29uc3QgY29ubmVjdGVkUG9zID0gcG9zaXRpb25zLmdldChjb25uZWN0ZWRJZCk7XG4gICAgICAgIGlmICghY29ubmVjdGVkUG9zKSBjb250aW51ZTtcbiAgICAgICAgY29uc3QgZGlzdCA9IGRpc3RhbmNlKHBvcywgY29ubmVjdGVkUG9zKTtcbiAgICAgICAgY29uc3QgYXR0cmFjdGlvbiA9IGRpc3QgKiBjb25maWcuYXR0cmFjdGlvblN0cmVuZ3RoO1xuICAgICAgICBjb25zdCBkaXIgPSBub3JtYWxpemUoe1xuICAgICAgICAgIHg6IGNvbm5lY3RlZFBvcy54IC0gcG9zLngsXG4gICAgICAgICAgeTogY29ubmVjdGVkUG9zLnkgLSBwb3MueSxcbiAgICAgICAgfSk7XG4gICAgICAgIGZ4ICs9IGRpci54ICogYXR0cmFjdGlvbjtcbiAgICAgICAgZnkgKz0gZGlyLnkgKiBhdHRyYWN0aW9uO1xuICAgICAgfVxuXG4gICAgICAvLyBEb21haW4gZ3Jhdml0eSAtIHB1bGwgdG93YXJkIGNsdXN0ZXIgY2VudGVyXG4gICAgICBjb25zdCBjZW50ZXIgPSBET01BSU5fQ0VOVEVSU1tub2RlLmRvbWFpbl0gfHwgeyB4OiAwLCB5OiAwIH07XG4gICAgICBjb25zdCB0b0NlbnRlclggPSBjZW50ZXIueCAtIHBvcy54O1xuICAgICAgY29uc3QgdG9DZW50ZXJZID0gY2VudGVyLnkgLSBwb3MueTtcbiAgICAgIGZ4ICs9IHRvQ2VudGVyWCAqIGNvbmZpZy5kb21haW5HcmF2aXR5O1xuICAgICAgZnkgKz0gdG9DZW50ZXJZICogY29uZmlnLmRvbWFpbkdyYXZpdHk7XG5cbiAgICAgIC8vIFBhY2tzIGdldCBleHRyYSBjZW50cmFsIGdyYXZpdHlcbiAgICAgIGlmIChub2RlLnR5cGUgPT09ICdwYWNrJykge1xuICAgICAgICBmeCArPSAtcG9zLnggKiAwLjAxO1xuICAgICAgICBmeSArPSAtcG9zLnkgKiAwLjAxO1xuICAgICAgfVxuXG4gICAgICAvLyBVcGRhdGUgdmVsb2NpdHkgd2l0aCBkYW1waW5nXG4gICAgICBjb25zdCB2ZWwgPSB2ZWxvY2l0aWVzLmdldChub2RlLmlkKSE7XG4gICAgICB2ZWwueCA9ICh2ZWwueCArIGZ4KSAqIDAuNSAqIGNvb2xpbmc7XG4gICAgICB2ZWwueSA9ICh2ZWwueSArIGZ5KSAqIDAuNSAqIGNvb2xpbmc7XG5cbiAgICAgIC8vIFVwZGF0ZSBwb3NpdGlvblxuICAgICAgcG9zLnggKz0gdmVsLng7XG4gICAgICBwb3MueSArPSB2ZWwueTtcblxuICAgICAgLy8gQ2xhbXAgdG8gYm91bmRzXG4gICAgICBjb25zdCBtYXJnaW4gPSA1MDtcbiAgICAgIHBvcy54ID0gTWF0aC5tYXgoLWNvbmZpZy53aWR0aCAvIDIgKyBtYXJnaW4sIE1hdGgubWluKGNvbmZpZy53aWR0aCAvIDIgLSBtYXJnaW4sIHBvcy54KSk7XG4gICAgICBwb3MueSA9IE1hdGgubWF4KC1jb25maWcuaGVpZ2h0IC8gMiArIG1hcmdpbiwgTWF0aC5taW4oY29uZmlnLmhlaWdodCAvIDIgLSBtYXJnaW4sIHBvcy55KSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBvc2l0aW9ucztcbn1cblxuLy8gU2NhbGUgcG9zaXRpb25zIGZvciBUaHJlZS5qcyBjb29yZGluYXRlIHN5c3RlbVxuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlUG9zaXRpb25zKFxuICBwb3NpdGlvbnM6IE1hcDxzdHJpbmcsIFZlY3RvcjI+LFxuICBzY2FsZTogbnVtYmVyID0gMC4wMVxuKTogTWFwPHN0cmluZywgVmVjdG9yMj4ge1xuICBjb25zdCBzY2FsZWQgPSBuZXcgTWFwPHN0cmluZywgVmVjdG9yMj4oKTtcbiAgZm9yIChjb25zdCBbaWQsIHBvc10gb2YgcG9zaXRpb25zKSB7XG4gICAgc2NhbGVkLnNldChpZCwge1xuICAgICAgeDogcG9zLnggKiBzY2FsZSxcbiAgICAgIHk6IHBvcy55ICogc2NhbGUsXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHNjYWxlZDtcbn1cbiJdLCJuYW1lcyI6WyJET01BSU5fQ0VOVEVSUyIsImd0bSIsIngiLCJ5IiwiZGV2Iiwic2VjdXJpdHkiLCJvcHMiLCJkb2NzIiwiYW5hbHl0aWNzIiwiREVGQVVMVF9DT05GSUciLCJ3aWR0aCIsImhlaWdodCIsIml0ZXJhdGlvbnMiLCJyZXB1bHNpb25TdHJlbmd0aCIsImF0dHJhY3Rpb25TdHJlbmd0aCIsImRvbWFpbkdyYXZpdHkiLCJkaXN0YW5jZSIsImEiLCJiIiwiZHgiLCJkeSIsIk1hdGgiLCJzcXJ0Iiwibm9ybWFsaXplIiwidiIsImxlbiIsImNvbXB1dGVMYXlvdXQiLCJub2RlcyIsImVkZ2VzIiwiY29uZmlnIiwicG9zaXRpb25zIiwiTWFwIiwidmVsb2NpdGllcyIsIm5vZGUiLCJjZW50ZXIiLCJkb21haW4iLCJoYXNoIiwiaWQiLCJzcGxpdCIsInJlZHVjZSIsImMiLCJjaGFyQ29kZUF0IiwiYW5nbGUiLCJQSSIsInJhZGl1cyIsInNldCIsImNvcyIsInNpbiIsImVkZ2VNYXAiLCJlZGdlIiwiaGFzIiwic291cmNlIiwidGFyZ2V0IiwiZ2V0IiwicHVzaCIsIml0ZXIiLCJjb29saW5nIiwicG9zIiwiZngiLCJmeSIsIm90aGVyIiwib3RoZXJQb3MiLCJkaXN0IiwibWF4IiwicmVwdWxzaW9uIiwiZGlyIiwiY29ubmVjdGVkIiwiY29ubmVjdGVkSWQiLCJjb25uZWN0ZWRQb3MiLCJhdHRyYWN0aW9uIiwidG9DZW50ZXJYIiwidG9DZW50ZXJZIiwidHlwZSIsInZlbCIsIm1hcmdpbiIsIm1pbiIsInNjYWxlUG9zaXRpb25zIiwic2NhbGUiLCJzY2FsZWQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/data/compute-layout.ts\n"));

/***/ })

});