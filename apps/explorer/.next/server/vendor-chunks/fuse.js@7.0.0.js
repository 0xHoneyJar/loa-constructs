"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/fuse.js@7.0.0";
exports.ids = ["vendor-chunks/fuse.js@7.0.0"];
exports.modules = {

/***/ "(ssr)/../../node_modules/.pnpm/fuse.js@7.0.0/node_modules/fuse.js/dist/fuse.mjs":
/*!*********************************************************************************!*\
  !*** ../../node_modules/.pnpm/fuse.js@7.0.0/node_modules/fuse.js/dist/fuse.mjs ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Fuse)\n/* harmony export */ });\n/**\n * Fuse.js v7.0.0 - Lightweight fuzzy-search (http://fusejs.io)\n *\n * Copyright (c) 2023 Kiro Risk (http://kiro.me)\n * All Rights Reserved. Apache Software License 2.0\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n */ function isArray(value) {\n    return !Array.isArray ? getTag(value) === '[object Array]' : Array.isArray(value);\n}\n// Adapted from: https://github.com/lodash/lodash/blob/master/.internal/baseToString.js\nconst INFINITY = 1 / 0;\nfunction baseToString(value) {\n    // Exit early for strings to avoid a performance hit in some environments.\n    if (typeof value == 'string') {\n        return value;\n    }\n    let result = value + '';\n    return result == '0' && 1 / value == -INFINITY ? '-0' : result;\n}\nfunction toString(value) {\n    return value == null ? '' : baseToString(value);\n}\nfunction isString(value) {\n    return typeof value === 'string';\n}\nfunction isNumber(value) {\n    return typeof value === 'number';\n}\n// Adapted from: https://github.com/lodash/lodash/blob/master/isBoolean.js\nfunction isBoolean(value) {\n    return value === true || value === false || isObjectLike(value) && getTag(value) == '[object Boolean]';\n}\nfunction isObject(value) {\n    return typeof value === 'object';\n}\n// Checks if `value` is object-like.\nfunction isObjectLike(value) {\n    return isObject(value) && value !== null;\n}\nfunction isDefined(value) {\n    return value !== undefined && value !== null;\n}\nfunction isBlank(value) {\n    return !value.trim().length;\n}\n// Gets the `toStringTag` of `value`.\n// Adapted from: https://github.com/lodash/lodash/blob/master/.internal/getTag.js\nfunction getTag(value) {\n    return value == null ? value === undefined ? '[object Undefined]' : '[object Null]' : Object.prototype.toString.call(value);\n}\nconst EXTENDED_SEARCH_UNAVAILABLE = 'Extended search is not available';\nconst INCORRECT_INDEX_TYPE = \"Incorrect 'index' type\";\nconst LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY = (key)=>`Invalid value for key ${key}`;\nconst PATTERN_LENGTH_TOO_LARGE = (max)=>`Pattern length exceeds max of ${max}.`;\nconst MISSING_KEY_PROPERTY = (name)=>`Missing ${name} property in key`;\nconst INVALID_KEY_WEIGHT_VALUE = (key)=>`Property 'weight' in key '${key}' must be a positive integer`;\nconst hasOwn = Object.prototype.hasOwnProperty;\nclass KeyStore {\n    constructor(keys){\n        this._keys = [];\n        this._keyMap = {};\n        let totalWeight = 0;\n        keys.forEach((key)=>{\n            let obj = createKey(key);\n            this._keys.push(obj);\n            this._keyMap[obj.id] = obj;\n            totalWeight += obj.weight;\n        });\n        // Normalize weights so that their sum is equal to 1\n        this._keys.forEach((key)=>{\n            key.weight /= totalWeight;\n        });\n    }\n    get(keyId) {\n        return this._keyMap[keyId];\n    }\n    keys() {\n        return this._keys;\n    }\n    toJSON() {\n        return JSON.stringify(this._keys);\n    }\n}\nfunction createKey(key) {\n    let path = null;\n    let id = null;\n    let src = null;\n    let weight = 1;\n    let getFn = null;\n    if (isString(key) || isArray(key)) {\n        src = key;\n        path = createKeyPath(key);\n        id = createKeyId(key);\n    } else {\n        if (!hasOwn.call(key, 'name')) {\n            throw new Error(MISSING_KEY_PROPERTY('name'));\n        }\n        const name = key.name;\n        src = name;\n        if (hasOwn.call(key, 'weight')) {\n            weight = key.weight;\n            if (weight <= 0) {\n                throw new Error(INVALID_KEY_WEIGHT_VALUE(name));\n            }\n        }\n        path = createKeyPath(name);\n        id = createKeyId(name);\n        getFn = key.getFn;\n    }\n    return {\n        path,\n        id,\n        weight,\n        src,\n        getFn\n    };\n}\nfunction createKeyPath(key) {\n    return isArray(key) ? key : key.split('.');\n}\nfunction createKeyId(key) {\n    return isArray(key) ? key.join('.') : key;\n}\nfunction get(obj, path) {\n    let list = [];\n    let arr = false;\n    const deepGet = (obj, path, index)=>{\n        if (!isDefined(obj)) {\n            return;\n        }\n        if (!path[index]) {\n            // If there's no path left, we've arrived at the object we care about.\n            list.push(obj);\n        } else {\n            let key = path[index];\n            const value = obj[key];\n            if (!isDefined(value)) {\n                return;\n            }\n            // If we're at the last value in the path, and if it's a string/number/bool,\n            // add it to the list\n            if (index === path.length - 1 && (isString(value) || isNumber(value) || isBoolean(value))) {\n                list.push(toString(value));\n            } else if (isArray(value)) {\n                arr = true;\n                // Search each item in the array.\n                for(let i = 0, len = value.length; i < len; i += 1){\n                    deepGet(value[i], path, index + 1);\n                }\n            } else if (path.length) {\n                // An object. Recurse further.\n                deepGet(value, path, index + 1);\n            }\n        }\n    };\n    // Backwards compatibility (since path used to be a string)\n    deepGet(obj, isString(path) ? path.split('.') : path, 0);\n    return arr ? list : list[0];\n}\nconst MatchOptions = {\n    // Whether the matches should be included in the result set. When `true`, each record in the result\n    // set will include the indices of the matched characters.\n    // These can consequently be used for highlighting purposes.\n    includeMatches: false,\n    // When `true`, the matching function will continue to the end of a search pattern even if\n    // a perfect match has already been located in the string.\n    findAllMatches: false,\n    // Minimum number of characters that must be matched before a result is considered a match\n    minMatchCharLength: 1\n};\nconst BasicOptions = {\n    // When `true`, the algorithm continues searching to the end of the input even if a perfect\n    // match is found before the end of the same input.\n    isCaseSensitive: false,\n    // When true, the matching function will continue to the end of a search pattern even if\n    includeScore: false,\n    // List of properties that will be searched. This also supports nested properties.\n    keys: [],\n    // Whether to sort the result list, by score\n    shouldSort: true,\n    // Default sort function: sort by ascending score, ascending index\n    sortFn: (a, b)=>a.score === b.score ? a.idx < b.idx ? -1 : 1 : a.score < b.score ? -1 : 1\n};\nconst FuzzyOptions = {\n    // Approximately where in the text is the pattern expected to be found?\n    location: 0,\n    // At what point does the match algorithm give up. A threshold of '0.0' requires a perfect match\n    // (of both letters and location), a threshold of '1.0' would match anything.\n    threshold: 0.6,\n    // Determines how close the match must be to the fuzzy location (specified above).\n    // An exact letter match which is 'distance' characters away from the fuzzy location\n    // would score as a complete mismatch. A distance of '0' requires the match be at\n    // the exact location specified, a threshold of '1000' would require a perfect match\n    // to be within 800 characters of the fuzzy location to be found using a 0.8 threshold.\n    distance: 100\n};\nconst AdvancedOptions = {\n    // When `true`, it enables the use of unix-like search commands\n    useExtendedSearch: false,\n    // The get function to use when fetching an object's properties.\n    // The default will search nested paths *ie foo.bar.baz*\n    getFn: get,\n    // When `true`, search will ignore `location` and `distance`, so it won't matter\n    // where in the string the pattern appears.\n    // More info: https://fusejs.io/concepts/scoring-theory.html#fuzziness-score\n    ignoreLocation: false,\n    // When `true`, the calculation for the relevance score (used for sorting) will\n    // ignore the field-length norm.\n    // More info: https://fusejs.io/concepts/scoring-theory.html#field-length-norm\n    ignoreFieldNorm: false,\n    // The weight to determine how much field length norm effects scoring.\n    fieldNormWeight: 1\n};\nvar Config = {\n    ...BasicOptions,\n    ...MatchOptions,\n    ...FuzzyOptions,\n    ...AdvancedOptions\n};\nconst SPACE = /[^ ]+/g;\n// Field-length norm: the shorter the field, the higher the weight.\n// Set to 3 decimals to reduce index size.\nfunction norm(weight = 1, mantissa = 3) {\n    const cache = new Map();\n    const m = Math.pow(10, mantissa);\n    return {\n        get (value) {\n            const numTokens = value.match(SPACE).length;\n            if (cache.has(numTokens)) {\n                return cache.get(numTokens);\n            }\n            // Default function is 1/sqrt(x), weight makes that variable\n            const norm = 1 / Math.pow(numTokens, 0.5 * weight);\n            // In place of `toFixed(mantissa)`, for faster computation\n            const n = parseFloat(Math.round(norm * m) / m);\n            cache.set(numTokens, n);\n            return n;\n        },\n        clear () {\n            cache.clear();\n        }\n    };\n}\nclass FuseIndex {\n    constructor({ getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}){\n        this.norm = norm(fieldNormWeight, 3);\n        this.getFn = getFn;\n        this.isCreated = false;\n        this.setIndexRecords();\n    }\n    setSources(docs = []) {\n        this.docs = docs;\n    }\n    setIndexRecords(records = []) {\n        this.records = records;\n    }\n    setKeys(keys = []) {\n        this.keys = keys;\n        this._keysMap = {};\n        keys.forEach((key, idx)=>{\n            this._keysMap[key.id] = idx;\n        });\n    }\n    create() {\n        if (this.isCreated || !this.docs.length) {\n            return;\n        }\n        this.isCreated = true;\n        // List is Array<String>\n        if (isString(this.docs[0])) {\n            this.docs.forEach((doc, docIndex)=>{\n                this._addString(doc, docIndex);\n            });\n        } else {\n            // List is Array<Object>\n            this.docs.forEach((doc, docIndex)=>{\n                this._addObject(doc, docIndex);\n            });\n        }\n        this.norm.clear();\n    }\n    // Adds a doc to the end of the index\n    add(doc) {\n        const idx = this.size();\n        if (isString(doc)) {\n            this._addString(doc, idx);\n        } else {\n            this._addObject(doc, idx);\n        }\n    }\n    // Removes the doc at the specified index of the index\n    removeAt(idx) {\n        this.records.splice(idx, 1);\n        // Change ref index of every subsquent doc\n        for(let i = idx, len = this.size(); i < len; i += 1){\n            this.records[i].i -= 1;\n        }\n    }\n    getValueForItemAtKeyId(item, keyId) {\n        return item[this._keysMap[keyId]];\n    }\n    size() {\n        return this.records.length;\n    }\n    _addString(doc, docIndex) {\n        if (!isDefined(doc) || isBlank(doc)) {\n            return;\n        }\n        let record = {\n            v: doc,\n            i: docIndex,\n            n: this.norm.get(doc)\n        };\n        this.records.push(record);\n    }\n    _addObject(doc, docIndex) {\n        let record = {\n            i: docIndex,\n            $: {}\n        };\n        // Iterate over every key (i.e, path), and fetch the value at that key\n        this.keys.forEach((key, keyIndex)=>{\n            let value = key.getFn ? key.getFn(doc) : this.getFn(doc, key.path);\n            if (!isDefined(value)) {\n                return;\n            }\n            if (isArray(value)) {\n                let subRecords = [];\n                const stack = [\n                    {\n                        nestedArrIndex: -1,\n                        value\n                    }\n                ];\n                while(stack.length){\n                    const { nestedArrIndex, value } = stack.pop();\n                    if (!isDefined(value)) {\n                        continue;\n                    }\n                    if (isString(value) && !isBlank(value)) {\n                        let subRecord = {\n                            v: value,\n                            i: nestedArrIndex,\n                            n: this.norm.get(value)\n                        };\n                        subRecords.push(subRecord);\n                    } else if (isArray(value)) {\n                        value.forEach((item, k)=>{\n                            stack.push({\n                                nestedArrIndex: k,\n                                value: item\n                            });\n                        });\n                    } else ;\n                }\n                record.$[keyIndex] = subRecords;\n            } else if (isString(value) && !isBlank(value)) {\n                let subRecord = {\n                    v: value,\n                    n: this.norm.get(value)\n                };\n                record.$[keyIndex] = subRecord;\n            }\n        });\n        this.records.push(record);\n    }\n    toJSON() {\n        return {\n            keys: this.keys,\n            records: this.records\n        };\n    }\n}\nfunction createIndex(keys, docs, { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}) {\n    const myIndex = new FuseIndex({\n        getFn,\n        fieldNormWeight\n    });\n    myIndex.setKeys(keys.map(createKey));\n    myIndex.setSources(docs);\n    myIndex.create();\n    return myIndex;\n}\nfunction parseIndex(data, { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}) {\n    const { keys, records } = data;\n    const myIndex = new FuseIndex({\n        getFn,\n        fieldNormWeight\n    });\n    myIndex.setKeys(keys);\n    myIndex.setIndexRecords(records);\n    return myIndex;\n}\nfunction computeScore$1(pattern, { errors = 0, currentLocation = 0, expectedLocation = 0, distance = Config.distance, ignoreLocation = Config.ignoreLocation } = {}) {\n    const accuracy = errors / pattern.length;\n    if (ignoreLocation) {\n        return accuracy;\n    }\n    const proximity = Math.abs(expectedLocation - currentLocation);\n    if (!distance) {\n        // Dodge divide by zero error.\n        return proximity ? 1.0 : accuracy;\n    }\n    return accuracy + proximity / distance;\n}\nfunction convertMaskToIndices(matchmask = [], minMatchCharLength = Config.minMatchCharLength) {\n    let indices = [];\n    let start = -1;\n    let end = -1;\n    let i = 0;\n    for(let len = matchmask.length; i < len; i += 1){\n        let match = matchmask[i];\n        if (match && start === -1) {\n            start = i;\n        } else if (!match && start !== -1) {\n            end = i - 1;\n            if (end - start + 1 >= minMatchCharLength) {\n                indices.push([\n                    start,\n                    end\n                ]);\n            }\n            start = -1;\n        }\n    }\n    // (i-1 - start) + 1 => i - start\n    if (matchmask[i - 1] && i - start >= minMatchCharLength) {\n        indices.push([\n            start,\n            i - 1\n        ]);\n    }\n    return indices;\n}\n// Machine word size\nconst MAX_BITS = 32;\nfunction search(text, pattern, patternAlphabet, { location = Config.location, distance = Config.distance, threshold = Config.threshold, findAllMatches = Config.findAllMatches, minMatchCharLength = Config.minMatchCharLength, includeMatches = Config.includeMatches, ignoreLocation = Config.ignoreLocation } = {}) {\n    if (pattern.length > MAX_BITS) {\n        throw new Error(PATTERN_LENGTH_TOO_LARGE(MAX_BITS));\n    }\n    const patternLen = pattern.length;\n    // Set starting location at beginning text and initialize the alphabet.\n    const textLen = text.length;\n    // Handle the case when location > text.length\n    const expectedLocation = Math.max(0, Math.min(location, textLen));\n    // Highest score beyond which we give up.\n    let currentThreshold = threshold;\n    // Is there a nearby exact match? (speedup)\n    let bestLocation = expectedLocation;\n    // Performance: only computer matches when the minMatchCharLength > 1\n    // OR if `includeMatches` is true.\n    const computeMatches = minMatchCharLength > 1 || includeMatches;\n    // A mask of the matches, used for building the indices\n    const matchMask = computeMatches ? Array(textLen) : [];\n    let index;\n    // Get all exact matches, here for speed up\n    while((index = text.indexOf(pattern, bestLocation)) > -1){\n        let score = computeScore$1(pattern, {\n            currentLocation: index,\n            expectedLocation,\n            distance,\n            ignoreLocation\n        });\n        currentThreshold = Math.min(score, currentThreshold);\n        bestLocation = index + patternLen;\n        if (computeMatches) {\n            let i = 0;\n            while(i < patternLen){\n                matchMask[index + i] = 1;\n                i += 1;\n            }\n        }\n    }\n    // Reset the best location\n    bestLocation = -1;\n    let lastBitArr = [];\n    let finalScore = 1;\n    let binMax = patternLen + textLen;\n    const mask = 1 << patternLen - 1;\n    for(let i = 0; i < patternLen; i += 1){\n        // Scan for the best match; each iteration allows for one more error.\n        // Run a binary search to determine how far from the match location we can stray\n        // at this error level.\n        let binMin = 0;\n        let binMid = binMax;\n        while(binMin < binMid){\n            const score = computeScore$1(pattern, {\n                errors: i,\n                currentLocation: expectedLocation + binMid,\n                expectedLocation,\n                distance,\n                ignoreLocation\n            });\n            if (score <= currentThreshold) {\n                binMin = binMid;\n            } else {\n                binMax = binMid;\n            }\n            binMid = Math.floor((binMax - binMin) / 2 + binMin);\n        }\n        // Use the result from this iteration as the maximum for the next.\n        binMax = binMid;\n        let start = Math.max(1, expectedLocation - binMid + 1);\n        let finish = findAllMatches ? textLen : Math.min(expectedLocation + binMid, textLen) + patternLen;\n        // Initialize the bit array\n        let bitArr = Array(finish + 2);\n        bitArr[finish + 1] = (1 << i) - 1;\n        for(let j = finish; j >= start; j -= 1){\n            let currentLocation = j - 1;\n            let charMatch = patternAlphabet[text.charAt(currentLocation)];\n            if (computeMatches) {\n                // Speed up: quick bool to int conversion (i.e, `charMatch ? 1 : 0`)\n                matchMask[currentLocation] = +!!charMatch;\n            }\n            // First pass: exact match\n            bitArr[j] = (bitArr[j + 1] << 1 | 1) & charMatch;\n            // Subsequent passes: fuzzy match\n            if (i) {\n                bitArr[j] |= (lastBitArr[j + 1] | lastBitArr[j]) << 1 | 1 | lastBitArr[j + 1];\n            }\n            if (bitArr[j] & mask) {\n                finalScore = computeScore$1(pattern, {\n                    errors: i,\n                    currentLocation,\n                    expectedLocation,\n                    distance,\n                    ignoreLocation\n                });\n                // This match will almost certainly be better than any existing match.\n                // But check anyway.\n                if (finalScore <= currentThreshold) {\n                    // Indeed it is\n                    currentThreshold = finalScore;\n                    bestLocation = currentLocation;\n                    // Already passed `loc`, downhill from here on in.\n                    if (bestLocation <= expectedLocation) {\n                        break;\n                    }\n                    // When passing `bestLocation`, don't exceed our current distance from `expectedLocation`.\n                    start = Math.max(1, 2 * expectedLocation - bestLocation);\n                }\n            }\n        }\n        // No hope for a (better) match at greater error levels.\n        const score = computeScore$1(pattern, {\n            errors: i + 1,\n            currentLocation: expectedLocation,\n            expectedLocation,\n            distance,\n            ignoreLocation\n        });\n        if (score > currentThreshold) {\n            break;\n        }\n        lastBitArr = bitArr;\n    }\n    const result = {\n        isMatch: bestLocation >= 0,\n        // Count exact matches (those with a score of 0) to be \"almost\" exact\n        score: Math.max(0.001, finalScore)\n    };\n    if (computeMatches) {\n        const indices = convertMaskToIndices(matchMask, minMatchCharLength);\n        if (!indices.length) {\n            result.isMatch = false;\n        } else if (includeMatches) {\n            result.indices = indices;\n        }\n    }\n    return result;\n}\nfunction createPatternAlphabet(pattern) {\n    let mask = {};\n    for(let i = 0, len = pattern.length; i < len; i += 1){\n        const char = pattern.charAt(i);\n        mask[char] = (mask[char] || 0) | 1 << len - i - 1;\n    }\n    return mask;\n}\nclass BitapSearch {\n    constructor(pattern, { location = Config.location, threshold = Config.threshold, distance = Config.distance, includeMatches = Config.includeMatches, findAllMatches = Config.findAllMatches, minMatchCharLength = Config.minMatchCharLength, isCaseSensitive = Config.isCaseSensitive, ignoreLocation = Config.ignoreLocation } = {}){\n        this.options = {\n            location,\n            threshold,\n            distance,\n            includeMatches,\n            findAllMatches,\n            minMatchCharLength,\n            isCaseSensitive,\n            ignoreLocation\n        };\n        this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();\n        this.chunks = [];\n        if (!this.pattern.length) {\n            return;\n        }\n        const addChunk = (pattern, startIndex)=>{\n            this.chunks.push({\n                pattern,\n                alphabet: createPatternAlphabet(pattern),\n                startIndex\n            });\n        };\n        const len = this.pattern.length;\n        if (len > MAX_BITS) {\n            let i = 0;\n            const remainder = len % MAX_BITS;\n            const end = len - remainder;\n            while(i < end){\n                addChunk(this.pattern.substr(i, MAX_BITS), i);\n                i += MAX_BITS;\n            }\n            if (remainder) {\n                const startIndex = len - MAX_BITS;\n                addChunk(this.pattern.substr(startIndex), startIndex);\n            }\n        } else {\n            addChunk(this.pattern, 0);\n        }\n    }\n    searchIn(text) {\n        const { isCaseSensitive, includeMatches } = this.options;\n        if (!isCaseSensitive) {\n            text = text.toLowerCase();\n        }\n        // Exact match\n        if (this.pattern === text) {\n            let result = {\n                isMatch: true,\n                score: 0\n            };\n            if (includeMatches) {\n                result.indices = [\n                    [\n                        0,\n                        text.length - 1\n                    ]\n                ];\n            }\n            return result;\n        }\n        // Otherwise, use Bitap algorithm\n        const { location, distance, threshold, findAllMatches, minMatchCharLength, ignoreLocation } = this.options;\n        let allIndices = [];\n        let totalScore = 0;\n        let hasMatches = false;\n        this.chunks.forEach(({ pattern, alphabet, startIndex })=>{\n            const { isMatch, score, indices } = search(text, pattern, alphabet, {\n                location: location + startIndex,\n                distance,\n                threshold,\n                findAllMatches,\n                minMatchCharLength,\n                includeMatches,\n                ignoreLocation\n            });\n            if (isMatch) {\n                hasMatches = true;\n            }\n            totalScore += score;\n            if (isMatch && indices) {\n                allIndices = [\n                    ...allIndices,\n                    ...indices\n                ];\n            }\n        });\n        let result = {\n            isMatch: hasMatches,\n            score: hasMatches ? totalScore / this.chunks.length : 1\n        };\n        if (hasMatches && includeMatches) {\n            result.indices = allIndices;\n        }\n        return result;\n    }\n}\nclass BaseMatch {\n    constructor(pattern){\n        this.pattern = pattern;\n    }\n    static isMultiMatch(pattern) {\n        return getMatch(pattern, this.multiRegex);\n    }\n    static isSingleMatch(pattern) {\n        return getMatch(pattern, this.singleRegex);\n    }\n    search() {}\n}\nfunction getMatch(pattern, exp) {\n    const matches = pattern.match(exp);\n    return matches ? matches[1] : null;\n}\n// Token: 'file\nclass ExactMatch extends BaseMatch {\n    constructor(pattern){\n        super(pattern);\n    }\n    static get type() {\n        return 'exact';\n    }\n    static get multiRegex() {\n        return /^=\"(.*)\"$/;\n    }\n    static get singleRegex() {\n        return /^=(.*)$/;\n    }\n    search(text) {\n        const isMatch = text === this.pattern;\n        return {\n            isMatch,\n            score: isMatch ? 0 : 1,\n            indices: [\n                0,\n                this.pattern.length - 1\n            ]\n        };\n    }\n}\n// Token: !fire\nclass InverseExactMatch extends BaseMatch {\n    constructor(pattern){\n        super(pattern);\n    }\n    static get type() {\n        return 'inverse-exact';\n    }\n    static get multiRegex() {\n        return /^!\"(.*)\"$/;\n    }\n    static get singleRegex() {\n        return /^!(.*)$/;\n    }\n    search(text) {\n        const index = text.indexOf(this.pattern);\n        const isMatch = index === -1;\n        return {\n            isMatch,\n            score: isMatch ? 0 : 1,\n            indices: [\n                0,\n                text.length - 1\n            ]\n        };\n    }\n}\n// Token: ^file\nclass PrefixExactMatch extends BaseMatch {\n    constructor(pattern){\n        super(pattern);\n    }\n    static get type() {\n        return 'prefix-exact';\n    }\n    static get multiRegex() {\n        return /^\\^\"(.*)\"$/;\n    }\n    static get singleRegex() {\n        return /^\\^(.*)$/;\n    }\n    search(text) {\n        const isMatch = text.startsWith(this.pattern);\n        return {\n            isMatch,\n            score: isMatch ? 0 : 1,\n            indices: [\n                0,\n                this.pattern.length - 1\n            ]\n        };\n    }\n}\n// Token: !^fire\nclass InversePrefixExactMatch extends BaseMatch {\n    constructor(pattern){\n        super(pattern);\n    }\n    static get type() {\n        return 'inverse-prefix-exact';\n    }\n    static get multiRegex() {\n        return /^!\\^\"(.*)\"$/;\n    }\n    static get singleRegex() {\n        return /^!\\^(.*)$/;\n    }\n    search(text) {\n        const isMatch = !text.startsWith(this.pattern);\n        return {\n            isMatch,\n            score: isMatch ? 0 : 1,\n            indices: [\n                0,\n                text.length - 1\n            ]\n        };\n    }\n}\n// Token: .file$\nclass SuffixExactMatch extends BaseMatch {\n    constructor(pattern){\n        super(pattern);\n    }\n    static get type() {\n        return 'suffix-exact';\n    }\n    static get multiRegex() {\n        return /^\"(.*)\"\\$$/;\n    }\n    static get singleRegex() {\n        return /^(.*)\\$$/;\n    }\n    search(text) {\n        const isMatch = text.endsWith(this.pattern);\n        return {\n            isMatch,\n            score: isMatch ? 0 : 1,\n            indices: [\n                text.length - this.pattern.length,\n                text.length - 1\n            ]\n        };\n    }\n}\n// Token: !.file$\nclass InverseSuffixExactMatch extends BaseMatch {\n    constructor(pattern){\n        super(pattern);\n    }\n    static get type() {\n        return 'inverse-suffix-exact';\n    }\n    static get multiRegex() {\n        return /^!\"(.*)\"\\$$/;\n    }\n    static get singleRegex() {\n        return /^!(.*)\\$$/;\n    }\n    search(text) {\n        const isMatch = !text.endsWith(this.pattern);\n        return {\n            isMatch,\n            score: isMatch ? 0 : 1,\n            indices: [\n                0,\n                text.length - 1\n            ]\n        };\n    }\n}\nclass FuzzyMatch extends BaseMatch {\n    constructor(pattern, { location = Config.location, threshold = Config.threshold, distance = Config.distance, includeMatches = Config.includeMatches, findAllMatches = Config.findAllMatches, minMatchCharLength = Config.minMatchCharLength, isCaseSensitive = Config.isCaseSensitive, ignoreLocation = Config.ignoreLocation } = {}){\n        super(pattern);\n        this._bitapSearch = new BitapSearch(pattern, {\n            location,\n            threshold,\n            distance,\n            includeMatches,\n            findAllMatches,\n            minMatchCharLength,\n            isCaseSensitive,\n            ignoreLocation\n        });\n    }\n    static get type() {\n        return 'fuzzy';\n    }\n    static get multiRegex() {\n        return /^\"(.*)\"$/;\n    }\n    static get singleRegex() {\n        return /^(.*)$/;\n    }\n    search(text) {\n        return this._bitapSearch.searchIn(text);\n    }\n}\n// Token: 'file\nclass IncludeMatch extends BaseMatch {\n    constructor(pattern){\n        super(pattern);\n    }\n    static get type() {\n        return 'include';\n    }\n    static get multiRegex() {\n        return /^'\"(.*)\"$/;\n    }\n    static get singleRegex() {\n        return /^'(.*)$/;\n    }\n    search(text) {\n        let location = 0;\n        let index;\n        const indices = [];\n        const patternLen = this.pattern.length;\n        // Get all exact matches\n        while((index = text.indexOf(this.pattern, location)) > -1){\n            location = index + patternLen;\n            indices.push([\n                index,\n                location - 1\n            ]);\n        }\n        const isMatch = !!indices.length;\n        return {\n            isMatch,\n            score: isMatch ? 0 : 1,\n            indices\n        };\n    }\n}\n// â—Order is important. DO NOT CHANGE.\nconst searchers = [\n    ExactMatch,\n    IncludeMatch,\n    PrefixExactMatch,\n    InversePrefixExactMatch,\n    InverseSuffixExactMatch,\n    SuffixExactMatch,\n    InverseExactMatch,\n    FuzzyMatch\n];\nconst searchersLen = searchers.length;\n// Regex to split by spaces, but keep anything in quotes together\nconst SPACE_RE = / +(?=(?:[^\\\"]*\\\"[^\\\"]*\\\")*[^\\\"]*$)/;\nconst OR_TOKEN = '|';\n// Return a 2D array representation of the query, for simpler parsing.\n// Example:\n// \"^core go$ | rb$ | py$ xy$\" => [[\"^core\", \"go$\"], [\"rb$\"], [\"py$\", \"xy$\"]]\nfunction parseQuery(pattern, options = {}) {\n    return pattern.split(OR_TOKEN).map((item)=>{\n        let query = item.trim().split(SPACE_RE).filter((item)=>item && !!item.trim());\n        let results = [];\n        for(let i = 0, len = query.length; i < len; i += 1){\n            const queryItem = query[i];\n            // 1. Handle multiple query match (i.e, once that are quoted, like `\"hello world\"`)\n            let found = false;\n            let idx = -1;\n            while(!found && ++idx < searchersLen){\n                const searcher = searchers[idx];\n                let token = searcher.isMultiMatch(queryItem);\n                if (token) {\n                    results.push(new searcher(token, options));\n                    found = true;\n                }\n            }\n            if (found) {\n                continue;\n            }\n            // 2. Handle single query matches (i.e, once that are *not* quoted)\n            idx = -1;\n            while(++idx < searchersLen){\n                const searcher = searchers[idx];\n                let token = searcher.isSingleMatch(queryItem);\n                if (token) {\n                    results.push(new searcher(token, options));\n                    break;\n                }\n            }\n        }\n        return results;\n    });\n}\n// These extended matchers can return an array of matches, as opposed\n// to a singl match\nconst MultiMatchSet = new Set([\n    FuzzyMatch.type,\n    IncludeMatch.type\n]);\n/**\n * Command-like searching\n * ======================\n *\n * Given multiple search terms delimited by spaces.e.g. `^jscript .python$ ruby !java`,\n * search in a given text.\n *\n * Search syntax:\n *\n * | Token       | Match type                 | Description                            |\n * | ----------- | -------------------------- | -------------------------------------- |\n * | `jscript`   | fuzzy-match                | Items that fuzzy match `jscript`       |\n * | `=scheme`   | exact-match                | Items that are `scheme`                |\n * | `'python`   | include-match              | Items that include `python`            |\n * | `!ruby`     | inverse-exact-match        | Items that do not include `ruby`       |\n * | `^java`     | prefix-exact-match         | Items that start with `java`           |\n * | `!^earlang` | inverse-prefix-exact-match | Items that do not start with `earlang` |\n * | `.js$`      | suffix-exact-match         | Items that end with `.js`              |\n * | `!.go$`     | inverse-suffix-exact-match | Items that do not end with `.go`       |\n *\n * A single pipe character acts as an OR operator. For example, the following\n * query matches entries that start with `core` and end with either`go`, `rb`,\n * or`py`.\n *\n * ```\n * ^core go$ | rb$ | py$\n * ```\n */ class ExtendedSearch {\n    constructor(pattern, { isCaseSensitive = Config.isCaseSensitive, includeMatches = Config.includeMatches, minMatchCharLength = Config.minMatchCharLength, ignoreLocation = Config.ignoreLocation, findAllMatches = Config.findAllMatches, location = Config.location, threshold = Config.threshold, distance = Config.distance } = {}){\n        this.query = null;\n        this.options = {\n            isCaseSensitive,\n            includeMatches,\n            minMatchCharLength,\n            findAllMatches,\n            ignoreLocation,\n            location,\n            threshold,\n            distance\n        };\n        this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();\n        this.query = parseQuery(this.pattern, this.options);\n    }\n    static condition(_, options) {\n        return options.useExtendedSearch;\n    }\n    searchIn(text) {\n        const query = this.query;\n        if (!query) {\n            return {\n                isMatch: false,\n                score: 1\n            };\n        }\n        const { includeMatches, isCaseSensitive } = this.options;\n        text = isCaseSensitive ? text : text.toLowerCase();\n        let numMatches = 0;\n        let allIndices = [];\n        let totalScore = 0;\n        // ORs\n        for(let i = 0, qLen = query.length; i < qLen; i += 1){\n            const searchers = query[i];\n            // Reset indices\n            allIndices.length = 0;\n            numMatches = 0;\n            // ANDs\n            for(let j = 0, pLen = searchers.length; j < pLen; j += 1){\n                const searcher = searchers[j];\n                const { isMatch, indices, score } = searcher.search(text);\n                if (isMatch) {\n                    numMatches += 1;\n                    totalScore += score;\n                    if (includeMatches) {\n                        const type = searcher.constructor.type;\n                        if (MultiMatchSet.has(type)) {\n                            allIndices = [\n                                ...allIndices,\n                                ...indices\n                            ];\n                        } else {\n                            allIndices.push(indices);\n                        }\n                    }\n                } else {\n                    totalScore = 0;\n                    numMatches = 0;\n                    allIndices.length = 0;\n                    break;\n                }\n            }\n            // OR condition, so if TRUE, return\n            if (numMatches) {\n                let result = {\n                    isMatch: true,\n                    score: totalScore / numMatches\n                };\n                if (includeMatches) {\n                    result.indices = allIndices;\n                }\n                return result;\n            }\n        }\n        // Nothing was matched\n        return {\n            isMatch: false,\n            score: 1\n        };\n    }\n}\nconst registeredSearchers = [];\nfunction register(...args) {\n    registeredSearchers.push(...args);\n}\nfunction createSearcher(pattern, options) {\n    for(let i = 0, len = registeredSearchers.length; i < len; i += 1){\n        let searcherClass = registeredSearchers[i];\n        if (searcherClass.condition(pattern, options)) {\n            return new searcherClass(pattern, options);\n        }\n    }\n    return new BitapSearch(pattern, options);\n}\nconst LogicalOperator = {\n    AND: '$and',\n    OR: '$or'\n};\nconst KeyType = {\n    PATH: '$path',\n    PATTERN: '$val'\n};\nconst isExpression = (query)=>!!(query[LogicalOperator.AND] || query[LogicalOperator.OR]);\nconst isPath = (query)=>!!query[KeyType.PATH];\nconst isLeaf = (query)=>!isArray(query) && isObject(query) && !isExpression(query);\nconst convertToExplicit = (query)=>({\n        [LogicalOperator.AND]: Object.keys(query).map((key)=>({\n                [key]: query[key]\n            }))\n    });\n// When `auto` is `true`, the parse function will infer and initialize and add\n// the appropriate `Searcher` instance\nfunction parse(query, options, { auto = true } = {}) {\n    const next = (query)=>{\n        let keys = Object.keys(query);\n        const isQueryPath = isPath(query);\n        if (!isQueryPath && keys.length > 1 && !isExpression(query)) {\n            return next(convertToExplicit(query));\n        }\n        if (isLeaf(query)) {\n            const key = isQueryPath ? query[KeyType.PATH] : keys[0];\n            const pattern = isQueryPath ? query[KeyType.PATTERN] : query[key];\n            if (!isString(pattern)) {\n                throw new Error(LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key));\n            }\n            const obj = {\n                keyId: createKeyId(key),\n                pattern\n            };\n            if (auto) {\n                obj.searcher = createSearcher(pattern, options);\n            }\n            return obj;\n        }\n        let node = {\n            children: [],\n            operator: keys[0]\n        };\n        keys.forEach((key)=>{\n            const value = query[key];\n            if (isArray(value)) {\n                value.forEach((item)=>{\n                    node.children.push(next(item));\n                });\n            }\n        });\n        return node;\n    };\n    if (!isExpression(query)) {\n        query = convertToExplicit(query);\n    }\n    return next(query);\n}\n// Practical scoring function\nfunction computeScore(results, { ignoreFieldNorm = Config.ignoreFieldNorm }) {\n    results.forEach((result)=>{\n        let totalScore = 1;\n        result.matches.forEach(({ key, norm, score })=>{\n            const weight = key ? key.weight : null;\n            totalScore *= Math.pow(score === 0 && weight ? Number.EPSILON : score, (weight || 1) * (ignoreFieldNorm ? 1 : norm));\n        });\n        result.score = totalScore;\n    });\n}\nfunction transformMatches(result, data) {\n    const matches = result.matches;\n    data.matches = [];\n    if (!isDefined(matches)) {\n        return;\n    }\n    matches.forEach((match)=>{\n        if (!isDefined(match.indices) || !match.indices.length) {\n            return;\n        }\n        const { indices, value } = match;\n        let obj = {\n            indices,\n            value\n        };\n        if (match.key) {\n            obj.key = match.key.src;\n        }\n        if (match.idx > -1) {\n            obj.refIndex = match.idx;\n        }\n        data.matches.push(obj);\n    });\n}\nfunction transformScore(result, data) {\n    data.score = result.score;\n}\nfunction format(results, docs, { includeMatches = Config.includeMatches, includeScore = Config.includeScore } = {}) {\n    const transformers = [];\n    if (includeMatches) transformers.push(transformMatches);\n    if (includeScore) transformers.push(transformScore);\n    return results.map((result)=>{\n        const { idx } = result;\n        const data = {\n            item: docs[idx],\n            refIndex: idx\n        };\n        if (transformers.length) {\n            transformers.forEach((transformer)=>{\n                transformer(result, data);\n            });\n        }\n        return data;\n    });\n}\nclass Fuse {\n    constructor(docs, options = {}, index){\n        this.options = {\n            ...Config,\n            ...options\n        };\n        if (this.options.useExtendedSearch && !true) {}\n        this._keyStore = new KeyStore(this.options.keys);\n        this.setCollection(docs, index);\n    }\n    setCollection(docs, index) {\n        this._docs = docs;\n        if (index && !(index instanceof FuseIndex)) {\n            throw new Error(INCORRECT_INDEX_TYPE);\n        }\n        this._myIndex = index || createIndex(this.options.keys, this._docs, {\n            getFn: this.options.getFn,\n            fieldNormWeight: this.options.fieldNormWeight\n        });\n    }\n    add(doc) {\n        if (!isDefined(doc)) {\n            return;\n        }\n        this._docs.push(doc);\n        this._myIndex.add(doc);\n    }\n    remove(predicate = ()=>false) {\n        const results = [];\n        for(let i = 0, len = this._docs.length; i < len; i += 1){\n            const doc = this._docs[i];\n            if (predicate(doc, i)) {\n                this.removeAt(i);\n                i -= 1;\n                len -= 1;\n                results.push(doc);\n            }\n        }\n        return results;\n    }\n    removeAt(idx) {\n        this._docs.splice(idx, 1);\n        this._myIndex.removeAt(idx);\n    }\n    getIndex() {\n        return this._myIndex;\n    }\n    search(query, { limit = -1 } = {}) {\n        const { includeMatches, includeScore, shouldSort, sortFn, ignoreFieldNorm } = this.options;\n        let results = isString(query) ? isString(this._docs[0]) ? this._searchStringList(query) : this._searchObjectList(query) : this._searchLogical(query);\n        computeScore(results, {\n            ignoreFieldNorm\n        });\n        if (shouldSort) {\n            results.sort(sortFn);\n        }\n        if (isNumber(limit) && limit > -1) {\n            results = results.slice(0, limit);\n        }\n        return format(results, this._docs, {\n            includeMatches,\n            includeScore\n        });\n    }\n    _searchStringList(query) {\n        const searcher = createSearcher(query, this.options);\n        const { records } = this._myIndex;\n        const results = [];\n        // Iterate over every string in the index\n        records.forEach(({ v: text, i: idx, n: norm })=>{\n            if (!isDefined(text)) {\n                return;\n            }\n            const { isMatch, score, indices } = searcher.searchIn(text);\n            if (isMatch) {\n                results.push({\n                    item: text,\n                    idx,\n                    matches: [\n                        {\n                            score,\n                            value: text,\n                            norm,\n                            indices\n                        }\n                    ]\n                });\n            }\n        });\n        return results;\n    }\n    _searchLogical(query) {\n        const expression = parse(query, this.options);\n        const evaluate = (node, item, idx)=>{\n            if (!node.children) {\n                const { keyId, searcher } = node;\n                const matches = this._findMatches({\n                    key: this._keyStore.get(keyId),\n                    value: this._myIndex.getValueForItemAtKeyId(item, keyId),\n                    searcher\n                });\n                if (matches && matches.length) {\n                    return [\n                        {\n                            idx,\n                            item,\n                            matches\n                        }\n                    ];\n                }\n                return [];\n            }\n            const res = [];\n            for(let i = 0, len = node.children.length; i < len; i += 1){\n                const child = node.children[i];\n                const result = evaluate(child, item, idx);\n                if (result.length) {\n                    res.push(...result);\n                } else if (node.operator === LogicalOperator.AND) {\n                    return [];\n                }\n            }\n            return res;\n        };\n        const records = this._myIndex.records;\n        const resultMap = {};\n        const results = [];\n        records.forEach(({ $: item, i: idx })=>{\n            if (isDefined(item)) {\n                let expResults = evaluate(expression, item, idx);\n                if (expResults.length) {\n                    // Dedupe when adding\n                    if (!resultMap[idx]) {\n                        resultMap[idx] = {\n                            idx,\n                            item,\n                            matches: []\n                        };\n                        results.push(resultMap[idx]);\n                    }\n                    expResults.forEach(({ matches })=>{\n                        resultMap[idx].matches.push(...matches);\n                    });\n                }\n            }\n        });\n        return results;\n    }\n    _searchObjectList(query) {\n        const searcher = createSearcher(query, this.options);\n        const { keys, records } = this._myIndex;\n        const results = [];\n        // List is Array<Object>\n        records.forEach(({ $: item, i: idx })=>{\n            if (!isDefined(item)) {\n                return;\n            }\n            let matches = [];\n            // Iterate over every key (i.e, path), and fetch the value at that key\n            keys.forEach((key, keyIndex)=>{\n                matches.push(...this._findMatches({\n                    key,\n                    value: item[keyIndex],\n                    searcher\n                }));\n            });\n            if (matches.length) {\n                results.push({\n                    idx,\n                    item,\n                    matches\n                });\n            }\n        });\n        return results;\n    }\n    _findMatches({ key, value, searcher }) {\n        if (!isDefined(value)) {\n            return [];\n        }\n        let matches = [];\n        if (isArray(value)) {\n            value.forEach(({ v: text, i: idx, n: norm })=>{\n                if (!isDefined(text)) {\n                    return;\n                }\n                const { isMatch, score, indices } = searcher.searchIn(text);\n                if (isMatch) {\n                    matches.push({\n                        score,\n                        key,\n                        value: text,\n                        idx,\n                        norm,\n                        indices\n                    });\n                }\n            });\n        } else {\n            const { v: text, n: norm } = value;\n            const { isMatch, score, indices } = searcher.searchIn(text);\n            if (isMatch) {\n                matches.push({\n                    score,\n                    key,\n                    value: text,\n                    norm,\n                    indices\n                });\n            }\n        }\n        return matches;\n    }\n}\nFuse.version = '7.0.0';\nFuse.createIndex = createIndex;\nFuse.parseIndex = parseIndex;\nFuse.config = Config;\n{\n    Fuse.parseQuery = parse;\n}{\n    register(ExtendedSearch);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2Z1c2UuanNANy4wLjAvbm9kZV9tb2R1bGVzL2Z1c2UuanMvZGlzdC9mdXNlLm1qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7Ozs7Ozs7Q0FPQyxHQUVELFNBQVNBLFFBQVFDLEtBQUs7SUFDcEIsT0FBTyxDQUFDQyxNQUFNRixPQUFPLEdBQ2pCRyxPQUFPRixXQUFXLG1CQUNsQkMsTUFBTUYsT0FBTyxDQUFDQztBQUNwQjtBQUVBLHVGQUF1RjtBQUN2RixNQUFNRyxXQUFXLElBQUk7QUFDckIsU0FBU0MsYUFBYUosS0FBSztJQUN6QiwwRUFBMEU7SUFDMUUsSUFBSSxPQUFPQSxTQUFTLFVBQVU7UUFDNUIsT0FBT0E7SUFDVDtJQUNBLElBQUlLLFNBQVNMLFFBQVE7SUFDckIsT0FBT0ssVUFBVSxPQUFPLElBQUlMLFNBQVMsQ0FBQ0csV0FBVyxPQUFPRTtBQUMxRDtBQUVBLFNBQVNDLFNBQVNOLEtBQUs7SUFDckIsT0FBT0EsU0FBUyxPQUFPLEtBQUtJLGFBQWFKO0FBQzNDO0FBRUEsU0FBU08sU0FBU1AsS0FBSztJQUNyQixPQUFPLE9BQU9BLFVBQVU7QUFDMUI7QUFFQSxTQUFTUSxTQUFTUixLQUFLO0lBQ3JCLE9BQU8sT0FBT0EsVUFBVTtBQUMxQjtBQUVBLDBFQUEwRTtBQUMxRSxTQUFTUyxVQUFVVCxLQUFLO0lBQ3RCLE9BQ0VBLFVBQVUsUUFDVkEsVUFBVSxTQUNUVSxhQUFhVixVQUFVRSxPQUFPRixVQUFVO0FBRTdDO0FBRUEsU0FBU1csU0FBU1gsS0FBSztJQUNyQixPQUFPLE9BQU9BLFVBQVU7QUFDMUI7QUFFQSxvQ0FBb0M7QUFDcEMsU0FBU1UsYUFBYVYsS0FBSztJQUN6QixPQUFPVyxTQUFTWCxVQUFVQSxVQUFVO0FBQ3RDO0FBRUEsU0FBU1ksVUFBVVosS0FBSztJQUN0QixPQUFPQSxVQUFVYSxhQUFhYixVQUFVO0FBQzFDO0FBRUEsU0FBU2MsUUFBUWQsS0FBSztJQUNwQixPQUFPLENBQUNBLE1BQU1lLElBQUksR0FBR0MsTUFBTTtBQUM3QjtBQUVBLHFDQUFxQztBQUNyQyxpRkFBaUY7QUFDakYsU0FBU2QsT0FBT0YsS0FBSztJQUNuQixPQUFPQSxTQUFTLE9BQ1pBLFVBQVVhLFlBQ1IsdUJBQ0Esa0JBQ0ZJLE9BQU9DLFNBQVMsQ0FBQ1osUUFBUSxDQUFDYSxJQUFJLENBQUNuQjtBQUNyQztBQUVBLE1BQU1vQiw4QkFBOEI7QUFFcEMsTUFBTUMsdUJBQXVCO0FBRTdCLE1BQU1DLHVDQUF1QyxDQUFDQyxNQUM1QyxDQUFDLHNCQUFzQixFQUFFQSxLQUFLO0FBRWhDLE1BQU1DLDJCQUEyQixDQUFDQyxNQUNoQyxDQUFDLDhCQUE4QixFQUFFQSxJQUFJLENBQUMsQ0FBQztBQUV6QyxNQUFNQyx1QkFBdUIsQ0FBQ0MsT0FBUyxDQUFDLFFBQVEsRUFBRUEsS0FBSyxnQkFBZ0IsQ0FBQztBQUV4RSxNQUFNQywyQkFBMkIsQ0FBQ0wsTUFDaEMsQ0FBQywwQkFBMEIsRUFBRUEsSUFBSSw0QkFBNEIsQ0FBQztBQUVoRSxNQUFNTSxTQUFTWixPQUFPQyxTQUFTLENBQUNZLGNBQWM7QUFFOUMsTUFBTUM7SUFDSkMsWUFBWUMsSUFBSSxDQUFFO1FBQ2hCLElBQUksQ0FBQ0MsS0FBSyxHQUFHLEVBQUU7UUFDZixJQUFJLENBQUNDLE9BQU8sR0FBRyxDQUFDO1FBRWhCLElBQUlDLGNBQWM7UUFFbEJILEtBQUtJLE9BQU8sQ0FBQyxDQUFDZDtZQUNaLElBQUllLE1BQU1DLFVBQVVoQjtZQUVwQixJQUFJLENBQUNXLEtBQUssQ0FBQ00sSUFBSSxDQUFDRjtZQUNoQixJQUFJLENBQUNILE9BQU8sQ0FBQ0csSUFBSUcsRUFBRSxDQUFDLEdBQUdIO1lBRXZCRixlQUFlRSxJQUFJSSxNQUFNO1FBQzNCO1FBRUEsb0RBQW9EO1FBQ3BELElBQUksQ0FBQ1IsS0FBSyxDQUFDRyxPQUFPLENBQUMsQ0FBQ2Q7WUFDbEJBLElBQUltQixNQUFNLElBQUlOO1FBQ2hCO0lBQ0Y7SUFDQU8sSUFBSUMsS0FBSyxFQUFFO1FBQ1QsT0FBTyxJQUFJLENBQUNULE9BQU8sQ0FBQ1MsTUFBTTtJQUM1QjtJQUNBWCxPQUFPO1FBQ0wsT0FBTyxJQUFJLENBQUNDLEtBQUs7SUFDbkI7SUFDQVcsU0FBUztRQUNQLE9BQU9DLEtBQUtDLFNBQVMsQ0FBQyxJQUFJLENBQUNiLEtBQUs7SUFDbEM7QUFDRjtBQUVBLFNBQVNLLFVBQVVoQixHQUFHO0lBQ3BCLElBQUl5QixPQUFPO0lBQ1gsSUFBSVAsS0FBSztJQUNULElBQUlRLE1BQU07SUFDVixJQUFJUCxTQUFTO0lBQ2IsSUFBSVEsUUFBUTtJQUVaLElBQUkzQyxTQUFTZ0IsUUFBUXhCLFFBQVF3QixNQUFNO1FBQ2pDMEIsTUFBTTFCO1FBQ055QixPQUFPRyxjQUFjNUI7UUFDckJrQixLQUFLVyxZQUFZN0I7SUFDbkIsT0FBTztRQUNMLElBQUksQ0FBQ00sT0FBT1YsSUFBSSxDQUFDSSxLQUFLLFNBQVM7WUFDN0IsTUFBTSxJQUFJOEIsTUFBTTNCLHFCQUFxQjtRQUN2QztRQUVBLE1BQU1DLE9BQU9KLElBQUlJLElBQUk7UUFDckJzQixNQUFNdEI7UUFFTixJQUFJRSxPQUFPVixJQUFJLENBQUNJLEtBQUssV0FBVztZQUM5Qm1CLFNBQVNuQixJQUFJbUIsTUFBTTtZQUVuQixJQUFJQSxVQUFVLEdBQUc7Z0JBQ2YsTUFBTSxJQUFJVyxNQUFNekIseUJBQXlCRDtZQUMzQztRQUNGO1FBRUFxQixPQUFPRyxjQUFjeEI7UUFDckJjLEtBQUtXLFlBQVl6QjtRQUNqQnVCLFFBQVEzQixJQUFJMkIsS0FBSztJQUNuQjtJQUVBLE9BQU87UUFBRUY7UUFBTVA7UUFBSUM7UUFBUU87UUFBS0M7SUFBTTtBQUN4QztBQUVBLFNBQVNDLGNBQWM1QixHQUFHO0lBQ3hCLE9BQU94QixRQUFRd0IsT0FBT0EsTUFBTUEsSUFBSStCLEtBQUssQ0FBQztBQUN4QztBQUVBLFNBQVNGLFlBQVk3QixHQUFHO0lBQ3RCLE9BQU94QixRQUFRd0IsT0FBT0EsSUFBSWdDLElBQUksQ0FBQyxPQUFPaEM7QUFDeEM7QUFFQSxTQUFTb0IsSUFBSUwsR0FBRyxFQUFFVSxJQUFJO0lBQ3BCLElBQUlRLE9BQU8sRUFBRTtJQUNiLElBQUlDLE1BQU07SUFFVixNQUFNQyxVQUFVLENBQUNwQixLQUFLVSxNQUFNVztRQUMxQixJQUFJLENBQUMvQyxVQUFVMEIsTUFBTTtZQUNuQjtRQUNGO1FBQ0EsSUFBSSxDQUFDVSxJQUFJLENBQUNXLE1BQU0sRUFBRTtZQUNoQixzRUFBc0U7WUFDdEVILEtBQUtoQixJQUFJLENBQUNGO1FBQ1osT0FBTztZQUNMLElBQUlmLE1BQU15QixJQUFJLENBQUNXLE1BQU07WUFFckIsTUFBTTNELFFBQVFzQyxHQUFHLENBQUNmLElBQUk7WUFFdEIsSUFBSSxDQUFDWCxVQUFVWixRQUFRO2dCQUNyQjtZQUNGO1lBRUEsNEVBQTRFO1lBQzVFLHFCQUFxQjtZQUNyQixJQUNFMkQsVUFBVVgsS0FBS2hDLE1BQU0sR0FBRyxLQUN2QlQsQ0FBQUEsU0FBU1AsVUFBVVEsU0FBU1IsVUFBVVMsVUFBVVQsTUFBSyxHQUN0RDtnQkFDQXdELEtBQUtoQixJQUFJLENBQUNsQyxTQUFTTjtZQUNyQixPQUFPLElBQUlELFFBQVFDLFFBQVE7Z0JBQ3pCeUQsTUFBTTtnQkFDTixpQ0FBaUM7Z0JBQ2pDLElBQUssSUFBSUcsSUFBSSxHQUFHQyxNQUFNN0QsTUFBTWdCLE1BQU0sRUFBRTRDLElBQUlDLEtBQUtELEtBQUssRUFBRztvQkFDbkRGLFFBQVExRCxLQUFLLENBQUM0RCxFQUFFLEVBQUVaLE1BQU1XLFFBQVE7Z0JBQ2xDO1lBQ0YsT0FBTyxJQUFJWCxLQUFLaEMsTUFBTSxFQUFFO2dCQUN0Qiw4QkFBOEI7Z0JBQzlCMEMsUUFBUTFELE9BQU9nRCxNQUFNVyxRQUFRO1lBQy9CO1FBQ0Y7SUFDRjtJQUVBLDJEQUEyRDtJQUMzREQsUUFBUXBCLEtBQUsvQixTQUFTeUMsUUFBUUEsS0FBS00sS0FBSyxDQUFDLE9BQU9OLE1BQU07SUFFdEQsT0FBT1MsTUFBTUQsT0FBT0EsSUFBSSxDQUFDLEVBQUU7QUFDN0I7QUFFQSxNQUFNTSxlQUFlO0lBQ25CLG1HQUFtRztJQUNuRywwREFBMEQ7SUFDMUQsNERBQTREO0lBQzVEQyxnQkFBZ0I7SUFDaEIsMEZBQTBGO0lBQzFGLDBEQUEwRDtJQUMxREMsZ0JBQWdCO0lBQ2hCLDBGQUEwRjtJQUMxRkMsb0JBQW9CO0FBQ3RCO0FBRUEsTUFBTUMsZUFBZTtJQUNuQiwyRkFBMkY7SUFDM0YsbURBQW1EO0lBQ25EQyxpQkFBaUI7SUFDakIsd0ZBQXdGO0lBQ3hGQyxjQUFjO0lBQ2Qsa0ZBQWtGO0lBQ2xGbkMsTUFBTSxFQUFFO0lBQ1IsNENBQTRDO0lBQzVDb0MsWUFBWTtJQUNaLGtFQUFrRTtJQUNsRUMsUUFBUSxDQUFDQyxHQUFHQyxJQUNWRCxFQUFFRSxLQUFLLEtBQUtELEVBQUVDLEtBQUssR0FBSUYsRUFBRUcsR0FBRyxHQUFHRixFQUFFRSxHQUFHLEdBQUcsQ0FBQyxJQUFJLElBQUtILEVBQUVFLEtBQUssR0FBR0QsRUFBRUMsS0FBSyxHQUFHLENBQUMsSUFBSTtBQUM5RTtBQUVBLE1BQU1FLGVBQWU7SUFDbkIsdUVBQXVFO0lBQ3ZFQyxVQUFVO0lBQ1YsZ0dBQWdHO0lBQ2hHLDZFQUE2RTtJQUM3RUMsV0FBVztJQUNYLGtGQUFrRjtJQUNsRixvRkFBb0Y7SUFDcEYsaUZBQWlGO0lBQ2pGLG9GQUFvRjtJQUNwRix1RkFBdUY7SUFDdkZDLFVBQVU7QUFDWjtBQUVBLE1BQU1DLGtCQUFrQjtJQUN0QiwrREFBK0Q7SUFDL0RDLG1CQUFtQjtJQUNuQixnRUFBZ0U7SUFDaEUsd0RBQXdEO0lBQ3hEOUIsT0FBT1A7SUFDUCxnRkFBZ0Y7SUFDaEYsMkNBQTJDO0lBQzNDLDRFQUE0RTtJQUM1RXNDLGdCQUFnQjtJQUNoQiwrRUFBK0U7SUFDL0UsZ0NBQWdDO0lBQ2hDLDhFQUE4RTtJQUM5RUMsaUJBQWlCO0lBQ2pCLHNFQUFzRTtJQUN0RUMsaUJBQWlCO0FBQ25CO0FBRUEsSUFBSUMsU0FBUztJQUNYLEdBQUdsQixZQUFZO0lBQ2YsR0FBR0osWUFBWTtJQUNmLEdBQUdhLFlBQVk7SUFDZixHQUFHSSxlQUFlO0FBQ3BCO0FBRUEsTUFBTU0sUUFBUTtBQUVkLG1FQUFtRTtBQUNuRSwwQ0FBMEM7QUFDMUMsU0FBU0MsS0FBSzVDLFNBQVMsQ0FBQyxFQUFFNkMsV0FBVyxDQUFDO0lBQ3BDLE1BQU1DLFFBQVEsSUFBSUM7SUFDbEIsTUFBTUMsSUFBSUMsS0FBS0MsR0FBRyxDQUFDLElBQUlMO0lBRXZCLE9BQU87UUFDTDVDLEtBQUkzQyxLQUFLO1lBQ1AsTUFBTTZGLFlBQVk3RixNQUFNOEYsS0FBSyxDQUFDVCxPQUFPckUsTUFBTTtZQUUzQyxJQUFJd0UsTUFBTU8sR0FBRyxDQUFDRixZQUFZO2dCQUN4QixPQUFPTCxNQUFNN0MsR0FBRyxDQUFDa0Q7WUFDbkI7WUFFQSw0REFBNEQ7WUFDNUQsTUFBTVAsT0FBTyxJQUFJSyxLQUFLQyxHQUFHLENBQUNDLFdBQVcsTUFBTW5EO1lBRTNDLDBEQUEwRDtZQUMxRCxNQUFNc0QsSUFBSUMsV0FBV04sS0FBS08sS0FBSyxDQUFDWixPQUFPSSxLQUFLQTtZQUU1Q0YsTUFBTVcsR0FBRyxDQUFDTixXQUFXRztZQUVyQixPQUFPQTtRQUNUO1FBQ0FJO1lBQ0VaLE1BQU1ZLEtBQUs7UUFDYjtJQUNGO0FBQ0Y7QUFFQSxNQUFNQztJQUNKckUsWUFBWSxFQUNWa0IsUUFBUWtDLE9BQU9sQyxLQUFLLEVBQ3BCaUMsa0JBQWtCQyxPQUFPRCxlQUFlLEVBQ3pDLEdBQUcsQ0FBQyxDQUFDLENBQUU7UUFDTixJQUFJLENBQUNHLElBQUksR0FBR0EsS0FBS0gsaUJBQWlCO1FBQ2xDLElBQUksQ0FBQ2pDLEtBQUssR0FBR0E7UUFDYixJQUFJLENBQUNvRCxTQUFTLEdBQUc7UUFFakIsSUFBSSxDQUFDQyxlQUFlO0lBQ3RCO0lBQ0FDLFdBQVdDLE9BQU8sRUFBRSxFQUFFO1FBQ3BCLElBQUksQ0FBQ0EsSUFBSSxHQUFHQTtJQUNkO0lBQ0FGLGdCQUFnQkcsVUFBVSxFQUFFLEVBQUU7UUFDNUIsSUFBSSxDQUFDQSxPQUFPLEdBQUdBO0lBQ2pCO0lBQ0FDLFFBQVExRSxPQUFPLEVBQUUsRUFBRTtRQUNqQixJQUFJLENBQUNBLElBQUksR0FBR0E7UUFDWixJQUFJLENBQUMyRSxRQUFRLEdBQUcsQ0FBQztRQUNqQjNFLEtBQUtJLE9BQU8sQ0FBQyxDQUFDZCxLQUFLbUQ7WUFDakIsSUFBSSxDQUFDa0MsUUFBUSxDQUFDckYsSUFBSWtCLEVBQUUsQ0FBQyxHQUFHaUM7UUFDMUI7SUFDRjtJQUNBbUMsU0FBUztRQUNQLElBQUksSUFBSSxDQUFDUCxTQUFTLElBQUksQ0FBQyxJQUFJLENBQUNHLElBQUksQ0FBQ3pGLE1BQU0sRUFBRTtZQUN2QztRQUNGO1FBRUEsSUFBSSxDQUFDc0YsU0FBUyxHQUFHO1FBRWpCLHdCQUF3QjtRQUN4QixJQUFJL0YsU0FBUyxJQUFJLENBQUNrRyxJQUFJLENBQUMsRUFBRSxHQUFHO1lBQzFCLElBQUksQ0FBQ0EsSUFBSSxDQUFDcEUsT0FBTyxDQUFDLENBQUN5RSxLQUFLQztnQkFDdEIsSUFBSSxDQUFDQyxVQUFVLENBQUNGLEtBQUtDO1lBQ3ZCO1FBQ0YsT0FBTztZQUNMLHdCQUF3QjtZQUN4QixJQUFJLENBQUNOLElBQUksQ0FBQ3BFLE9BQU8sQ0FBQyxDQUFDeUUsS0FBS0M7Z0JBQ3RCLElBQUksQ0FBQ0UsVUFBVSxDQUFDSCxLQUFLQztZQUN2QjtRQUNGO1FBRUEsSUFBSSxDQUFDekIsSUFBSSxDQUFDYyxLQUFLO0lBQ2pCO0lBQ0EscUNBQXFDO0lBQ3JDYyxJQUFJSixHQUFHLEVBQUU7UUFDUCxNQUFNcEMsTUFBTSxJQUFJLENBQUN5QyxJQUFJO1FBRXJCLElBQUk1RyxTQUFTdUcsTUFBTTtZQUNqQixJQUFJLENBQUNFLFVBQVUsQ0FBQ0YsS0FBS3BDO1FBQ3ZCLE9BQU87WUFDTCxJQUFJLENBQUN1QyxVQUFVLENBQUNILEtBQUtwQztRQUN2QjtJQUNGO0lBQ0Esc0RBQXNEO0lBQ3REMEMsU0FBUzFDLEdBQUcsRUFBRTtRQUNaLElBQUksQ0FBQ2dDLE9BQU8sQ0FBQ1csTUFBTSxDQUFDM0MsS0FBSztRQUV6QiwwQ0FBMEM7UUFDMUMsSUFBSyxJQUFJZCxJQUFJYyxLQUFLYixNQUFNLElBQUksQ0FBQ3NELElBQUksSUFBSXZELElBQUlDLEtBQUtELEtBQUssRUFBRztZQUNwRCxJQUFJLENBQUM4QyxPQUFPLENBQUM5QyxFQUFFLENBQUNBLENBQUMsSUFBSTtRQUN2QjtJQUNGO0lBQ0EwRCx1QkFBdUJDLElBQUksRUFBRTNFLEtBQUssRUFBRTtRQUNsQyxPQUFPMkUsSUFBSSxDQUFDLElBQUksQ0FBQ1gsUUFBUSxDQUFDaEUsTUFBTSxDQUFDO0lBQ25DO0lBQ0F1RSxPQUFPO1FBQ0wsT0FBTyxJQUFJLENBQUNULE9BQU8sQ0FBQzFGLE1BQU07SUFDNUI7SUFDQWdHLFdBQVdGLEdBQUcsRUFBRUMsUUFBUSxFQUFFO1FBQ3hCLElBQUksQ0FBQ25HLFVBQVVrRyxRQUFRaEcsUUFBUWdHLE1BQU07WUFDbkM7UUFDRjtRQUVBLElBQUlVLFNBQVM7WUFDWEMsR0FBR1g7WUFDSGxELEdBQUdtRDtZQUNIZixHQUFHLElBQUksQ0FBQ1YsSUFBSSxDQUFDM0MsR0FBRyxDQUFDbUU7UUFDbkI7UUFFQSxJQUFJLENBQUNKLE9BQU8sQ0FBQ2xFLElBQUksQ0FBQ2dGO0lBQ3BCO0lBQ0FQLFdBQVdILEdBQUcsRUFBRUMsUUFBUSxFQUFFO1FBQ3hCLElBQUlTLFNBQVM7WUFBRTVELEdBQUdtRDtZQUFVVyxHQUFHLENBQUM7UUFBRTtRQUVsQyxzRUFBc0U7UUFDdEUsSUFBSSxDQUFDekYsSUFBSSxDQUFDSSxPQUFPLENBQUMsQ0FBQ2QsS0FBS29HO1lBQ3RCLElBQUkzSCxRQUFRdUIsSUFBSTJCLEtBQUssR0FBRzNCLElBQUkyQixLQUFLLENBQUM0RCxPQUFPLElBQUksQ0FBQzVELEtBQUssQ0FBQzRELEtBQUt2RixJQUFJeUIsSUFBSTtZQUVqRSxJQUFJLENBQUNwQyxVQUFVWixRQUFRO2dCQUNyQjtZQUNGO1lBRUEsSUFBSUQsUUFBUUMsUUFBUTtnQkFDbEIsSUFBSTRILGFBQWEsRUFBRTtnQkFDbkIsTUFBTUMsUUFBUTtvQkFBQzt3QkFBRUMsZ0JBQWdCLENBQUM7d0JBQUc5SDtvQkFBTTtpQkFBRTtnQkFFN0MsTUFBTzZILE1BQU03RyxNQUFNLENBQUU7b0JBQ25CLE1BQU0sRUFBRThHLGNBQWMsRUFBRTlILEtBQUssRUFBRSxHQUFHNkgsTUFBTUUsR0FBRztvQkFFM0MsSUFBSSxDQUFDbkgsVUFBVVosUUFBUTt3QkFDckI7b0JBQ0Y7b0JBRUEsSUFBSU8sU0FBU1AsVUFBVSxDQUFDYyxRQUFRZCxRQUFRO3dCQUN0QyxJQUFJZ0ksWUFBWTs0QkFDZFAsR0FBR3pIOzRCQUNINEQsR0FBR2tFOzRCQUNIOUIsR0FBRyxJQUFJLENBQUNWLElBQUksQ0FBQzNDLEdBQUcsQ0FBQzNDO3dCQUNuQjt3QkFFQTRILFdBQVdwRixJQUFJLENBQUN3RjtvQkFDbEIsT0FBTyxJQUFJakksUUFBUUMsUUFBUTt3QkFDekJBLE1BQU1xQyxPQUFPLENBQUMsQ0FBQ2tGLE1BQU1VOzRCQUNuQkosTUFBTXJGLElBQUksQ0FBQztnQ0FDVHNGLGdCQUFnQkc7Z0NBQ2hCakksT0FBT3VIOzRCQUNUO3dCQUNGO29CQUNGO2dCQUNGO2dCQUNBQyxPQUFPRSxDQUFDLENBQUNDLFNBQVMsR0FBR0M7WUFDdkIsT0FBTyxJQUFJckgsU0FBU1AsVUFBVSxDQUFDYyxRQUFRZCxRQUFRO2dCQUM3QyxJQUFJZ0ksWUFBWTtvQkFDZFAsR0FBR3pIO29CQUNIZ0csR0FBRyxJQUFJLENBQUNWLElBQUksQ0FBQzNDLEdBQUcsQ0FBQzNDO2dCQUNuQjtnQkFFQXdILE9BQU9FLENBQUMsQ0FBQ0MsU0FBUyxHQUFHSztZQUN2QjtRQUNGO1FBRUEsSUFBSSxDQUFDdEIsT0FBTyxDQUFDbEUsSUFBSSxDQUFDZ0Y7SUFDcEI7SUFDQTNFLFNBQVM7UUFDUCxPQUFPO1lBQ0xaLE1BQU0sSUFBSSxDQUFDQSxJQUFJO1lBQ2Z5RSxTQUFTLElBQUksQ0FBQ0EsT0FBTztRQUN2QjtJQUNGO0FBQ0Y7QUFFQSxTQUFTd0IsWUFDUGpHLElBQUksRUFDSndFLElBQUksRUFDSixFQUFFdkQsUUFBUWtDLE9BQU9sQyxLQUFLLEVBQUVpQyxrQkFBa0JDLE9BQU9ELGVBQWUsRUFBRSxHQUFHLENBQUMsQ0FBQztJQUV2RSxNQUFNZ0QsVUFBVSxJQUFJOUIsVUFBVTtRQUFFbkQ7UUFBT2lDO0lBQWdCO0lBQ3ZEZ0QsUUFBUXhCLE9BQU8sQ0FBQzFFLEtBQUttRyxHQUFHLENBQUM3RjtJQUN6QjRGLFFBQVEzQixVQUFVLENBQUNDO0lBQ25CMEIsUUFBUXRCLE1BQU07SUFDZCxPQUFPc0I7QUFDVDtBQUVBLFNBQVNFLFdBQ1BDLElBQUksRUFDSixFQUFFcEYsUUFBUWtDLE9BQU9sQyxLQUFLLEVBQUVpQyxrQkFBa0JDLE9BQU9ELGVBQWUsRUFBRSxHQUFHLENBQUMsQ0FBQztJQUV2RSxNQUFNLEVBQUVsRCxJQUFJLEVBQUV5RSxPQUFPLEVBQUUsR0FBRzRCO0lBQzFCLE1BQU1ILFVBQVUsSUFBSTlCLFVBQVU7UUFBRW5EO1FBQU9pQztJQUFnQjtJQUN2RGdELFFBQVF4QixPQUFPLENBQUMxRTtJQUNoQmtHLFFBQVE1QixlQUFlLENBQUNHO0lBQ3hCLE9BQU95QjtBQUNUO0FBRUEsU0FBU0ksZUFDUEMsT0FBTyxFQUNQLEVBQ0VDLFNBQVMsQ0FBQyxFQUNWQyxrQkFBa0IsQ0FBQyxFQUNuQkMsbUJBQW1CLENBQUMsRUFDcEI3RCxXQUFXTSxPQUFPTixRQUFRLEVBQzFCRyxpQkFBaUJHLE9BQU9ILGNBQWMsRUFDdkMsR0FBRyxDQUFDLENBQUM7SUFFTixNQUFNMkQsV0FBV0gsU0FBU0QsUUFBUXhILE1BQU07SUFFeEMsSUFBSWlFLGdCQUFnQjtRQUNsQixPQUFPMkQ7SUFDVDtJQUVBLE1BQU1DLFlBQVlsRCxLQUFLbUQsR0FBRyxDQUFDSCxtQkFBbUJEO0lBRTlDLElBQUksQ0FBQzVELFVBQVU7UUFDYiw4QkFBOEI7UUFDOUIsT0FBTytELFlBQVksTUFBTUQ7SUFDM0I7SUFFQSxPQUFPQSxXQUFXQyxZQUFZL0Q7QUFDaEM7QUFFQSxTQUFTaUUscUJBQ1BDLFlBQVksRUFBRSxFQUNkL0UscUJBQXFCbUIsT0FBT25CLGtCQUFrQjtJQUU5QyxJQUFJZ0YsVUFBVSxFQUFFO0lBQ2hCLElBQUlDLFFBQVEsQ0FBQztJQUNiLElBQUlDLE1BQU0sQ0FBQztJQUNYLElBQUl2RixJQUFJO0lBRVIsSUFBSyxJQUFJQyxNQUFNbUYsVUFBVWhJLE1BQU0sRUFBRTRDLElBQUlDLEtBQUtELEtBQUssRUFBRztRQUNoRCxJQUFJa0MsUUFBUWtELFNBQVMsQ0FBQ3BGLEVBQUU7UUFDeEIsSUFBSWtDLFNBQVNvRCxVQUFVLENBQUMsR0FBRztZQUN6QkEsUUFBUXRGO1FBQ1YsT0FBTyxJQUFJLENBQUNrQyxTQUFTb0QsVUFBVSxDQUFDLEdBQUc7WUFDakNDLE1BQU12RixJQUFJO1lBQ1YsSUFBSXVGLE1BQU1ELFFBQVEsS0FBS2pGLG9CQUFvQjtnQkFDekNnRixRQUFRekcsSUFBSSxDQUFDO29CQUFDMEc7b0JBQU9DO2lCQUFJO1lBQzNCO1lBQ0FELFFBQVEsQ0FBQztRQUNYO0lBQ0Y7SUFFQSxpQ0FBaUM7SUFDakMsSUFBSUYsU0FBUyxDQUFDcEYsSUFBSSxFQUFFLElBQUlBLElBQUlzRixTQUFTakYsb0JBQW9CO1FBQ3ZEZ0YsUUFBUXpHLElBQUksQ0FBQztZQUFDMEc7WUFBT3RGLElBQUk7U0FBRTtJQUM3QjtJQUVBLE9BQU9xRjtBQUNUO0FBRUEsb0JBQW9CO0FBQ3BCLE1BQU1HLFdBQVc7QUFFakIsU0FBU0MsT0FDUEMsSUFBSSxFQUNKZCxPQUFPLEVBQ1BlLGVBQWUsRUFDZixFQUNFM0UsV0FBV1EsT0FBT1IsUUFBUSxFQUMxQkUsV0FBV00sT0FBT04sUUFBUSxFQUMxQkQsWUFBWU8sT0FBT1AsU0FBUyxFQUM1QmIsaUJBQWlCb0IsT0FBT3BCLGNBQWMsRUFDdENDLHFCQUFxQm1CLE9BQU9uQixrQkFBa0IsRUFDOUNGLGlCQUFpQnFCLE9BQU9yQixjQUFjLEVBQ3RDa0IsaUJBQWlCRyxPQUFPSCxjQUFjLEVBQ3ZDLEdBQUcsQ0FBQyxDQUFDO0lBRU4sSUFBSXVELFFBQVF4SCxNQUFNLEdBQUdvSSxVQUFVO1FBQzdCLE1BQU0sSUFBSS9GLE1BQU03Qix5QkFBeUI0SDtJQUMzQztJQUVBLE1BQU1JLGFBQWFoQixRQUFReEgsTUFBTTtJQUNqQyx1RUFBdUU7SUFDdkUsTUFBTXlJLFVBQVVILEtBQUt0SSxNQUFNO0lBQzNCLDhDQUE4QztJQUM5QyxNQUFNMkgsbUJBQW1CaEQsS0FBS2xFLEdBQUcsQ0FBQyxHQUFHa0UsS0FBSytELEdBQUcsQ0FBQzlFLFVBQVU2RTtJQUN4RCx5Q0FBeUM7SUFDekMsSUFBSUUsbUJBQW1COUU7SUFDdkIsMkNBQTJDO0lBQzNDLElBQUkrRSxlQUFlakI7SUFFbkIscUVBQXFFO0lBQ3JFLGtDQUFrQztJQUNsQyxNQUFNa0IsaUJBQWlCNUYscUJBQXFCLEtBQUtGO0lBQ2pELHVEQUF1RDtJQUN2RCxNQUFNK0YsWUFBWUQsaUJBQWlCNUosTUFBTXdKLFdBQVcsRUFBRTtJQUV0RCxJQUFJOUY7SUFFSiwyQ0FBMkM7SUFDM0MsTUFBTyxDQUFDQSxRQUFRMkYsS0FBS1MsT0FBTyxDQUFDdkIsU0FBU29CLGFBQVksSUFBSyxDQUFDLEVBQUc7UUFDekQsSUFBSW5GLFFBQVE4RCxlQUFlQyxTQUFTO1lBQ2xDRSxpQkFBaUIvRTtZQUNqQmdGO1lBQ0E3RDtZQUNBRztRQUNGO1FBRUEwRSxtQkFBbUJoRSxLQUFLK0QsR0FBRyxDQUFDakYsT0FBT2tGO1FBQ25DQyxlQUFlakcsUUFBUTZGO1FBRXZCLElBQUlLLGdCQUFnQjtZQUNsQixJQUFJakcsSUFBSTtZQUNSLE1BQU9BLElBQUk0RixXQUFZO2dCQUNyQk0sU0FBUyxDQUFDbkcsUUFBUUMsRUFBRSxHQUFHO2dCQUN2QkEsS0FBSztZQUNQO1FBQ0Y7SUFDRjtJQUVBLDBCQUEwQjtJQUMxQmdHLGVBQWUsQ0FBQztJQUVoQixJQUFJSSxhQUFhLEVBQUU7SUFDbkIsSUFBSUMsYUFBYTtJQUNqQixJQUFJQyxTQUFTVixhQUFhQztJQUUxQixNQUFNVSxPQUFPLEtBQU1YLGFBQWE7SUFFaEMsSUFBSyxJQUFJNUYsSUFBSSxHQUFHQSxJQUFJNEYsWUFBWTVGLEtBQUssRUFBRztRQUN0QyxxRUFBcUU7UUFDckUsZ0ZBQWdGO1FBQ2hGLHVCQUF1QjtRQUN2QixJQUFJd0csU0FBUztRQUNiLElBQUlDLFNBQVNIO1FBRWIsTUFBT0UsU0FBU0MsT0FBUTtZQUN0QixNQUFNNUYsUUFBUThELGVBQWVDLFNBQVM7Z0JBQ3BDQyxRQUFRN0U7Z0JBQ1I4RSxpQkFBaUJDLG1CQUFtQjBCO2dCQUNwQzFCO2dCQUNBN0Q7Z0JBQ0FHO1lBQ0Y7WUFFQSxJQUFJUixTQUFTa0Ysa0JBQWtCO2dCQUM3QlMsU0FBU0M7WUFDWCxPQUFPO2dCQUNMSCxTQUFTRztZQUNYO1lBRUFBLFNBQVMxRSxLQUFLMkUsS0FBSyxDQUFDLENBQUNKLFNBQVNFLE1BQUssSUFBSyxJQUFJQTtRQUM5QztRQUVBLGtFQUFrRTtRQUNsRUYsU0FBU0c7UUFFVCxJQUFJbkIsUUFBUXZELEtBQUtsRSxHQUFHLENBQUMsR0FBR2tILG1CQUFtQjBCLFNBQVM7UUFDcEQsSUFBSUUsU0FBU3ZHLGlCQUNUeUYsVUFDQTlELEtBQUsrRCxHQUFHLENBQUNmLG1CQUFtQjBCLFFBQVFaLFdBQVdEO1FBRW5ELDJCQUEyQjtRQUMzQixJQUFJZ0IsU0FBU3ZLLE1BQU1zSyxTQUFTO1FBRTVCQyxNQUFNLENBQUNELFNBQVMsRUFBRSxHQUFHLENBQUMsS0FBSzNHLENBQUFBLElBQUs7UUFFaEMsSUFBSyxJQUFJNkcsSUFBSUYsUUFBUUUsS0FBS3ZCLE9BQU91QixLQUFLLEVBQUc7WUFDdkMsSUFBSS9CLGtCQUFrQitCLElBQUk7WUFDMUIsSUFBSUMsWUFBWW5CLGVBQWUsQ0FBQ0QsS0FBS3FCLE1BQU0sQ0FBQ2pDLGlCQUFpQjtZQUU3RCxJQUFJbUIsZ0JBQWdCO2dCQUNsQixvRUFBb0U7Z0JBQ3BFQyxTQUFTLENBQUNwQixnQkFBZ0IsR0FBRyxDQUFDLENBQUMsQ0FBQ2dDO1lBQ2xDO1lBRUEsMEJBQTBCO1lBQzFCRixNQUFNLENBQUNDLEVBQUUsR0FBRyxDQUFDLE1BQU8sQ0FBQ0EsSUFBSSxFQUFFLElBQUksSUFBSyxLQUFLQztZQUV6QyxpQ0FBaUM7WUFDakMsSUFBSTlHLEdBQUc7Z0JBQ0w0RyxNQUFNLENBQUNDLEVBQUUsSUFDUCxDQUFFVCxVQUFVLENBQUNTLElBQUksRUFBRSxHQUFHVCxVQUFVLENBQUNTLEVBQUUsS0FBSyxJQUFLLElBQUlULFVBQVUsQ0FBQ1MsSUFBSSxFQUFFO1lBQ3RFO1lBRUEsSUFBSUQsTUFBTSxDQUFDQyxFQUFFLEdBQUdOLE1BQU07Z0JBQ3BCRixhQUFhMUIsZUFBZUMsU0FBUztvQkFDbkNDLFFBQVE3RTtvQkFDUjhFO29CQUNBQztvQkFDQTdEO29CQUNBRztnQkFDRjtnQkFFQSxzRUFBc0U7Z0JBQ3RFLG9CQUFvQjtnQkFDcEIsSUFBSWdGLGNBQWNOLGtCQUFrQjtvQkFDbEMsZUFBZTtvQkFDZkEsbUJBQW1CTTtvQkFDbkJMLGVBQWVsQjtvQkFFZixrREFBa0Q7b0JBQ2xELElBQUlrQixnQkFBZ0JqQixrQkFBa0I7d0JBQ3BDO29CQUNGO29CQUVBLDBGQUEwRjtvQkFDMUZPLFFBQVF2RCxLQUFLbEUsR0FBRyxDQUFDLEdBQUcsSUFBSWtILG1CQUFtQmlCO2dCQUM3QztZQUNGO1FBQ0Y7UUFFQSx3REFBd0Q7UUFDeEQsTUFBTW5GLFFBQVE4RCxlQUFlQyxTQUFTO1lBQ3BDQyxRQUFRN0UsSUFBSTtZQUNaOEUsaUJBQWlCQztZQUNqQkE7WUFDQTdEO1lBQ0FHO1FBQ0Y7UUFFQSxJQUFJUixRQUFRa0Ysa0JBQWtCO1lBQzVCO1FBQ0Y7UUFFQUssYUFBYVE7SUFDZjtJQUVBLE1BQU1uSyxTQUFTO1FBQ2J1SyxTQUFTaEIsZ0JBQWdCO1FBQ3pCLHFFQUFxRTtRQUNyRW5GLE9BQU9rQixLQUFLbEUsR0FBRyxDQUFDLE9BQU93STtJQUN6QjtJQUVBLElBQUlKLGdCQUFnQjtRQUNsQixNQUFNWixVQUFVRixxQkFBcUJlLFdBQVc3RjtRQUNoRCxJQUFJLENBQUNnRixRQUFRakksTUFBTSxFQUFFO1lBQ25CWCxPQUFPdUssT0FBTyxHQUFHO1FBQ25CLE9BQU8sSUFBSTdHLGdCQUFnQjtZQUN6QjFELE9BQU80SSxPQUFPLEdBQUdBO1FBQ25CO0lBQ0Y7SUFFQSxPQUFPNUk7QUFDVDtBQUVBLFNBQVN3SyxzQkFBc0JyQyxPQUFPO0lBQ3BDLElBQUkyQixPQUFPLENBQUM7SUFFWixJQUFLLElBQUl2RyxJQUFJLEdBQUdDLE1BQU0yRSxRQUFReEgsTUFBTSxFQUFFNEMsSUFBSUMsS0FBS0QsS0FBSyxFQUFHO1FBQ3JELE1BQU1rSCxPQUFPdEMsUUFBUW1DLE1BQU0sQ0FBQy9HO1FBQzVCdUcsSUFBSSxDQUFDVyxLQUFLLEdBQUcsQ0FBQ1gsSUFBSSxDQUFDVyxLQUFLLElBQUksS0FBTSxLQUFNakgsTUFBTUQsSUFBSTtJQUNwRDtJQUVBLE9BQU91RztBQUNUO0FBRUEsTUFBTVk7SUFDSi9JLFlBQ0V3RyxPQUFPLEVBQ1AsRUFDRTVELFdBQVdRLE9BQU9SLFFBQVEsRUFDMUJDLFlBQVlPLE9BQU9QLFNBQVMsRUFDNUJDLFdBQVdNLE9BQU9OLFFBQVEsRUFDMUJmLGlCQUFpQnFCLE9BQU9yQixjQUFjLEVBQ3RDQyxpQkFBaUJvQixPQUFPcEIsY0FBYyxFQUN0Q0MscUJBQXFCbUIsT0FBT25CLGtCQUFrQixFQUM5Q0Usa0JBQWtCaUIsT0FBT2pCLGVBQWUsRUFDeENjLGlCQUFpQkcsT0FBT0gsY0FBYyxFQUN2QyxHQUFHLENBQUMsQ0FBQyxDQUNOO1FBQ0EsSUFBSSxDQUFDK0YsT0FBTyxHQUFHO1lBQ2JwRztZQUNBQztZQUNBQztZQUNBZjtZQUNBQztZQUNBQztZQUNBRTtZQUNBYztRQUNGO1FBRUEsSUFBSSxDQUFDdUQsT0FBTyxHQUFHckUsa0JBQWtCcUUsVUFBVUEsUUFBUXlDLFdBQVc7UUFFOUQsSUFBSSxDQUFDQyxNQUFNLEdBQUcsRUFBRTtRQUVoQixJQUFJLENBQUMsSUFBSSxDQUFDMUMsT0FBTyxDQUFDeEgsTUFBTSxFQUFFO1lBQ3hCO1FBQ0Y7UUFFQSxNQUFNbUssV0FBVyxDQUFDM0MsU0FBUzRDO1lBQ3pCLElBQUksQ0FBQ0YsTUFBTSxDQUFDMUksSUFBSSxDQUFDO2dCQUNmZ0c7Z0JBQ0E2QyxVQUFVUixzQkFBc0JyQztnQkFDaEM0QztZQUNGO1FBQ0Y7UUFFQSxNQUFNdkgsTUFBTSxJQUFJLENBQUMyRSxPQUFPLENBQUN4SCxNQUFNO1FBRS9CLElBQUk2QyxNQUFNdUYsVUFBVTtZQUNsQixJQUFJeEYsSUFBSTtZQUNSLE1BQU0wSCxZQUFZekgsTUFBTXVGO1lBQ3hCLE1BQU1ELE1BQU10RixNQUFNeUg7WUFFbEIsTUFBTzFILElBQUl1RixJQUFLO2dCQUNkZ0MsU0FBUyxJQUFJLENBQUMzQyxPQUFPLENBQUMrQyxNQUFNLENBQUMzSCxHQUFHd0YsV0FBV3hGO2dCQUMzQ0EsS0FBS3dGO1lBQ1A7WUFFQSxJQUFJa0MsV0FBVztnQkFDYixNQUFNRixhQUFhdkgsTUFBTXVGO2dCQUN6QitCLFNBQVMsSUFBSSxDQUFDM0MsT0FBTyxDQUFDK0MsTUFBTSxDQUFDSCxhQUFhQTtZQUM1QztRQUNGLE9BQU87WUFDTEQsU0FBUyxJQUFJLENBQUMzQyxPQUFPLEVBQUU7UUFDekI7SUFDRjtJQUVBZ0QsU0FBU2xDLElBQUksRUFBRTtRQUNiLE1BQU0sRUFBRW5GLGVBQWUsRUFBRUosY0FBYyxFQUFFLEdBQUcsSUFBSSxDQUFDaUgsT0FBTztRQUV4RCxJQUFJLENBQUM3RyxpQkFBaUI7WUFDcEJtRixPQUFPQSxLQUFLMkIsV0FBVztRQUN6QjtRQUVBLGNBQWM7UUFDZCxJQUFJLElBQUksQ0FBQ3pDLE9BQU8sS0FBS2MsTUFBTTtZQUN6QixJQUFJakosU0FBUztnQkFDWHVLLFNBQVM7Z0JBQ1RuRyxPQUFPO1lBQ1Q7WUFFQSxJQUFJVixnQkFBZ0I7Z0JBQ2xCMUQsT0FBTzRJLE9BQU8sR0FBRztvQkFBQzt3QkFBQzt3QkFBR0ssS0FBS3RJLE1BQU0sR0FBRztxQkFBRTtpQkFBQztZQUN6QztZQUVBLE9BQU9YO1FBQ1Q7UUFFQSxpQ0FBaUM7UUFDakMsTUFBTSxFQUNKdUUsUUFBUSxFQUNSRSxRQUFRLEVBQ1JELFNBQVMsRUFDVGIsY0FBYyxFQUNkQyxrQkFBa0IsRUFDbEJnQixjQUFjLEVBQ2YsR0FBRyxJQUFJLENBQUMrRixPQUFPO1FBRWhCLElBQUlTLGFBQWEsRUFBRTtRQUNuQixJQUFJQyxhQUFhO1FBQ2pCLElBQUlDLGFBQWE7UUFFakIsSUFBSSxDQUFDVCxNQUFNLENBQUM3SSxPQUFPLENBQUMsQ0FBQyxFQUFFbUcsT0FBTyxFQUFFNkMsUUFBUSxFQUFFRCxVQUFVLEVBQUU7WUFDcEQsTUFBTSxFQUFFUixPQUFPLEVBQUVuRyxLQUFLLEVBQUV3RSxPQUFPLEVBQUUsR0FBR0ksT0FBT0MsTUFBTWQsU0FBUzZDLFVBQVU7Z0JBQ2xFekcsVUFBVUEsV0FBV3dHO2dCQUNyQnRHO2dCQUNBRDtnQkFDQWI7Z0JBQ0FDO2dCQUNBRjtnQkFDQWtCO1lBQ0Y7WUFFQSxJQUFJMkYsU0FBUztnQkFDWGUsYUFBYTtZQUNmO1lBRUFELGNBQWNqSDtZQUVkLElBQUltRyxXQUFXM0IsU0FBUztnQkFDdEJ3QyxhQUFhO3VCQUFJQTt1QkFBZXhDO2lCQUFRO1lBQzFDO1FBQ0Y7UUFFQSxJQUFJNUksU0FBUztZQUNYdUssU0FBU2U7WUFDVGxILE9BQU9rSCxhQUFhRCxhQUFhLElBQUksQ0FBQ1IsTUFBTSxDQUFDbEssTUFBTSxHQUFHO1FBQ3hEO1FBRUEsSUFBSTJLLGNBQWM1SCxnQkFBZ0I7WUFDaEMxRCxPQUFPNEksT0FBTyxHQUFHd0M7UUFDbkI7UUFFQSxPQUFPcEw7SUFDVDtBQUNGO0FBRUEsTUFBTXVMO0lBQ0o1SixZQUFZd0csT0FBTyxDQUFFO1FBQ25CLElBQUksQ0FBQ0EsT0FBTyxHQUFHQTtJQUNqQjtJQUNBLE9BQU9xRCxhQUFhckQsT0FBTyxFQUFFO1FBQzNCLE9BQU9zRCxTQUFTdEQsU0FBUyxJQUFJLENBQUN1RCxVQUFVO0lBQzFDO0lBQ0EsT0FBT0MsY0FBY3hELE9BQU8sRUFBRTtRQUM1QixPQUFPc0QsU0FBU3RELFNBQVMsSUFBSSxDQUFDeUQsV0FBVztJQUMzQztJQUNBNUMsU0FBaUIsQ0FBQztBQUNwQjtBQUVBLFNBQVN5QyxTQUFTdEQsT0FBTyxFQUFFMEQsR0FBRztJQUM1QixNQUFNQyxVQUFVM0QsUUFBUTFDLEtBQUssQ0FBQ29HO0lBQzlCLE9BQU9DLFVBQVVBLE9BQU8sQ0FBQyxFQUFFLEdBQUc7QUFDaEM7QUFFQSxlQUFlO0FBRWYsTUFBTUMsbUJBQW1CUjtJQUN2QjVKLFlBQVl3RyxPQUFPLENBQUU7UUFDbkIsS0FBSyxDQUFDQTtJQUNSO0lBQ0EsV0FBVzZELE9BQU87UUFDaEIsT0FBTztJQUNUO0lBQ0EsV0FBV04sYUFBYTtRQUN0QixPQUFPO0lBQ1Q7SUFDQSxXQUFXRSxjQUFjO1FBQ3ZCLE9BQU87SUFDVDtJQUNBNUMsT0FBT0MsSUFBSSxFQUFFO1FBQ1gsTUFBTXNCLFVBQVV0QixTQUFTLElBQUksQ0FBQ2QsT0FBTztRQUVyQyxPQUFPO1lBQ0xvQztZQUNBbkcsT0FBT21HLFVBQVUsSUFBSTtZQUNyQjNCLFNBQVM7Z0JBQUM7Z0JBQUcsSUFBSSxDQUFDVCxPQUFPLENBQUN4SCxNQUFNLEdBQUc7YUFBRTtRQUN2QztJQUNGO0FBQ0Y7QUFFQSxlQUFlO0FBRWYsTUFBTXNMLDBCQUEwQlY7SUFDOUI1SixZQUFZd0csT0FBTyxDQUFFO1FBQ25CLEtBQUssQ0FBQ0E7SUFDUjtJQUNBLFdBQVc2RCxPQUFPO1FBQ2hCLE9BQU87SUFDVDtJQUNBLFdBQVdOLGFBQWE7UUFDdEIsT0FBTztJQUNUO0lBQ0EsV0FBV0UsY0FBYztRQUN2QixPQUFPO0lBQ1Q7SUFDQTVDLE9BQU9DLElBQUksRUFBRTtRQUNYLE1BQU0zRixRQUFRMkYsS0FBS1MsT0FBTyxDQUFDLElBQUksQ0FBQ3ZCLE9BQU87UUFDdkMsTUFBTW9DLFVBQVVqSCxVQUFVLENBQUM7UUFFM0IsT0FBTztZQUNMaUg7WUFDQW5HLE9BQU9tRyxVQUFVLElBQUk7WUFDckIzQixTQUFTO2dCQUFDO2dCQUFHSyxLQUFLdEksTUFBTSxHQUFHO2FBQUU7UUFDL0I7SUFDRjtBQUNGO0FBRUEsZUFBZTtBQUVmLE1BQU11TCx5QkFBeUJYO0lBQzdCNUosWUFBWXdHLE9BQU8sQ0FBRTtRQUNuQixLQUFLLENBQUNBO0lBQ1I7SUFDQSxXQUFXNkQsT0FBTztRQUNoQixPQUFPO0lBQ1Q7SUFDQSxXQUFXTixhQUFhO1FBQ3RCLE9BQU87SUFDVDtJQUNBLFdBQVdFLGNBQWM7UUFDdkIsT0FBTztJQUNUO0lBQ0E1QyxPQUFPQyxJQUFJLEVBQUU7UUFDWCxNQUFNc0IsVUFBVXRCLEtBQUtrRCxVQUFVLENBQUMsSUFBSSxDQUFDaEUsT0FBTztRQUU1QyxPQUFPO1lBQ0xvQztZQUNBbkcsT0FBT21HLFVBQVUsSUFBSTtZQUNyQjNCLFNBQVM7Z0JBQUM7Z0JBQUcsSUFBSSxDQUFDVCxPQUFPLENBQUN4SCxNQUFNLEdBQUc7YUFBRTtRQUN2QztJQUNGO0FBQ0Y7QUFFQSxnQkFBZ0I7QUFFaEIsTUFBTXlMLGdDQUFnQ2I7SUFDcEM1SixZQUFZd0csT0FBTyxDQUFFO1FBQ25CLEtBQUssQ0FBQ0E7SUFDUjtJQUNBLFdBQVc2RCxPQUFPO1FBQ2hCLE9BQU87SUFDVDtJQUNBLFdBQVdOLGFBQWE7UUFDdEIsT0FBTztJQUNUO0lBQ0EsV0FBV0UsY0FBYztRQUN2QixPQUFPO0lBQ1Q7SUFDQTVDLE9BQU9DLElBQUksRUFBRTtRQUNYLE1BQU1zQixVQUFVLENBQUN0QixLQUFLa0QsVUFBVSxDQUFDLElBQUksQ0FBQ2hFLE9BQU87UUFFN0MsT0FBTztZQUNMb0M7WUFDQW5HLE9BQU9tRyxVQUFVLElBQUk7WUFDckIzQixTQUFTO2dCQUFDO2dCQUFHSyxLQUFLdEksTUFBTSxHQUFHO2FBQUU7UUFDL0I7SUFDRjtBQUNGO0FBRUEsZ0JBQWdCO0FBRWhCLE1BQU0wTCx5QkFBeUJkO0lBQzdCNUosWUFBWXdHLE9BQU8sQ0FBRTtRQUNuQixLQUFLLENBQUNBO0lBQ1I7SUFDQSxXQUFXNkQsT0FBTztRQUNoQixPQUFPO0lBQ1Q7SUFDQSxXQUFXTixhQUFhO1FBQ3RCLE9BQU87SUFDVDtJQUNBLFdBQVdFLGNBQWM7UUFDdkIsT0FBTztJQUNUO0lBQ0E1QyxPQUFPQyxJQUFJLEVBQUU7UUFDWCxNQUFNc0IsVUFBVXRCLEtBQUtxRCxRQUFRLENBQUMsSUFBSSxDQUFDbkUsT0FBTztRQUUxQyxPQUFPO1lBQ0xvQztZQUNBbkcsT0FBT21HLFVBQVUsSUFBSTtZQUNyQjNCLFNBQVM7Z0JBQUNLLEtBQUt0SSxNQUFNLEdBQUcsSUFBSSxDQUFDd0gsT0FBTyxDQUFDeEgsTUFBTTtnQkFBRXNJLEtBQUt0SSxNQUFNLEdBQUc7YUFBRTtRQUMvRDtJQUNGO0FBQ0Y7QUFFQSxpQkFBaUI7QUFFakIsTUFBTTRMLGdDQUFnQ2hCO0lBQ3BDNUosWUFBWXdHLE9BQU8sQ0FBRTtRQUNuQixLQUFLLENBQUNBO0lBQ1I7SUFDQSxXQUFXNkQsT0FBTztRQUNoQixPQUFPO0lBQ1Q7SUFDQSxXQUFXTixhQUFhO1FBQ3RCLE9BQU87SUFDVDtJQUNBLFdBQVdFLGNBQWM7UUFDdkIsT0FBTztJQUNUO0lBQ0E1QyxPQUFPQyxJQUFJLEVBQUU7UUFDWCxNQUFNc0IsVUFBVSxDQUFDdEIsS0FBS3FELFFBQVEsQ0FBQyxJQUFJLENBQUNuRSxPQUFPO1FBQzNDLE9BQU87WUFDTG9DO1lBQ0FuRyxPQUFPbUcsVUFBVSxJQUFJO1lBQ3JCM0IsU0FBUztnQkFBQztnQkFBR0ssS0FBS3RJLE1BQU0sR0FBRzthQUFFO1FBQy9CO0lBQ0Y7QUFDRjtBQUVBLE1BQU02TCxtQkFBbUJqQjtJQUN2QjVKLFlBQ0V3RyxPQUFPLEVBQ1AsRUFDRTVELFdBQVdRLE9BQU9SLFFBQVEsRUFDMUJDLFlBQVlPLE9BQU9QLFNBQVMsRUFDNUJDLFdBQVdNLE9BQU9OLFFBQVEsRUFDMUJmLGlCQUFpQnFCLE9BQU9yQixjQUFjLEVBQ3RDQyxpQkFBaUJvQixPQUFPcEIsY0FBYyxFQUN0Q0MscUJBQXFCbUIsT0FBT25CLGtCQUFrQixFQUM5Q0Usa0JBQWtCaUIsT0FBT2pCLGVBQWUsRUFDeENjLGlCQUFpQkcsT0FBT0gsY0FBYyxFQUN2QyxHQUFHLENBQUMsQ0FBQyxDQUNOO1FBQ0EsS0FBSyxDQUFDdUQ7UUFDTixJQUFJLENBQUNzRSxZQUFZLEdBQUcsSUFBSS9CLFlBQVl2QyxTQUFTO1lBQzNDNUQ7WUFDQUM7WUFDQUM7WUFDQWY7WUFDQUM7WUFDQUM7WUFDQUU7WUFDQWM7UUFDRjtJQUNGO0lBQ0EsV0FBV29ILE9BQU87UUFDaEIsT0FBTztJQUNUO0lBQ0EsV0FBV04sYUFBYTtRQUN0QixPQUFPO0lBQ1Q7SUFDQSxXQUFXRSxjQUFjO1FBQ3ZCLE9BQU87SUFDVDtJQUNBNUMsT0FBT0MsSUFBSSxFQUFFO1FBQ1gsT0FBTyxJQUFJLENBQUN3RCxZQUFZLENBQUN0QixRQUFRLENBQUNsQztJQUNwQztBQUNGO0FBRUEsZUFBZTtBQUVmLE1BQU15RCxxQkFBcUJuQjtJQUN6QjVKLFlBQVl3RyxPQUFPLENBQUU7UUFDbkIsS0FBSyxDQUFDQTtJQUNSO0lBQ0EsV0FBVzZELE9BQU87UUFDaEIsT0FBTztJQUNUO0lBQ0EsV0FBV04sYUFBYTtRQUN0QixPQUFPO0lBQ1Q7SUFDQSxXQUFXRSxjQUFjO1FBQ3ZCLE9BQU87SUFDVDtJQUNBNUMsT0FBT0MsSUFBSSxFQUFFO1FBQ1gsSUFBSTFFLFdBQVc7UUFDZixJQUFJakI7UUFFSixNQUFNc0YsVUFBVSxFQUFFO1FBQ2xCLE1BQU1PLGFBQWEsSUFBSSxDQUFDaEIsT0FBTyxDQUFDeEgsTUFBTTtRQUV0Qyx3QkFBd0I7UUFDeEIsTUFBTyxDQUFDMkMsUUFBUTJGLEtBQUtTLE9BQU8sQ0FBQyxJQUFJLENBQUN2QixPQUFPLEVBQUU1RCxTQUFRLElBQUssQ0FBQyxFQUFHO1lBQzFEQSxXQUFXakIsUUFBUTZGO1lBQ25CUCxRQUFRekcsSUFBSSxDQUFDO2dCQUFDbUI7Z0JBQU9pQixXQUFXO2FBQUU7UUFDcEM7UUFFQSxNQUFNZ0csVUFBVSxDQUFDLENBQUMzQixRQUFRakksTUFBTTtRQUVoQyxPQUFPO1lBQ0w0SjtZQUNBbkcsT0FBT21HLFVBQVUsSUFBSTtZQUNyQjNCO1FBQ0Y7SUFDRjtBQUNGO0FBRUEsc0NBQXNDO0FBQ3RDLE1BQU0rRCxZQUFZO0lBQ2hCWjtJQUNBVztJQUNBUjtJQUNBRTtJQUNBRztJQUNBRjtJQUNBSjtJQUNBTztDQUNEO0FBRUQsTUFBTUksZUFBZUQsVUFBVWhNLE1BQU07QUFFckMsaUVBQWlFO0FBQ2pFLE1BQU1rTSxXQUFXO0FBQ2pCLE1BQU1DLFdBQVc7QUFFakIsc0VBQXNFO0FBQ3RFLFdBQVc7QUFDWCw2RUFBNkU7QUFDN0UsU0FBU0MsV0FBVzVFLE9BQU8sRUFBRXdDLFVBQVUsQ0FBQyxDQUFDO0lBQ3ZDLE9BQU94QyxRQUFRbEYsS0FBSyxDQUFDNkosVUFBVS9FLEdBQUcsQ0FBQyxDQUFDYjtRQUNsQyxJQUFJOEYsUUFBUTlGLEtBQ1R4RyxJQUFJLEdBQ0p1QyxLQUFLLENBQUM0SixVQUNOSSxNQUFNLENBQUMsQ0FBQy9GLE9BQVNBLFFBQVEsQ0FBQyxDQUFDQSxLQUFLeEcsSUFBSTtRQUV2QyxJQUFJd00sVUFBVSxFQUFFO1FBQ2hCLElBQUssSUFBSTNKLElBQUksR0FBR0MsTUFBTXdKLE1BQU1yTSxNQUFNLEVBQUU0QyxJQUFJQyxLQUFLRCxLQUFLLEVBQUc7WUFDbkQsTUFBTTRKLFlBQVlILEtBQUssQ0FBQ3pKLEVBQUU7WUFFMUIsbUZBQW1GO1lBQ25GLElBQUk2SixRQUFRO1lBQ1osSUFBSS9JLE1BQU0sQ0FBQztZQUNYLE1BQU8sQ0FBQytJLFNBQVMsRUFBRS9JLE1BQU11SSxhQUFjO2dCQUNyQyxNQUFNUyxXQUFXVixTQUFTLENBQUN0SSxJQUFJO2dCQUMvQixJQUFJaUosUUFBUUQsU0FBUzdCLFlBQVksQ0FBQzJCO2dCQUNsQyxJQUFJRyxPQUFPO29CQUNUSixRQUFRL0ssSUFBSSxDQUFDLElBQUlrTCxTQUFTQyxPQUFPM0M7b0JBQ2pDeUMsUUFBUTtnQkFDVjtZQUNGO1lBRUEsSUFBSUEsT0FBTztnQkFDVDtZQUNGO1lBRUEsbUVBQW1FO1lBQ25FL0ksTUFBTSxDQUFDO1lBQ1AsTUFBTyxFQUFFQSxNQUFNdUksYUFBYztnQkFDM0IsTUFBTVMsV0FBV1YsU0FBUyxDQUFDdEksSUFBSTtnQkFDL0IsSUFBSWlKLFFBQVFELFNBQVMxQixhQUFhLENBQUN3QjtnQkFDbkMsSUFBSUcsT0FBTztvQkFDVEosUUFBUS9LLElBQUksQ0FBQyxJQUFJa0wsU0FBU0MsT0FBTzNDO29CQUNqQztnQkFDRjtZQUNGO1FBQ0Y7UUFFQSxPQUFPdUM7SUFDVDtBQUNGO0FBRUEscUVBQXFFO0FBQ3JFLG1CQUFtQjtBQUNuQixNQUFNSyxnQkFBZ0IsSUFBSUMsSUFBSTtJQUFDaEIsV0FBV1IsSUFBSTtJQUFFVSxhQUFhVixJQUFJO0NBQUM7QUFFbEU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQTJCQyxHQUNELE1BQU15QjtJQUNKOUwsWUFDRXdHLE9BQU8sRUFDUCxFQUNFckUsa0JBQWtCaUIsT0FBT2pCLGVBQWUsRUFDeENKLGlCQUFpQnFCLE9BQU9yQixjQUFjLEVBQ3RDRSxxQkFBcUJtQixPQUFPbkIsa0JBQWtCLEVBQzlDZ0IsaUJBQWlCRyxPQUFPSCxjQUFjLEVBQ3RDakIsaUJBQWlCb0IsT0FBT3BCLGNBQWMsRUFDdENZLFdBQVdRLE9BQU9SLFFBQVEsRUFDMUJDLFlBQVlPLE9BQU9QLFNBQVMsRUFDNUJDLFdBQVdNLE9BQU9OLFFBQVEsRUFDM0IsR0FBRyxDQUFDLENBQUMsQ0FDTjtRQUNBLElBQUksQ0FBQ3VJLEtBQUssR0FBRztRQUNiLElBQUksQ0FBQ3JDLE9BQU8sR0FBRztZQUNiN0c7WUFDQUo7WUFDQUU7WUFDQUQ7WUFDQWlCO1lBQ0FMO1lBQ0FDO1lBQ0FDO1FBQ0Y7UUFFQSxJQUFJLENBQUMwRCxPQUFPLEdBQUdyRSxrQkFBa0JxRSxVQUFVQSxRQUFReUMsV0FBVztRQUM5RCxJQUFJLENBQUNvQyxLQUFLLEdBQUdELFdBQVcsSUFBSSxDQUFDNUUsT0FBTyxFQUFFLElBQUksQ0FBQ3dDLE9BQU87SUFDcEQ7SUFFQSxPQUFPK0MsVUFBVUMsQ0FBQyxFQUFFaEQsT0FBTyxFQUFFO1FBQzNCLE9BQU9BLFFBQVFoRyxpQkFBaUI7SUFDbEM7SUFFQXdHLFNBQVNsQyxJQUFJLEVBQUU7UUFDYixNQUFNK0QsUUFBUSxJQUFJLENBQUNBLEtBQUs7UUFFeEIsSUFBSSxDQUFDQSxPQUFPO1lBQ1YsT0FBTztnQkFDTHpDLFNBQVM7Z0JBQ1RuRyxPQUFPO1lBQ1Q7UUFDRjtRQUVBLE1BQU0sRUFBRVYsY0FBYyxFQUFFSSxlQUFlLEVBQUUsR0FBRyxJQUFJLENBQUM2RyxPQUFPO1FBRXhEMUIsT0FBT25GLGtCQUFrQm1GLE9BQU9BLEtBQUsyQixXQUFXO1FBRWhELElBQUlnRCxhQUFhO1FBQ2pCLElBQUl4QyxhQUFhLEVBQUU7UUFDbkIsSUFBSUMsYUFBYTtRQUVqQixNQUFNO1FBQ04sSUFBSyxJQUFJOUgsSUFBSSxHQUFHc0ssT0FBT2IsTUFBTXJNLE1BQU0sRUFBRTRDLElBQUlzSyxNQUFNdEssS0FBSyxFQUFHO1lBQ3JELE1BQU1vSixZQUFZSyxLQUFLLENBQUN6SixFQUFFO1lBRTFCLGdCQUFnQjtZQUNoQjZILFdBQVd6SyxNQUFNLEdBQUc7WUFDcEJpTixhQUFhO1lBRWIsT0FBTztZQUNQLElBQUssSUFBSXhELElBQUksR0FBRzBELE9BQU9uQixVQUFVaE0sTUFBTSxFQUFFeUosSUFBSTBELE1BQU0xRCxLQUFLLEVBQUc7Z0JBQ3pELE1BQU1pRCxXQUFXVixTQUFTLENBQUN2QyxFQUFFO2dCQUM3QixNQUFNLEVBQUVHLE9BQU8sRUFBRTNCLE9BQU8sRUFBRXhFLEtBQUssRUFBRSxHQUFHaUosU0FBU3JFLE1BQU0sQ0FBQ0M7Z0JBRXBELElBQUlzQixTQUFTO29CQUNYcUQsY0FBYztvQkFDZHZDLGNBQWNqSDtvQkFDZCxJQUFJVixnQkFBZ0I7d0JBQ2xCLE1BQU1zSSxPQUFPcUIsU0FBUzFMLFdBQVcsQ0FBQ3FLLElBQUk7d0JBQ3RDLElBQUl1QixjQUFjN0gsR0FBRyxDQUFDc0csT0FBTzs0QkFDM0JaLGFBQWE7bUNBQUlBO21DQUFleEM7NkJBQVE7d0JBQzFDLE9BQU87NEJBQ0x3QyxXQUFXakosSUFBSSxDQUFDeUc7d0JBQ2xCO29CQUNGO2dCQUNGLE9BQU87b0JBQ0x5QyxhQUFhO29CQUNidUMsYUFBYTtvQkFDYnhDLFdBQVd6SyxNQUFNLEdBQUc7b0JBQ3BCO2dCQUNGO1lBQ0Y7WUFFQSxtQ0FBbUM7WUFDbkMsSUFBSWlOLFlBQVk7Z0JBQ2QsSUFBSTVOLFNBQVM7b0JBQ1h1SyxTQUFTO29CQUNUbkcsT0FBT2lILGFBQWF1QztnQkFDdEI7Z0JBRUEsSUFBSWxLLGdCQUFnQjtvQkFDbEIxRCxPQUFPNEksT0FBTyxHQUFHd0M7Z0JBQ25CO2dCQUVBLE9BQU9wTDtZQUNUO1FBQ0Y7UUFFQSxzQkFBc0I7UUFDdEIsT0FBTztZQUNMdUssU0FBUztZQUNUbkcsT0FBTztRQUNUO0lBQ0Y7QUFDRjtBQUVBLE1BQU0ySixzQkFBc0IsRUFBRTtBQUU5QixTQUFTQyxTQUFTLEdBQUdDLElBQUk7SUFDdkJGLG9CQUFvQjVMLElBQUksSUFBSThMO0FBQzlCO0FBRUEsU0FBU0MsZUFBZS9GLE9BQU8sRUFBRXdDLE9BQU87SUFDdEMsSUFBSyxJQUFJcEgsSUFBSSxHQUFHQyxNQUFNdUssb0JBQW9CcE4sTUFBTSxFQUFFNEMsSUFBSUMsS0FBS0QsS0FBSyxFQUFHO1FBQ2pFLElBQUk0SyxnQkFBZ0JKLG1CQUFtQixDQUFDeEssRUFBRTtRQUMxQyxJQUFJNEssY0FBY1QsU0FBUyxDQUFDdkYsU0FBU3dDLFVBQVU7WUFDN0MsT0FBTyxJQUFJd0QsY0FBY2hHLFNBQVN3QztRQUNwQztJQUNGO0lBRUEsT0FBTyxJQUFJRCxZQUFZdkMsU0FBU3dDO0FBQ2xDO0FBRUEsTUFBTXlELGtCQUFrQjtJQUN0QkMsS0FBSztJQUNMQyxJQUFJO0FBQ047QUFFQSxNQUFNQyxVQUFVO0lBQ2RDLE1BQU07SUFDTkMsU0FBUztBQUNYO0FBRUEsTUFBTUMsZUFBZSxDQUFDMUIsUUFDcEIsQ0FBQyxDQUFFQSxDQUFBQSxLQUFLLENBQUNvQixnQkFBZ0JDLEdBQUcsQ0FBQyxJQUFJckIsS0FBSyxDQUFDb0IsZ0JBQWdCRSxFQUFFLENBQUM7QUFFNUQsTUFBTUssU0FBUyxDQUFDM0IsUUFBVSxDQUFDLENBQUNBLEtBQUssQ0FBQ3VCLFFBQVFDLElBQUksQ0FBQztBQUUvQyxNQUFNSSxTQUFTLENBQUM1QixRQUNkLENBQUN0TixRQUFRc04sVUFBVTFNLFNBQVMwTSxVQUFVLENBQUMwQixhQUFhMUI7QUFFdEQsTUFBTTZCLG9CQUFvQixDQUFDN0IsUUFBVztRQUNwQyxDQUFDb0IsZ0JBQWdCQyxHQUFHLENBQUMsRUFBRXpOLE9BQU9nQixJQUFJLENBQUNvTCxPQUFPakYsR0FBRyxDQUFDLENBQUM3RyxNQUFTO2dCQUN0RCxDQUFDQSxJQUFJLEVBQUU4TCxLQUFLLENBQUM5TCxJQUFJO1lBQ25CO0lBQ0Y7QUFFQSw4RUFBOEU7QUFDOUUsc0NBQXNDO0FBQ3RDLFNBQVM0TixNQUFNOUIsS0FBSyxFQUFFckMsT0FBTyxFQUFFLEVBQUVvRSxPQUFPLElBQUksRUFBRSxHQUFHLENBQUMsQ0FBQztJQUNqRCxNQUFNQyxPQUFPLENBQUNoQztRQUNaLElBQUlwTCxPQUFPaEIsT0FBT2dCLElBQUksQ0FBQ29MO1FBRXZCLE1BQU1pQyxjQUFjTixPQUFPM0I7UUFFM0IsSUFBSSxDQUFDaUMsZUFBZXJOLEtBQUtqQixNQUFNLEdBQUcsS0FBSyxDQUFDK04sYUFBYTFCLFFBQVE7WUFDM0QsT0FBT2dDLEtBQUtILGtCQUFrQjdCO1FBQ2hDO1FBRUEsSUFBSTRCLE9BQU81QixRQUFRO1lBQ2pCLE1BQU05TCxNQUFNK04sY0FBY2pDLEtBQUssQ0FBQ3VCLFFBQVFDLElBQUksQ0FBQyxHQUFHNU0sSUFBSSxDQUFDLEVBQUU7WUFFdkQsTUFBTXVHLFVBQVU4RyxjQUFjakMsS0FBSyxDQUFDdUIsUUFBUUUsT0FBTyxDQUFDLEdBQUd6QixLQUFLLENBQUM5TCxJQUFJO1lBRWpFLElBQUksQ0FBQ2hCLFNBQVNpSSxVQUFVO2dCQUN0QixNQUFNLElBQUluRixNQUFNL0IscUNBQXFDQztZQUN2RDtZQUVBLE1BQU1lLE1BQU07Z0JBQ1ZNLE9BQU9RLFlBQVk3QjtnQkFDbkJpSDtZQUNGO1lBRUEsSUFBSTRHLE1BQU07Z0JBQ1I5TSxJQUFJb0wsUUFBUSxHQUFHYSxlQUFlL0YsU0FBU3dDO1lBQ3pDO1lBRUEsT0FBTzFJO1FBQ1Q7UUFFQSxJQUFJaU4sT0FBTztZQUNUQyxVQUFVLEVBQUU7WUFDWkMsVUFBVXhOLElBQUksQ0FBQyxFQUFFO1FBQ25CO1FBRUFBLEtBQUtJLE9BQU8sQ0FBQyxDQUFDZDtZQUNaLE1BQU12QixRQUFRcU4sS0FBSyxDQUFDOUwsSUFBSTtZQUV4QixJQUFJeEIsUUFBUUMsUUFBUTtnQkFDbEJBLE1BQU1xQyxPQUFPLENBQUMsQ0FBQ2tGO29CQUNiZ0ksS0FBS0MsUUFBUSxDQUFDaE4sSUFBSSxDQUFDNk0sS0FBSzlIO2dCQUMxQjtZQUNGO1FBQ0Y7UUFFQSxPQUFPZ0k7SUFDVDtJQUVBLElBQUksQ0FBQ1IsYUFBYTFCLFFBQVE7UUFDeEJBLFFBQVE2QixrQkFBa0I3QjtJQUM1QjtJQUVBLE9BQU9nQyxLQUFLaEM7QUFDZDtBQUVBLDZCQUE2QjtBQUM3QixTQUFTcUMsYUFDUG5DLE9BQU8sRUFDUCxFQUFFckksa0JBQWtCRSxPQUFPRixlQUFlLEVBQUU7SUFFNUNxSSxRQUFRbEwsT0FBTyxDQUFDLENBQUNoQztRQUNmLElBQUlxTCxhQUFhO1FBRWpCckwsT0FBTzhMLE9BQU8sQ0FBQzlKLE9BQU8sQ0FBQyxDQUFDLEVBQUVkLEdBQUcsRUFBRStELElBQUksRUFBRWIsS0FBSyxFQUFFO1lBQzFDLE1BQU0vQixTQUFTbkIsTUFBTUEsSUFBSW1CLE1BQU0sR0FBRztZQUVsQ2dKLGNBQWMvRixLQUFLQyxHQUFHLENBQ3BCbkIsVUFBVSxLQUFLL0IsU0FBU2lOLE9BQU9DLE9BQU8sR0FBR25MLE9BQ3pDLENBQUMvQixVQUFVLEtBQU13QyxDQUFBQSxrQkFBa0IsSUFBSUksSUFBRztRQUU5QztRQUVBakYsT0FBT29FLEtBQUssR0FBR2lIO0lBQ2pCO0FBQ0Y7QUFFQSxTQUFTbUUsaUJBQWlCeFAsTUFBTSxFQUFFaUksSUFBSTtJQUNwQyxNQUFNNkQsVUFBVTlMLE9BQU84TCxPQUFPO0lBQzlCN0QsS0FBSzZELE9BQU8sR0FBRyxFQUFFO0lBRWpCLElBQUksQ0FBQ3ZMLFVBQVV1TCxVQUFVO1FBQ3ZCO0lBQ0Y7SUFFQUEsUUFBUTlKLE9BQU8sQ0FBQyxDQUFDeUQ7UUFDZixJQUFJLENBQUNsRixVQUFVa0YsTUFBTW1ELE9BQU8sS0FBSyxDQUFDbkQsTUFBTW1ELE9BQU8sQ0FBQ2pJLE1BQU0sRUFBRTtZQUN0RDtRQUNGO1FBRUEsTUFBTSxFQUFFaUksT0FBTyxFQUFFakosS0FBSyxFQUFFLEdBQUc4RjtRQUUzQixJQUFJeEQsTUFBTTtZQUNSMkc7WUFDQWpKO1FBQ0Y7UUFFQSxJQUFJOEYsTUFBTXZFLEdBQUcsRUFBRTtZQUNiZSxJQUFJZixHQUFHLEdBQUd1RSxNQUFNdkUsR0FBRyxDQUFDMEIsR0FBRztRQUN6QjtRQUVBLElBQUk2QyxNQUFNcEIsR0FBRyxHQUFHLENBQUMsR0FBRztZQUNsQnBDLElBQUl3TixRQUFRLEdBQUdoSyxNQUFNcEIsR0FBRztRQUMxQjtRQUVBNEQsS0FBSzZELE9BQU8sQ0FBQzNKLElBQUksQ0FBQ0Y7SUFDcEI7QUFDRjtBQUVBLFNBQVN5TixlQUFlMVAsTUFBTSxFQUFFaUksSUFBSTtJQUNsQ0EsS0FBSzdELEtBQUssR0FBR3BFLE9BQU9vRSxLQUFLO0FBQzNCO0FBRUEsU0FBU3VMLE9BQ1B6QyxPQUFPLEVBQ1A5RyxJQUFJLEVBQ0osRUFDRTFDLGlCQUFpQnFCLE9BQU9yQixjQUFjLEVBQ3RDSyxlQUFlZ0IsT0FBT2hCLFlBQVksRUFDbkMsR0FBRyxDQUFDLENBQUM7SUFFTixNQUFNNkwsZUFBZSxFQUFFO0lBRXZCLElBQUlsTSxnQkFBZ0JrTSxhQUFhek4sSUFBSSxDQUFDcU47SUFDdEMsSUFBSXpMLGNBQWM2TCxhQUFhek4sSUFBSSxDQUFDdU47SUFFcEMsT0FBT3hDLFFBQVFuRixHQUFHLENBQUMsQ0FBQy9IO1FBQ2xCLE1BQU0sRUFBRXFFLEdBQUcsRUFBRSxHQUFHckU7UUFFaEIsTUFBTWlJLE9BQU87WUFDWGYsTUFBTWQsSUFBSSxDQUFDL0IsSUFBSTtZQUNmb0wsVUFBVXBMO1FBQ1o7UUFFQSxJQUFJdUwsYUFBYWpQLE1BQU0sRUFBRTtZQUN2QmlQLGFBQWE1TixPQUFPLENBQUMsQ0FBQzZOO2dCQUNwQkEsWUFBWTdQLFFBQVFpSTtZQUN0QjtRQUNGO1FBRUEsT0FBT0E7SUFDVDtBQUNGO0FBRUEsTUFBTTZIO0lBQ0puTyxZQUFZeUUsSUFBSSxFQUFFdUUsVUFBVSxDQUFDLENBQUMsRUFBRXJILEtBQUssQ0FBRTtRQUNyQyxJQUFJLENBQUNxSCxPQUFPLEdBQUc7WUFBRSxHQUFHNUYsTUFBTTtZQUFFLEdBQUc0RixPQUFPO1FBQUM7UUFFdkMsSUFDRSxJQUFJLENBQUNBLE9BQU8sQ0FBQ2hHLGlCQUFpQixJQUM5QixDQUFDLE1BQ0QsRUFFRDtRQUVELElBQUksQ0FBQ29MLFNBQVMsR0FBRyxJQUFJck8sU0FBUyxJQUFJLENBQUNpSixPQUFPLENBQUMvSSxJQUFJO1FBRS9DLElBQUksQ0FBQ29PLGFBQWEsQ0FBQzVKLE1BQU05QztJQUMzQjtJQUVBME0sY0FBYzVKLElBQUksRUFBRTlDLEtBQUssRUFBRTtRQUN6QixJQUFJLENBQUMyTSxLQUFLLEdBQUc3SjtRQUViLElBQUk5QyxTQUFTLENBQUVBLENBQUFBLGlCQUFpQjBDLFNBQVEsR0FBSTtZQUMxQyxNQUFNLElBQUloRCxNQUFNaEM7UUFDbEI7UUFFQSxJQUFJLENBQUNrUCxRQUFRLEdBQ1g1TSxTQUNBdUUsWUFBWSxJQUFJLENBQUM4QyxPQUFPLENBQUMvSSxJQUFJLEVBQUUsSUFBSSxDQUFDcU8sS0FBSyxFQUFFO1lBQ3pDcE4sT0FBTyxJQUFJLENBQUM4SCxPQUFPLENBQUM5SCxLQUFLO1lBQ3pCaUMsaUJBQWlCLElBQUksQ0FBQzZGLE9BQU8sQ0FBQzdGLGVBQWU7UUFDL0M7SUFDSjtJQUVBK0IsSUFBSUosR0FBRyxFQUFFO1FBQ1AsSUFBSSxDQUFDbEcsVUFBVWtHLE1BQU07WUFDbkI7UUFDRjtRQUVBLElBQUksQ0FBQ3dKLEtBQUssQ0FBQzlOLElBQUksQ0FBQ3NFO1FBQ2hCLElBQUksQ0FBQ3lKLFFBQVEsQ0FBQ3JKLEdBQUcsQ0FBQ0o7SUFDcEI7SUFFQTBKLE9BQU9DLFlBQVksSUFBb0IsS0FBSyxFQUFFO1FBQzVDLE1BQU1sRCxVQUFVLEVBQUU7UUFFbEIsSUFBSyxJQUFJM0osSUFBSSxHQUFHQyxNQUFNLElBQUksQ0FBQ3lNLEtBQUssQ0FBQ3RQLE1BQU0sRUFBRTRDLElBQUlDLEtBQUtELEtBQUssRUFBRztZQUN4RCxNQUFNa0QsTUFBTSxJQUFJLENBQUN3SixLQUFLLENBQUMxTSxFQUFFO1lBQ3pCLElBQUk2TSxVQUFVM0osS0FBS2xELElBQUk7Z0JBQ3JCLElBQUksQ0FBQ3dELFFBQVEsQ0FBQ3hEO2dCQUNkQSxLQUFLO2dCQUNMQyxPQUFPO2dCQUVQMEosUUFBUS9LLElBQUksQ0FBQ3NFO1lBQ2Y7UUFDRjtRQUVBLE9BQU95RztJQUNUO0lBRUFuRyxTQUFTMUMsR0FBRyxFQUFFO1FBQ1osSUFBSSxDQUFDNEwsS0FBSyxDQUFDakosTUFBTSxDQUFDM0MsS0FBSztRQUN2QixJQUFJLENBQUM2TCxRQUFRLENBQUNuSixRQUFRLENBQUMxQztJQUN6QjtJQUVBZ00sV0FBVztRQUNULE9BQU8sSUFBSSxDQUFDSCxRQUFRO0lBQ3RCO0lBRUFsSCxPQUFPZ0UsS0FBSyxFQUFFLEVBQUVzRCxRQUFRLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLEVBQUU7UUFDakMsTUFBTSxFQUNKNU0sY0FBYyxFQUNkSyxZQUFZLEVBQ1pDLFVBQVUsRUFDVkMsTUFBTSxFQUNOWSxlQUFlLEVBQ2hCLEdBQUcsSUFBSSxDQUFDOEYsT0FBTztRQUVoQixJQUFJdUMsVUFBVWhOLFNBQVM4TSxTQUNuQjlNLFNBQVMsSUFBSSxDQUFDK1AsS0FBSyxDQUFDLEVBQUUsSUFDcEIsSUFBSSxDQUFDTSxpQkFBaUIsQ0FBQ3ZELFNBQ3ZCLElBQUksQ0FBQ3dELGlCQUFpQixDQUFDeEQsU0FDekIsSUFBSSxDQUFDeUQsY0FBYyxDQUFDekQ7UUFFeEJxQyxhQUFhbkMsU0FBUztZQUFFckk7UUFBZ0I7UUFFeEMsSUFBSWIsWUFBWTtZQUNka0osUUFBUXdELElBQUksQ0FBQ3pNO1FBQ2Y7UUFFQSxJQUFJOUQsU0FBU21RLFVBQVVBLFFBQVEsQ0FBQyxHQUFHO1lBQ2pDcEQsVUFBVUEsUUFBUXlELEtBQUssQ0FBQyxHQUFHTDtRQUM3QjtRQUVBLE9BQU9YLE9BQU96QyxTQUFTLElBQUksQ0FBQytDLEtBQUssRUFBRTtZQUNqQ3ZNO1lBQ0FLO1FBQ0Y7SUFDRjtJQUVBd00sa0JBQWtCdkQsS0FBSyxFQUFFO1FBQ3ZCLE1BQU1LLFdBQVdhLGVBQWVsQixPQUFPLElBQUksQ0FBQ3JDLE9BQU87UUFDbkQsTUFBTSxFQUFFdEUsT0FBTyxFQUFFLEdBQUcsSUFBSSxDQUFDNkosUUFBUTtRQUNqQyxNQUFNaEQsVUFBVSxFQUFFO1FBRWxCLHlDQUF5QztRQUN6QzdHLFFBQVFyRSxPQUFPLENBQUMsQ0FBQyxFQUFFb0YsR0FBRzZCLElBQUksRUFBRTFGLEdBQUdjLEdBQUcsRUFBRXNCLEdBQUdWLElBQUksRUFBRTtZQUMzQyxJQUFJLENBQUMxRSxVQUFVMEksT0FBTztnQkFDcEI7WUFDRjtZQUVBLE1BQU0sRUFBRXNCLE9BQU8sRUFBRW5HLEtBQUssRUFBRXdFLE9BQU8sRUFBRSxHQUFHeUUsU0FBU2xDLFFBQVEsQ0FBQ2xDO1lBRXRELElBQUlzQixTQUFTO2dCQUNYMkMsUUFBUS9LLElBQUksQ0FBQztvQkFDWCtFLE1BQU0rQjtvQkFDTjVFO29CQUNBeUgsU0FBUzt3QkFBQzs0QkFBRTFIOzRCQUFPekUsT0FBT3NKOzRCQUFNaEU7NEJBQU0yRDt3QkFBUTtxQkFBRTtnQkFDbEQ7WUFDRjtRQUNGO1FBRUEsT0FBT3NFO0lBQ1Q7SUFFQXVELGVBQWV6RCxLQUFLLEVBQUU7UUFFcEIsTUFBTTRELGFBQWE5QixNQUFNOUIsT0FBTyxJQUFJLENBQUNyQyxPQUFPO1FBRTVDLE1BQU1rRyxXQUFXLENBQUMzQixNQUFNaEksTUFBTTdDO1lBQzVCLElBQUksQ0FBQzZLLEtBQUtDLFFBQVEsRUFBRTtnQkFDbEIsTUFBTSxFQUFFNU0sS0FBSyxFQUFFOEssUUFBUSxFQUFFLEdBQUc2QjtnQkFFNUIsTUFBTXBELFVBQVUsSUFBSSxDQUFDZ0YsWUFBWSxDQUFDO29CQUNoQzVQLEtBQUssSUFBSSxDQUFDNk8sU0FBUyxDQUFDek4sR0FBRyxDQUFDQztvQkFDeEI1QyxPQUFPLElBQUksQ0FBQ3VRLFFBQVEsQ0FBQ2pKLHNCQUFzQixDQUFDQyxNQUFNM0U7b0JBQ2xEOEs7Z0JBQ0Y7Z0JBRUEsSUFBSXZCLFdBQVdBLFFBQVFuTCxNQUFNLEVBQUU7b0JBQzdCLE9BQU87d0JBQ0w7NEJBQ0UwRDs0QkFDQTZDOzRCQUNBNEU7d0JBQ0Y7cUJBQ0Q7Z0JBQ0g7Z0JBRUEsT0FBTyxFQUFFO1lBQ1g7WUFFQSxNQUFNaUYsTUFBTSxFQUFFO1lBQ2QsSUFBSyxJQUFJeE4sSUFBSSxHQUFHQyxNQUFNMEwsS0FBS0MsUUFBUSxDQUFDeE8sTUFBTSxFQUFFNEMsSUFBSUMsS0FBS0QsS0FBSyxFQUFHO2dCQUMzRCxNQUFNeU4sUUFBUTlCLEtBQUtDLFFBQVEsQ0FBQzVMLEVBQUU7Z0JBQzlCLE1BQU12RCxTQUFTNlEsU0FBU0csT0FBTzlKLE1BQU03QztnQkFDckMsSUFBSXJFLE9BQU9XLE1BQU0sRUFBRTtvQkFDakJvUSxJQUFJNU8sSUFBSSxJQUFJbkM7Z0JBQ2QsT0FBTyxJQUFJa1AsS0FBS0UsUUFBUSxLQUFLaEIsZ0JBQWdCQyxHQUFHLEVBQUU7b0JBQ2hELE9BQU8sRUFBRTtnQkFDWDtZQUNGO1lBQ0EsT0FBTzBDO1FBQ1Q7UUFFQSxNQUFNMUssVUFBVSxJQUFJLENBQUM2SixRQUFRLENBQUM3SixPQUFPO1FBQ3JDLE1BQU00SyxZQUFZLENBQUM7UUFDbkIsTUFBTS9ELFVBQVUsRUFBRTtRQUVsQjdHLFFBQVFyRSxPQUFPLENBQUMsQ0FBQyxFQUFFcUYsR0FBR0gsSUFBSSxFQUFFM0QsR0FBR2MsR0FBRyxFQUFFO1lBQ2xDLElBQUk5RCxVQUFVMkcsT0FBTztnQkFDbkIsSUFBSWdLLGFBQWFMLFNBQVNELFlBQVkxSixNQUFNN0M7Z0JBRTVDLElBQUk2TSxXQUFXdlEsTUFBTSxFQUFFO29CQUNyQixxQkFBcUI7b0JBQ3JCLElBQUksQ0FBQ3NRLFNBQVMsQ0FBQzVNLElBQUksRUFBRTt3QkFDbkI0TSxTQUFTLENBQUM1TSxJQUFJLEdBQUc7NEJBQUVBOzRCQUFLNkM7NEJBQU00RSxTQUFTLEVBQUU7d0JBQUM7d0JBQzFDb0IsUUFBUS9LLElBQUksQ0FBQzhPLFNBQVMsQ0FBQzVNLElBQUk7b0JBQzdCO29CQUNBNk0sV0FBV2xQLE9BQU8sQ0FBQyxDQUFDLEVBQUU4SixPQUFPLEVBQUU7d0JBQzdCbUYsU0FBUyxDQUFDNU0sSUFBSSxDQUFDeUgsT0FBTyxDQUFDM0osSUFBSSxJQUFJMko7b0JBQ2pDO2dCQUNGO1lBQ0Y7UUFDRjtRQUVBLE9BQU9vQjtJQUNUO0lBRUFzRCxrQkFBa0J4RCxLQUFLLEVBQUU7UUFDdkIsTUFBTUssV0FBV2EsZUFBZWxCLE9BQU8sSUFBSSxDQUFDckMsT0FBTztRQUNuRCxNQUFNLEVBQUUvSSxJQUFJLEVBQUV5RSxPQUFPLEVBQUUsR0FBRyxJQUFJLENBQUM2SixRQUFRO1FBQ3ZDLE1BQU1oRCxVQUFVLEVBQUU7UUFFbEIsd0JBQXdCO1FBQ3hCN0csUUFBUXJFLE9BQU8sQ0FBQyxDQUFDLEVBQUVxRixHQUFHSCxJQUFJLEVBQUUzRCxHQUFHYyxHQUFHLEVBQUU7WUFDbEMsSUFBSSxDQUFDOUQsVUFBVTJHLE9BQU87Z0JBQ3BCO1lBQ0Y7WUFFQSxJQUFJNEUsVUFBVSxFQUFFO1lBRWhCLHNFQUFzRTtZQUN0RWxLLEtBQUtJLE9BQU8sQ0FBQyxDQUFDZCxLQUFLb0c7Z0JBQ2pCd0UsUUFBUTNKLElBQUksSUFDUCxJQUFJLENBQUMyTyxZQUFZLENBQUM7b0JBQ25CNVA7b0JBQ0F2QixPQUFPdUgsSUFBSSxDQUFDSSxTQUFTO29CQUNyQitGO2dCQUNGO1lBRUo7WUFFQSxJQUFJdkIsUUFBUW5MLE1BQU0sRUFBRTtnQkFDbEJ1TSxRQUFRL0ssSUFBSSxDQUFDO29CQUNYa0M7b0JBQ0E2QztvQkFDQTRFO2dCQUNGO1lBQ0Y7UUFDRjtRQUVBLE9BQU9vQjtJQUNUO0lBQ0E0RCxhQUFhLEVBQUU1UCxHQUFHLEVBQUV2QixLQUFLLEVBQUUwTixRQUFRLEVBQUUsRUFBRTtRQUNyQyxJQUFJLENBQUM5TSxVQUFVWixRQUFRO1lBQ3JCLE9BQU8sRUFBRTtRQUNYO1FBRUEsSUFBSW1NLFVBQVUsRUFBRTtRQUVoQixJQUFJcE0sUUFBUUMsUUFBUTtZQUNsQkEsTUFBTXFDLE9BQU8sQ0FBQyxDQUFDLEVBQUVvRixHQUFHNkIsSUFBSSxFQUFFMUYsR0FBR2MsR0FBRyxFQUFFc0IsR0FBR1YsSUFBSSxFQUFFO2dCQUN6QyxJQUFJLENBQUMxRSxVQUFVMEksT0FBTztvQkFDcEI7Z0JBQ0Y7Z0JBRUEsTUFBTSxFQUFFc0IsT0FBTyxFQUFFbkcsS0FBSyxFQUFFd0UsT0FBTyxFQUFFLEdBQUd5RSxTQUFTbEMsUUFBUSxDQUFDbEM7Z0JBRXRELElBQUlzQixTQUFTO29CQUNYdUIsUUFBUTNKLElBQUksQ0FBQzt3QkFDWGlDO3dCQUNBbEQ7d0JBQ0F2QixPQUFPc0o7d0JBQ1A1RTt3QkFDQVk7d0JBQ0EyRDtvQkFDRjtnQkFDRjtZQUNGO1FBQ0YsT0FBTztZQUNMLE1BQU0sRUFBRXhCLEdBQUc2QixJQUFJLEVBQUV0RCxHQUFHVixJQUFJLEVBQUUsR0FBR3RGO1lBRTdCLE1BQU0sRUFBRTRLLE9BQU8sRUFBRW5HLEtBQUssRUFBRXdFLE9BQU8sRUFBRSxHQUFHeUUsU0FBU2xDLFFBQVEsQ0FBQ2xDO1lBRXRELElBQUlzQixTQUFTO2dCQUNYdUIsUUFBUTNKLElBQUksQ0FBQztvQkFBRWlDO29CQUFPbEQ7b0JBQUt2QixPQUFPc0o7b0JBQU1oRTtvQkFBTTJEO2dCQUFRO1lBQ3hEO1FBQ0Y7UUFFQSxPQUFPa0Q7SUFDVDtBQUNGO0FBRUFnRSxLQUFLcUIsT0FBTyxHQUFHO0FBQ2ZyQixLQUFLakksV0FBVyxHQUFHQTtBQUNuQmlJLEtBQUs5SCxVQUFVLEdBQUdBO0FBQ2xCOEgsS0FBS3NCLE1BQU0sR0FBR3JNO0FBRWQ7SUFDRStLLEtBQUsvQyxVQUFVLEdBQUcrQjtBQUNwQixDQUVBO0lBQ0VkLFNBQVNQO0FBQ1gsQ0FFMkIiLCJzb3VyY2VzIjpbIi9Vc2Vycy96a3NvanUvRG9jdW1lbnRzL0dpdEh1Yi9sb2EtY29uc3RydWN0cy9ub2RlX21vZHVsZXMvLnBucG0vZnVzZS5qc0A3LjAuMC9ub2RlX21vZHVsZXMvZnVzZS5qcy9kaXN0L2Z1c2UubWpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRnVzZS5qcyB2Ny4wLjAgLSBMaWdodHdlaWdodCBmdXp6eS1zZWFyY2ggKGh0dHA6Ly9mdXNlanMuaW8pXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDIzIEtpcm8gUmlzayAoaHR0cDovL2tpcm8ubWUpXG4gKiBBbGwgUmlnaHRzIFJlc2VydmVkLiBBcGFjaGUgU29mdHdhcmUgTGljZW5zZSAyLjBcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqL1xuXG5mdW5jdGlvbiBpc0FycmF5KHZhbHVlKSB7XG4gIHJldHVybiAhQXJyYXkuaXNBcnJheVxuICAgID8gZ2V0VGFnKHZhbHVlKSA9PT0gJ1tvYmplY3QgQXJyYXldJ1xuICAgIDogQXJyYXkuaXNBcnJheSh2YWx1ZSlcbn1cblxuLy8gQWRhcHRlZCBmcm9tOiBodHRwczovL2dpdGh1Yi5jb20vbG9kYXNoL2xvZGFzaC9ibG9iL21hc3Rlci8uaW50ZXJuYWwvYmFzZVRvU3RyaW5nLmpzXG5jb25zdCBJTkZJTklUWSA9IDEgLyAwO1xuZnVuY3Rpb24gYmFzZVRvU3RyaW5nKHZhbHVlKSB7XG4gIC8vIEV4aXQgZWFybHkgZm9yIHN0cmluZ3MgdG8gYXZvaWQgYSBwZXJmb3JtYW5jZSBoaXQgaW4gc29tZSBlbnZpcm9ubWVudHMuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuICBsZXQgcmVzdWx0ID0gdmFsdWUgKyAnJztcbiAgcmV0dXJuIHJlc3VsdCA9PSAnMCcgJiYgMSAvIHZhbHVlID09IC1JTkZJTklUWSA/ICctMCcgOiByZXN1bHRcbn1cblxuZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IGJhc2VUb1N0cmluZyh2YWx1ZSlcbn1cblxuZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZydcbn1cblxuZnVuY3Rpb24gaXNOdW1iZXIodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcidcbn1cblxuLy8gQWRhcHRlZCBmcm9tOiBodHRwczovL2dpdGh1Yi5jb20vbG9kYXNoL2xvZGFzaC9ibG9iL21hc3Rlci9pc0Jvb2xlYW4uanNcbmZ1bmN0aW9uIGlzQm9vbGVhbih2YWx1ZSkge1xuICByZXR1cm4gKFxuICAgIHZhbHVlID09PSB0cnVlIHx8XG4gICAgdmFsdWUgPT09IGZhbHNlIHx8XG4gICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgZ2V0VGFnKHZhbHVlKSA9PSAnW29iamVjdCBCb29sZWFuXScpXG4gIClcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCdcbn1cblxuLy8gQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSAmJiB2YWx1ZSAhPT0gbnVsbFxufVxuXG5mdW5jdGlvbiBpc0RlZmluZWQodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGxcbn1cblxuZnVuY3Rpb24gaXNCbGFuayh2YWx1ZSkge1xuICByZXR1cm4gIXZhbHVlLnRyaW0oKS5sZW5ndGhcbn1cblxuLy8gR2V0cyB0aGUgYHRvU3RyaW5nVGFnYCBvZiBgdmFsdWVgLlxuLy8gQWRhcHRlZCBmcm9tOiBodHRwczovL2dpdGh1Yi5jb20vbG9kYXNoL2xvZGFzaC9ibG9iL21hc3Rlci8uaW50ZXJuYWwvZ2V0VGFnLmpzXG5mdW5jdGlvbiBnZXRUYWcodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGxcbiAgICA/IHZhbHVlID09PSB1bmRlZmluZWRcbiAgICAgID8gJ1tvYmplY3QgVW5kZWZpbmVkXSdcbiAgICAgIDogJ1tvYmplY3QgTnVsbF0nXG4gICAgOiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpXG59XG5cbmNvbnN0IEVYVEVOREVEX1NFQVJDSF9VTkFWQUlMQUJMRSA9ICdFeHRlbmRlZCBzZWFyY2ggaXMgbm90IGF2YWlsYWJsZSc7XG5cbmNvbnN0IElOQ09SUkVDVF9JTkRFWF9UWVBFID0gXCJJbmNvcnJlY3QgJ2luZGV4JyB0eXBlXCI7XG5cbmNvbnN0IExPR0lDQUxfU0VBUkNIX0lOVkFMSURfUVVFUllfRk9SX0tFWSA9IChrZXkpID0+XG4gIGBJbnZhbGlkIHZhbHVlIGZvciBrZXkgJHtrZXl9YDtcblxuY29uc3QgUEFUVEVSTl9MRU5HVEhfVE9PX0xBUkdFID0gKG1heCkgPT5cbiAgYFBhdHRlcm4gbGVuZ3RoIGV4Y2VlZHMgbWF4IG9mICR7bWF4fS5gO1xuXG5jb25zdCBNSVNTSU5HX0tFWV9QUk9QRVJUWSA9IChuYW1lKSA9PiBgTWlzc2luZyAke25hbWV9IHByb3BlcnR5IGluIGtleWA7XG5cbmNvbnN0IElOVkFMSURfS0VZX1dFSUdIVF9WQUxVRSA9IChrZXkpID0+XG4gIGBQcm9wZXJ0eSAnd2VpZ2h0JyBpbiBrZXkgJyR7a2V5fScgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXJgO1xuXG5jb25zdCBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5jbGFzcyBLZXlTdG9yZSB7XG4gIGNvbnN0cnVjdG9yKGtleXMpIHtcbiAgICB0aGlzLl9rZXlzID0gW107XG4gICAgdGhpcy5fa2V5TWFwID0ge307XG5cbiAgICBsZXQgdG90YWxXZWlnaHQgPSAwO1xuXG4gICAga2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGxldCBvYmogPSBjcmVhdGVLZXkoa2V5KTtcblxuICAgICAgdGhpcy5fa2V5cy5wdXNoKG9iaik7XG4gICAgICB0aGlzLl9rZXlNYXBbb2JqLmlkXSA9IG9iajtcblxuICAgICAgdG90YWxXZWlnaHQgKz0gb2JqLndlaWdodDtcbiAgICB9KTtcblxuICAgIC8vIE5vcm1hbGl6ZSB3ZWlnaHRzIHNvIHRoYXQgdGhlaXIgc3VtIGlzIGVxdWFsIHRvIDFcbiAgICB0aGlzLl9rZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAga2V5LndlaWdodCAvPSB0b3RhbFdlaWdodDtcbiAgICB9KTtcbiAgfVxuICBnZXQoa2V5SWQpIHtcbiAgICByZXR1cm4gdGhpcy5fa2V5TWFwW2tleUlkXVxuICB9XG4gIGtleXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2tleXNcbiAgfVxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMuX2tleXMpXG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlS2V5KGtleSkge1xuICBsZXQgcGF0aCA9IG51bGw7XG4gIGxldCBpZCA9IG51bGw7XG4gIGxldCBzcmMgPSBudWxsO1xuICBsZXQgd2VpZ2h0ID0gMTtcbiAgbGV0IGdldEZuID0gbnVsbDtcblxuICBpZiAoaXNTdHJpbmcoa2V5KSB8fCBpc0FycmF5KGtleSkpIHtcbiAgICBzcmMgPSBrZXk7XG4gICAgcGF0aCA9IGNyZWF0ZUtleVBhdGgoa2V5KTtcbiAgICBpZCA9IGNyZWF0ZUtleUlkKGtleSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKCFoYXNPd24uY2FsbChrZXksICduYW1lJykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihNSVNTSU5HX0tFWV9QUk9QRVJUWSgnbmFtZScpKVxuICAgIH1cblxuICAgIGNvbnN0IG5hbWUgPSBrZXkubmFtZTtcbiAgICBzcmMgPSBuYW1lO1xuXG4gICAgaWYgKGhhc093bi5jYWxsKGtleSwgJ3dlaWdodCcpKSB7XG4gICAgICB3ZWlnaHQgPSBrZXkud2VpZ2h0O1xuXG4gICAgICBpZiAod2VpZ2h0IDw9IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKElOVkFMSURfS0VZX1dFSUdIVF9WQUxVRShuYW1lKSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwYXRoID0gY3JlYXRlS2V5UGF0aChuYW1lKTtcbiAgICBpZCA9IGNyZWF0ZUtleUlkKG5hbWUpO1xuICAgIGdldEZuID0ga2V5LmdldEZuO1xuICB9XG5cbiAgcmV0dXJuIHsgcGF0aCwgaWQsIHdlaWdodCwgc3JjLCBnZXRGbiB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUtleVBhdGgoa2V5KSB7XG4gIHJldHVybiBpc0FycmF5KGtleSkgPyBrZXkgOiBrZXkuc3BsaXQoJy4nKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVLZXlJZChrZXkpIHtcbiAgcmV0dXJuIGlzQXJyYXkoa2V5KSA/IGtleS5qb2luKCcuJykgOiBrZXlcbn1cblxuZnVuY3Rpb24gZ2V0KG9iaiwgcGF0aCkge1xuICBsZXQgbGlzdCA9IFtdO1xuICBsZXQgYXJyID0gZmFsc2U7XG5cbiAgY29uc3QgZGVlcEdldCA9IChvYmosIHBhdGgsIGluZGV4KSA9PiB7XG4gICAgaWYgKCFpc0RlZmluZWQob2JqKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGlmICghcGF0aFtpbmRleF0pIHtcbiAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gcGF0aCBsZWZ0LCB3ZSd2ZSBhcnJpdmVkIGF0IHRoZSBvYmplY3Qgd2UgY2FyZSBhYm91dC5cbiAgICAgIGxpc3QucHVzaChvYmopO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQga2V5ID0gcGF0aFtpbmRleF07XG5cbiAgICAgIGNvbnN0IHZhbHVlID0gb2JqW2tleV07XG5cbiAgICAgIGlmICghaXNEZWZpbmVkKHZhbHVlKSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gSWYgd2UncmUgYXQgdGhlIGxhc3QgdmFsdWUgaW4gdGhlIHBhdGgsIGFuZCBpZiBpdCdzIGEgc3RyaW5nL251bWJlci9ib29sLFxuICAgICAgLy8gYWRkIGl0IHRvIHRoZSBsaXN0XG4gICAgICBpZiAoXG4gICAgICAgIGluZGV4ID09PSBwYXRoLmxlbmd0aCAtIDEgJiZcbiAgICAgICAgKGlzU3RyaW5nKHZhbHVlKSB8fCBpc051bWJlcih2YWx1ZSkgfHwgaXNCb29sZWFuKHZhbHVlKSlcbiAgICAgICkge1xuICAgICAgICBsaXN0LnB1c2godG9TdHJpbmcodmFsdWUpKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgYXJyID0gdHJ1ZTtcbiAgICAgICAgLy8gU2VhcmNoIGVhY2ggaXRlbSBpbiB0aGUgYXJyYXkuXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB2YWx1ZS5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgIGRlZXBHZXQodmFsdWVbaV0sIHBhdGgsIGluZGV4ICsgMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocGF0aC5sZW5ndGgpIHtcbiAgICAgICAgLy8gQW4gb2JqZWN0LiBSZWN1cnNlIGZ1cnRoZXIuXG4gICAgICAgIGRlZXBHZXQodmFsdWUsIHBhdGgsIGluZGV4ICsgMSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IChzaW5jZSBwYXRoIHVzZWQgdG8gYmUgYSBzdHJpbmcpXG4gIGRlZXBHZXQob2JqLCBpc1N0cmluZyhwYXRoKSA/IHBhdGguc3BsaXQoJy4nKSA6IHBhdGgsIDApO1xuXG4gIHJldHVybiBhcnIgPyBsaXN0IDogbGlzdFswXVxufVxuXG5jb25zdCBNYXRjaE9wdGlvbnMgPSB7XG4gIC8vIFdoZXRoZXIgdGhlIG1hdGNoZXMgc2hvdWxkIGJlIGluY2x1ZGVkIGluIHRoZSByZXN1bHQgc2V0LiBXaGVuIGB0cnVlYCwgZWFjaCByZWNvcmQgaW4gdGhlIHJlc3VsdFxuICAvLyBzZXQgd2lsbCBpbmNsdWRlIHRoZSBpbmRpY2VzIG9mIHRoZSBtYXRjaGVkIGNoYXJhY3RlcnMuXG4gIC8vIFRoZXNlIGNhbiBjb25zZXF1ZW50bHkgYmUgdXNlZCBmb3IgaGlnaGxpZ2h0aW5nIHB1cnBvc2VzLlxuICBpbmNsdWRlTWF0Y2hlczogZmFsc2UsXG4gIC8vIFdoZW4gYHRydWVgLCB0aGUgbWF0Y2hpbmcgZnVuY3Rpb24gd2lsbCBjb250aW51ZSB0byB0aGUgZW5kIG9mIGEgc2VhcmNoIHBhdHRlcm4gZXZlbiBpZlxuICAvLyBhIHBlcmZlY3QgbWF0Y2ggaGFzIGFscmVhZHkgYmVlbiBsb2NhdGVkIGluIHRoZSBzdHJpbmcuXG4gIGZpbmRBbGxNYXRjaGVzOiBmYWxzZSxcbiAgLy8gTWluaW11bSBudW1iZXIgb2YgY2hhcmFjdGVycyB0aGF0IG11c3QgYmUgbWF0Y2hlZCBiZWZvcmUgYSByZXN1bHQgaXMgY29uc2lkZXJlZCBhIG1hdGNoXG4gIG1pbk1hdGNoQ2hhckxlbmd0aDogMVxufTtcblxuY29uc3QgQmFzaWNPcHRpb25zID0ge1xuICAvLyBXaGVuIGB0cnVlYCwgdGhlIGFsZ29yaXRobSBjb250aW51ZXMgc2VhcmNoaW5nIHRvIHRoZSBlbmQgb2YgdGhlIGlucHV0IGV2ZW4gaWYgYSBwZXJmZWN0XG4gIC8vIG1hdGNoIGlzIGZvdW5kIGJlZm9yZSB0aGUgZW5kIG9mIHRoZSBzYW1lIGlucHV0LlxuICBpc0Nhc2VTZW5zaXRpdmU6IGZhbHNlLFxuICAvLyBXaGVuIHRydWUsIHRoZSBtYXRjaGluZyBmdW5jdGlvbiB3aWxsIGNvbnRpbnVlIHRvIHRoZSBlbmQgb2YgYSBzZWFyY2ggcGF0dGVybiBldmVuIGlmXG4gIGluY2x1ZGVTY29yZTogZmFsc2UsXG4gIC8vIExpc3Qgb2YgcHJvcGVydGllcyB0aGF0IHdpbGwgYmUgc2VhcmNoZWQuIFRoaXMgYWxzbyBzdXBwb3J0cyBuZXN0ZWQgcHJvcGVydGllcy5cbiAga2V5czogW10sXG4gIC8vIFdoZXRoZXIgdG8gc29ydCB0aGUgcmVzdWx0IGxpc3QsIGJ5IHNjb3JlXG4gIHNob3VsZFNvcnQ6IHRydWUsXG4gIC8vIERlZmF1bHQgc29ydCBmdW5jdGlvbjogc29ydCBieSBhc2NlbmRpbmcgc2NvcmUsIGFzY2VuZGluZyBpbmRleFxuICBzb3J0Rm46IChhLCBiKSA9PlxuICAgIGEuc2NvcmUgPT09IGIuc2NvcmUgPyAoYS5pZHggPCBiLmlkeCA/IC0xIDogMSkgOiBhLnNjb3JlIDwgYi5zY29yZSA/IC0xIDogMVxufTtcblxuY29uc3QgRnV6enlPcHRpb25zID0ge1xuICAvLyBBcHByb3hpbWF0ZWx5IHdoZXJlIGluIHRoZSB0ZXh0IGlzIHRoZSBwYXR0ZXJuIGV4cGVjdGVkIHRvIGJlIGZvdW5kP1xuICBsb2NhdGlvbjogMCxcbiAgLy8gQXQgd2hhdCBwb2ludCBkb2VzIHRoZSBtYXRjaCBhbGdvcml0aG0gZ2l2ZSB1cC4gQSB0aHJlc2hvbGQgb2YgJzAuMCcgcmVxdWlyZXMgYSBwZXJmZWN0IG1hdGNoXG4gIC8vIChvZiBib3RoIGxldHRlcnMgYW5kIGxvY2F0aW9uKSwgYSB0aHJlc2hvbGQgb2YgJzEuMCcgd291bGQgbWF0Y2ggYW55dGhpbmcuXG4gIHRocmVzaG9sZDogMC42LFxuICAvLyBEZXRlcm1pbmVzIGhvdyBjbG9zZSB0aGUgbWF0Y2ggbXVzdCBiZSB0byB0aGUgZnV6enkgbG9jYXRpb24gKHNwZWNpZmllZCBhYm92ZSkuXG4gIC8vIEFuIGV4YWN0IGxldHRlciBtYXRjaCB3aGljaCBpcyAnZGlzdGFuY2UnIGNoYXJhY3RlcnMgYXdheSBmcm9tIHRoZSBmdXp6eSBsb2NhdGlvblxuICAvLyB3b3VsZCBzY29yZSBhcyBhIGNvbXBsZXRlIG1pc21hdGNoLiBBIGRpc3RhbmNlIG9mICcwJyByZXF1aXJlcyB0aGUgbWF0Y2ggYmUgYXRcbiAgLy8gdGhlIGV4YWN0IGxvY2F0aW9uIHNwZWNpZmllZCwgYSB0aHJlc2hvbGQgb2YgJzEwMDAnIHdvdWxkIHJlcXVpcmUgYSBwZXJmZWN0IG1hdGNoXG4gIC8vIHRvIGJlIHdpdGhpbiA4MDAgY2hhcmFjdGVycyBvZiB0aGUgZnV6enkgbG9jYXRpb24gdG8gYmUgZm91bmQgdXNpbmcgYSAwLjggdGhyZXNob2xkLlxuICBkaXN0YW5jZTogMTAwXG59O1xuXG5jb25zdCBBZHZhbmNlZE9wdGlvbnMgPSB7XG4gIC8vIFdoZW4gYHRydWVgLCBpdCBlbmFibGVzIHRoZSB1c2Ugb2YgdW5peC1saWtlIHNlYXJjaCBjb21tYW5kc1xuICB1c2VFeHRlbmRlZFNlYXJjaDogZmFsc2UsXG4gIC8vIFRoZSBnZXQgZnVuY3Rpb24gdG8gdXNlIHdoZW4gZmV0Y2hpbmcgYW4gb2JqZWN0J3MgcHJvcGVydGllcy5cbiAgLy8gVGhlIGRlZmF1bHQgd2lsbCBzZWFyY2ggbmVzdGVkIHBhdGhzICppZSBmb28uYmFyLmJheipcbiAgZ2V0Rm46IGdldCxcbiAgLy8gV2hlbiBgdHJ1ZWAsIHNlYXJjaCB3aWxsIGlnbm9yZSBgbG9jYXRpb25gIGFuZCBgZGlzdGFuY2VgLCBzbyBpdCB3b24ndCBtYXR0ZXJcbiAgLy8gd2hlcmUgaW4gdGhlIHN0cmluZyB0aGUgcGF0dGVybiBhcHBlYXJzLlxuICAvLyBNb3JlIGluZm86IGh0dHBzOi8vZnVzZWpzLmlvL2NvbmNlcHRzL3Njb3JpbmctdGhlb3J5Lmh0bWwjZnV6emluZXNzLXNjb3JlXG4gIGlnbm9yZUxvY2F0aW9uOiBmYWxzZSxcbiAgLy8gV2hlbiBgdHJ1ZWAsIHRoZSBjYWxjdWxhdGlvbiBmb3IgdGhlIHJlbGV2YW5jZSBzY29yZSAodXNlZCBmb3Igc29ydGluZykgd2lsbFxuICAvLyBpZ25vcmUgdGhlIGZpZWxkLWxlbmd0aCBub3JtLlxuICAvLyBNb3JlIGluZm86IGh0dHBzOi8vZnVzZWpzLmlvL2NvbmNlcHRzL3Njb3JpbmctdGhlb3J5Lmh0bWwjZmllbGQtbGVuZ3RoLW5vcm1cbiAgaWdub3JlRmllbGROb3JtOiBmYWxzZSxcbiAgLy8gVGhlIHdlaWdodCB0byBkZXRlcm1pbmUgaG93IG11Y2ggZmllbGQgbGVuZ3RoIG5vcm0gZWZmZWN0cyBzY29yaW5nLlxuICBmaWVsZE5vcm1XZWlnaHQ6IDFcbn07XG5cbnZhciBDb25maWcgPSB7XG4gIC4uLkJhc2ljT3B0aW9ucyxcbiAgLi4uTWF0Y2hPcHRpb25zLFxuICAuLi5GdXp6eU9wdGlvbnMsXG4gIC4uLkFkdmFuY2VkT3B0aW9uc1xufTtcblxuY29uc3QgU1BBQ0UgPSAvW14gXSsvZztcblxuLy8gRmllbGQtbGVuZ3RoIG5vcm06IHRoZSBzaG9ydGVyIHRoZSBmaWVsZCwgdGhlIGhpZ2hlciB0aGUgd2VpZ2h0LlxuLy8gU2V0IHRvIDMgZGVjaW1hbHMgdG8gcmVkdWNlIGluZGV4IHNpemUuXG5mdW5jdGlvbiBub3JtKHdlaWdodCA9IDEsIG1hbnRpc3NhID0gMykge1xuICBjb25zdCBjYWNoZSA9IG5ldyBNYXAoKTtcbiAgY29uc3QgbSA9IE1hdGgucG93KDEwLCBtYW50aXNzYSk7XG5cbiAgcmV0dXJuIHtcbiAgICBnZXQodmFsdWUpIHtcbiAgICAgIGNvbnN0IG51bVRva2VucyA9IHZhbHVlLm1hdGNoKFNQQUNFKS5sZW5ndGg7XG5cbiAgICAgIGlmIChjYWNoZS5oYXMobnVtVG9rZW5zKSkge1xuICAgICAgICByZXR1cm4gY2FjaGUuZ2V0KG51bVRva2VucylcbiAgICAgIH1cblxuICAgICAgLy8gRGVmYXVsdCBmdW5jdGlvbiBpcyAxL3NxcnQoeCksIHdlaWdodCBtYWtlcyB0aGF0IHZhcmlhYmxlXG4gICAgICBjb25zdCBub3JtID0gMSAvIE1hdGgucG93KG51bVRva2VucywgMC41ICogd2VpZ2h0KTtcblxuICAgICAgLy8gSW4gcGxhY2Ugb2YgYHRvRml4ZWQobWFudGlzc2EpYCwgZm9yIGZhc3RlciBjb21wdXRhdGlvblxuICAgICAgY29uc3QgbiA9IHBhcnNlRmxvYXQoTWF0aC5yb3VuZChub3JtICogbSkgLyBtKTtcblxuICAgICAgY2FjaGUuc2V0KG51bVRva2Vucywgbik7XG5cbiAgICAgIHJldHVybiBuXG4gICAgfSxcbiAgICBjbGVhcigpIHtcbiAgICAgIGNhY2hlLmNsZWFyKCk7XG4gICAgfVxuICB9XG59XG5cbmNsYXNzIEZ1c2VJbmRleCB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBnZXRGbiA9IENvbmZpZy5nZXRGbixcbiAgICBmaWVsZE5vcm1XZWlnaHQgPSBDb25maWcuZmllbGROb3JtV2VpZ2h0XG4gIH0gPSB7fSkge1xuICAgIHRoaXMubm9ybSA9IG5vcm0oZmllbGROb3JtV2VpZ2h0LCAzKTtcbiAgICB0aGlzLmdldEZuID0gZ2V0Rm47XG4gICAgdGhpcy5pc0NyZWF0ZWQgPSBmYWxzZTtcblxuICAgIHRoaXMuc2V0SW5kZXhSZWNvcmRzKCk7XG4gIH1cbiAgc2V0U291cmNlcyhkb2NzID0gW10pIHtcbiAgICB0aGlzLmRvY3MgPSBkb2NzO1xuICB9XG4gIHNldEluZGV4UmVjb3JkcyhyZWNvcmRzID0gW10pIHtcbiAgICB0aGlzLnJlY29yZHMgPSByZWNvcmRzO1xuICB9XG4gIHNldEtleXMoa2V5cyA9IFtdKSB7XG4gICAgdGhpcy5rZXlzID0ga2V5cztcbiAgICB0aGlzLl9rZXlzTWFwID0ge307XG4gICAga2V5cy5mb3JFYWNoKChrZXksIGlkeCkgPT4ge1xuICAgICAgdGhpcy5fa2V5c01hcFtrZXkuaWRdID0gaWR4O1xuICAgIH0pO1xuICB9XG4gIGNyZWF0ZSgpIHtcbiAgICBpZiAodGhpcy5pc0NyZWF0ZWQgfHwgIXRoaXMuZG9jcy5sZW5ndGgpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuaXNDcmVhdGVkID0gdHJ1ZTtcblxuICAgIC8vIExpc3QgaXMgQXJyYXk8U3RyaW5nPlxuICAgIGlmIChpc1N0cmluZyh0aGlzLmRvY3NbMF0pKSB7XG4gICAgICB0aGlzLmRvY3MuZm9yRWFjaCgoZG9jLCBkb2NJbmRleCkgPT4ge1xuICAgICAgICB0aGlzLl9hZGRTdHJpbmcoZG9jLCBkb2NJbmRleCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTGlzdCBpcyBBcnJheTxPYmplY3Q+XG4gICAgICB0aGlzLmRvY3MuZm9yRWFjaCgoZG9jLCBkb2NJbmRleCkgPT4ge1xuICAgICAgICB0aGlzLl9hZGRPYmplY3QoZG9jLCBkb2NJbmRleCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLm5vcm0uY2xlYXIoKTtcbiAgfVxuICAvLyBBZGRzIGEgZG9jIHRvIHRoZSBlbmQgb2YgdGhlIGluZGV4XG4gIGFkZChkb2MpIHtcbiAgICBjb25zdCBpZHggPSB0aGlzLnNpemUoKTtcblxuICAgIGlmIChpc1N0cmluZyhkb2MpKSB7XG4gICAgICB0aGlzLl9hZGRTdHJpbmcoZG9jLCBpZHgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9hZGRPYmplY3QoZG9jLCBpZHgpO1xuICAgIH1cbiAgfVxuICAvLyBSZW1vdmVzIHRoZSBkb2MgYXQgdGhlIHNwZWNpZmllZCBpbmRleCBvZiB0aGUgaW5kZXhcbiAgcmVtb3ZlQXQoaWR4KSB7XG4gICAgdGhpcy5yZWNvcmRzLnNwbGljZShpZHgsIDEpO1xuXG4gICAgLy8gQ2hhbmdlIHJlZiBpbmRleCBvZiBldmVyeSBzdWJzcXVlbnQgZG9jXG4gICAgZm9yIChsZXQgaSA9IGlkeCwgbGVuID0gdGhpcy5zaXplKCk7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgdGhpcy5yZWNvcmRzW2ldLmkgLT0gMTtcbiAgICB9XG4gIH1cbiAgZ2V0VmFsdWVGb3JJdGVtQXRLZXlJZChpdGVtLCBrZXlJZCkge1xuICAgIHJldHVybiBpdGVtW3RoaXMuX2tleXNNYXBba2V5SWRdXVxuICB9XG4gIHNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVjb3Jkcy5sZW5ndGhcbiAgfVxuICBfYWRkU3RyaW5nKGRvYywgZG9jSW5kZXgpIHtcbiAgICBpZiAoIWlzRGVmaW5lZChkb2MpIHx8IGlzQmxhbmsoZG9jKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgbGV0IHJlY29yZCA9IHtcbiAgICAgIHY6IGRvYyxcbiAgICAgIGk6IGRvY0luZGV4LFxuICAgICAgbjogdGhpcy5ub3JtLmdldChkb2MpXG4gICAgfTtcblxuICAgIHRoaXMucmVjb3Jkcy5wdXNoKHJlY29yZCk7XG4gIH1cbiAgX2FkZE9iamVjdChkb2MsIGRvY0luZGV4KSB7XG4gICAgbGV0IHJlY29yZCA9IHsgaTogZG9jSW5kZXgsICQ6IHt9IH07XG5cbiAgICAvLyBJdGVyYXRlIG92ZXIgZXZlcnkga2V5IChpLmUsIHBhdGgpLCBhbmQgZmV0Y2ggdGhlIHZhbHVlIGF0IHRoYXQga2V5XG4gICAgdGhpcy5rZXlzLmZvckVhY2goKGtleSwga2V5SW5kZXgpID0+IHtcbiAgICAgIGxldCB2YWx1ZSA9IGtleS5nZXRGbiA/IGtleS5nZXRGbihkb2MpIDogdGhpcy5nZXRGbihkb2MsIGtleS5wYXRoKTtcblxuICAgICAgaWYgKCFpc0RlZmluZWQodmFsdWUpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgbGV0IHN1YlJlY29yZHMgPSBbXTtcbiAgICAgICAgY29uc3Qgc3RhY2sgPSBbeyBuZXN0ZWRBcnJJbmRleDogLTEsIHZhbHVlIH1dO1xuXG4gICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGgpIHtcbiAgICAgICAgICBjb25zdCB7IG5lc3RlZEFyckluZGV4LCB2YWx1ZSB9ID0gc3RhY2sucG9wKCk7XG5cbiAgICAgICAgICBpZiAoIWlzRGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGlzU3RyaW5nKHZhbHVlKSAmJiAhaXNCbGFuayh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGxldCBzdWJSZWNvcmQgPSB7XG4gICAgICAgICAgICAgIHY6IHZhbHVlLFxuICAgICAgICAgICAgICBpOiBuZXN0ZWRBcnJJbmRleCxcbiAgICAgICAgICAgICAgbjogdGhpcy5ub3JtLmdldCh2YWx1ZSlcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHN1YlJlY29yZHMucHVzaChzdWJSZWNvcmQpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbHVlLmZvckVhY2goKGl0ZW0sIGspID0+IHtcbiAgICAgICAgICAgICAgc3RhY2sucHVzaCh7XG4gICAgICAgICAgICAgICAgbmVzdGVkQXJySW5kZXg6IGssXG4gICAgICAgICAgICAgICAgdmFsdWU6IGl0ZW1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2UgO1xuICAgICAgICB9XG4gICAgICAgIHJlY29yZC4kW2tleUluZGV4XSA9IHN1YlJlY29yZHM7XG4gICAgICB9IGVsc2UgaWYgKGlzU3RyaW5nKHZhbHVlKSAmJiAhaXNCbGFuayh2YWx1ZSkpIHtcbiAgICAgICAgbGV0IHN1YlJlY29yZCA9IHtcbiAgICAgICAgICB2OiB2YWx1ZSxcbiAgICAgICAgICBuOiB0aGlzLm5vcm0uZ2V0KHZhbHVlKVxuICAgICAgICB9O1xuXG4gICAgICAgIHJlY29yZC4kW2tleUluZGV4XSA9IHN1YlJlY29yZDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMucmVjb3Jkcy5wdXNoKHJlY29yZCk7XG4gIH1cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBrZXlzOiB0aGlzLmtleXMsXG4gICAgICByZWNvcmRzOiB0aGlzLnJlY29yZHNcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlSW5kZXgoXG4gIGtleXMsXG4gIGRvY3MsXG4gIHsgZ2V0Rm4gPSBDb25maWcuZ2V0Rm4sIGZpZWxkTm9ybVdlaWdodCA9IENvbmZpZy5maWVsZE5vcm1XZWlnaHQgfSA9IHt9XG4pIHtcbiAgY29uc3QgbXlJbmRleCA9IG5ldyBGdXNlSW5kZXgoeyBnZXRGbiwgZmllbGROb3JtV2VpZ2h0IH0pO1xuICBteUluZGV4LnNldEtleXMoa2V5cy5tYXAoY3JlYXRlS2V5KSk7XG4gIG15SW5kZXguc2V0U291cmNlcyhkb2NzKTtcbiAgbXlJbmRleC5jcmVhdGUoKTtcbiAgcmV0dXJuIG15SW5kZXhcbn1cblxuZnVuY3Rpb24gcGFyc2VJbmRleChcbiAgZGF0YSxcbiAgeyBnZXRGbiA9IENvbmZpZy5nZXRGbiwgZmllbGROb3JtV2VpZ2h0ID0gQ29uZmlnLmZpZWxkTm9ybVdlaWdodCB9ID0ge31cbikge1xuICBjb25zdCB7IGtleXMsIHJlY29yZHMgfSA9IGRhdGE7XG4gIGNvbnN0IG15SW5kZXggPSBuZXcgRnVzZUluZGV4KHsgZ2V0Rm4sIGZpZWxkTm9ybVdlaWdodCB9KTtcbiAgbXlJbmRleC5zZXRLZXlzKGtleXMpO1xuICBteUluZGV4LnNldEluZGV4UmVjb3JkcyhyZWNvcmRzKTtcbiAgcmV0dXJuIG15SW5kZXhcbn1cblxuZnVuY3Rpb24gY29tcHV0ZVNjb3JlJDEoXG4gIHBhdHRlcm4sXG4gIHtcbiAgICBlcnJvcnMgPSAwLFxuICAgIGN1cnJlbnRMb2NhdGlvbiA9IDAsXG4gICAgZXhwZWN0ZWRMb2NhdGlvbiA9IDAsXG4gICAgZGlzdGFuY2UgPSBDb25maWcuZGlzdGFuY2UsXG4gICAgaWdub3JlTG9jYXRpb24gPSBDb25maWcuaWdub3JlTG9jYXRpb25cbiAgfSA9IHt9XG4pIHtcbiAgY29uc3QgYWNjdXJhY3kgPSBlcnJvcnMgLyBwYXR0ZXJuLmxlbmd0aDtcblxuICBpZiAoaWdub3JlTG9jYXRpb24pIHtcbiAgICByZXR1cm4gYWNjdXJhY3lcbiAgfVxuXG4gIGNvbnN0IHByb3hpbWl0eSA9IE1hdGguYWJzKGV4cGVjdGVkTG9jYXRpb24gLSBjdXJyZW50TG9jYXRpb24pO1xuXG4gIGlmICghZGlzdGFuY2UpIHtcbiAgICAvLyBEb2RnZSBkaXZpZGUgYnkgemVybyBlcnJvci5cbiAgICByZXR1cm4gcHJveGltaXR5ID8gMS4wIDogYWNjdXJhY3lcbiAgfVxuXG4gIHJldHVybiBhY2N1cmFjeSArIHByb3hpbWl0eSAvIGRpc3RhbmNlXG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRNYXNrVG9JbmRpY2VzKFxuICBtYXRjaG1hc2sgPSBbXSxcbiAgbWluTWF0Y2hDaGFyTGVuZ3RoID0gQ29uZmlnLm1pbk1hdGNoQ2hhckxlbmd0aFxuKSB7XG4gIGxldCBpbmRpY2VzID0gW107XG4gIGxldCBzdGFydCA9IC0xO1xuICBsZXQgZW5kID0gLTE7XG4gIGxldCBpID0gMDtcblxuICBmb3IgKGxldCBsZW4gPSBtYXRjaG1hc2subGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICBsZXQgbWF0Y2ggPSBtYXRjaG1hc2tbaV07XG4gICAgaWYgKG1hdGNoICYmIHN0YXJ0ID09PSAtMSkge1xuICAgICAgc3RhcnQgPSBpO1xuICAgIH0gZWxzZSBpZiAoIW1hdGNoICYmIHN0YXJ0ICE9PSAtMSkge1xuICAgICAgZW5kID0gaSAtIDE7XG4gICAgICBpZiAoZW5kIC0gc3RhcnQgKyAxID49IG1pbk1hdGNoQ2hhckxlbmd0aCkge1xuICAgICAgICBpbmRpY2VzLnB1c2goW3N0YXJ0LCBlbmRdKTtcbiAgICAgIH1cbiAgICAgIHN0YXJ0ID0gLTE7XG4gICAgfVxuICB9XG5cbiAgLy8gKGktMSAtIHN0YXJ0KSArIDEgPT4gaSAtIHN0YXJ0XG4gIGlmIChtYXRjaG1hc2tbaSAtIDFdICYmIGkgLSBzdGFydCA+PSBtaW5NYXRjaENoYXJMZW5ndGgpIHtcbiAgICBpbmRpY2VzLnB1c2goW3N0YXJ0LCBpIC0gMV0pO1xuICB9XG5cbiAgcmV0dXJuIGluZGljZXNcbn1cblxuLy8gTWFjaGluZSB3b3JkIHNpemVcbmNvbnN0IE1BWF9CSVRTID0gMzI7XG5cbmZ1bmN0aW9uIHNlYXJjaChcbiAgdGV4dCxcbiAgcGF0dGVybixcbiAgcGF0dGVybkFscGhhYmV0LFxuICB7XG4gICAgbG9jYXRpb24gPSBDb25maWcubG9jYXRpb24sXG4gICAgZGlzdGFuY2UgPSBDb25maWcuZGlzdGFuY2UsXG4gICAgdGhyZXNob2xkID0gQ29uZmlnLnRocmVzaG9sZCxcbiAgICBmaW5kQWxsTWF0Y2hlcyA9IENvbmZpZy5maW5kQWxsTWF0Y2hlcyxcbiAgICBtaW5NYXRjaENoYXJMZW5ndGggPSBDb25maWcubWluTWF0Y2hDaGFyTGVuZ3RoLFxuICAgIGluY2x1ZGVNYXRjaGVzID0gQ29uZmlnLmluY2x1ZGVNYXRjaGVzLFxuICAgIGlnbm9yZUxvY2F0aW9uID0gQ29uZmlnLmlnbm9yZUxvY2F0aW9uXG4gIH0gPSB7fVxuKSB7XG4gIGlmIChwYXR0ZXJuLmxlbmd0aCA+IE1BWF9CSVRTKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFBBVFRFUk5fTEVOR1RIX1RPT19MQVJHRShNQVhfQklUUykpXG4gIH1cblxuICBjb25zdCBwYXR0ZXJuTGVuID0gcGF0dGVybi5sZW5ndGg7XG4gIC8vIFNldCBzdGFydGluZyBsb2NhdGlvbiBhdCBiZWdpbm5pbmcgdGV4dCBhbmQgaW5pdGlhbGl6ZSB0aGUgYWxwaGFiZXQuXG4gIGNvbnN0IHRleHRMZW4gPSB0ZXh0Lmxlbmd0aDtcbiAgLy8gSGFuZGxlIHRoZSBjYXNlIHdoZW4gbG9jYXRpb24gPiB0ZXh0Lmxlbmd0aFxuICBjb25zdCBleHBlY3RlZExvY2F0aW9uID0gTWF0aC5tYXgoMCwgTWF0aC5taW4obG9jYXRpb24sIHRleHRMZW4pKTtcbiAgLy8gSGlnaGVzdCBzY29yZSBiZXlvbmQgd2hpY2ggd2UgZ2l2ZSB1cC5cbiAgbGV0IGN1cnJlbnRUaHJlc2hvbGQgPSB0aHJlc2hvbGQ7XG4gIC8vIElzIHRoZXJlIGEgbmVhcmJ5IGV4YWN0IG1hdGNoPyAoc3BlZWR1cClcbiAgbGV0IGJlc3RMb2NhdGlvbiA9IGV4cGVjdGVkTG9jYXRpb247XG5cbiAgLy8gUGVyZm9ybWFuY2U6IG9ubHkgY29tcHV0ZXIgbWF0Y2hlcyB3aGVuIHRoZSBtaW5NYXRjaENoYXJMZW5ndGggPiAxXG4gIC8vIE9SIGlmIGBpbmNsdWRlTWF0Y2hlc2AgaXMgdHJ1ZS5cbiAgY29uc3QgY29tcHV0ZU1hdGNoZXMgPSBtaW5NYXRjaENoYXJMZW5ndGggPiAxIHx8IGluY2x1ZGVNYXRjaGVzO1xuICAvLyBBIG1hc2sgb2YgdGhlIG1hdGNoZXMsIHVzZWQgZm9yIGJ1aWxkaW5nIHRoZSBpbmRpY2VzXG4gIGNvbnN0IG1hdGNoTWFzayA9IGNvbXB1dGVNYXRjaGVzID8gQXJyYXkodGV4dExlbikgOiBbXTtcblxuICBsZXQgaW5kZXg7XG5cbiAgLy8gR2V0IGFsbCBleGFjdCBtYXRjaGVzLCBoZXJlIGZvciBzcGVlZCB1cFxuICB3aGlsZSAoKGluZGV4ID0gdGV4dC5pbmRleE9mKHBhdHRlcm4sIGJlc3RMb2NhdGlvbikpID4gLTEpIHtcbiAgICBsZXQgc2NvcmUgPSBjb21wdXRlU2NvcmUkMShwYXR0ZXJuLCB7XG4gICAgICBjdXJyZW50TG9jYXRpb246IGluZGV4LFxuICAgICAgZXhwZWN0ZWRMb2NhdGlvbixcbiAgICAgIGRpc3RhbmNlLFxuICAgICAgaWdub3JlTG9jYXRpb25cbiAgICB9KTtcblxuICAgIGN1cnJlbnRUaHJlc2hvbGQgPSBNYXRoLm1pbihzY29yZSwgY3VycmVudFRocmVzaG9sZCk7XG4gICAgYmVzdExvY2F0aW9uID0gaW5kZXggKyBwYXR0ZXJuTGVuO1xuXG4gICAgaWYgKGNvbXB1dGVNYXRjaGVzKSB7XG4gICAgICBsZXQgaSA9IDA7XG4gICAgICB3aGlsZSAoaSA8IHBhdHRlcm5MZW4pIHtcbiAgICAgICAgbWF0Y2hNYXNrW2luZGV4ICsgaV0gPSAxO1xuICAgICAgICBpICs9IDE7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gUmVzZXQgdGhlIGJlc3QgbG9jYXRpb25cbiAgYmVzdExvY2F0aW9uID0gLTE7XG5cbiAgbGV0IGxhc3RCaXRBcnIgPSBbXTtcbiAgbGV0IGZpbmFsU2NvcmUgPSAxO1xuICBsZXQgYmluTWF4ID0gcGF0dGVybkxlbiArIHRleHRMZW47XG5cbiAgY29uc3QgbWFzayA9IDEgPDwgKHBhdHRlcm5MZW4gLSAxKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdHRlcm5MZW47IGkgKz0gMSkge1xuICAgIC8vIFNjYW4gZm9yIHRoZSBiZXN0IG1hdGNoOyBlYWNoIGl0ZXJhdGlvbiBhbGxvd3MgZm9yIG9uZSBtb3JlIGVycm9yLlxuICAgIC8vIFJ1biBhIGJpbmFyeSBzZWFyY2ggdG8gZGV0ZXJtaW5lIGhvdyBmYXIgZnJvbSB0aGUgbWF0Y2ggbG9jYXRpb24gd2UgY2FuIHN0cmF5XG4gICAgLy8gYXQgdGhpcyBlcnJvciBsZXZlbC5cbiAgICBsZXQgYmluTWluID0gMDtcbiAgICBsZXQgYmluTWlkID0gYmluTWF4O1xuXG4gICAgd2hpbGUgKGJpbk1pbiA8IGJpbk1pZCkge1xuICAgICAgY29uc3Qgc2NvcmUgPSBjb21wdXRlU2NvcmUkMShwYXR0ZXJuLCB7XG4gICAgICAgIGVycm9yczogaSxcbiAgICAgICAgY3VycmVudExvY2F0aW9uOiBleHBlY3RlZExvY2F0aW9uICsgYmluTWlkLFxuICAgICAgICBleHBlY3RlZExvY2F0aW9uLFxuICAgICAgICBkaXN0YW5jZSxcbiAgICAgICAgaWdub3JlTG9jYXRpb25cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoc2NvcmUgPD0gY3VycmVudFRocmVzaG9sZCkge1xuICAgICAgICBiaW5NaW4gPSBiaW5NaWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiaW5NYXggPSBiaW5NaWQ7XG4gICAgICB9XG5cbiAgICAgIGJpbk1pZCA9IE1hdGguZmxvb3IoKGJpbk1heCAtIGJpbk1pbikgLyAyICsgYmluTWluKTtcbiAgICB9XG5cbiAgICAvLyBVc2UgdGhlIHJlc3VsdCBmcm9tIHRoaXMgaXRlcmF0aW9uIGFzIHRoZSBtYXhpbXVtIGZvciB0aGUgbmV4dC5cbiAgICBiaW5NYXggPSBiaW5NaWQ7XG5cbiAgICBsZXQgc3RhcnQgPSBNYXRoLm1heCgxLCBleHBlY3RlZExvY2F0aW9uIC0gYmluTWlkICsgMSk7XG4gICAgbGV0IGZpbmlzaCA9IGZpbmRBbGxNYXRjaGVzXG4gICAgICA/IHRleHRMZW5cbiAgICAgIDogTWF0aC5taW4oZXhwZWN0ZWRMb2NhdGlvbiArIGJpbk1pZCwgdGV4dExlbikgKyBwYXR0ZXJuTGVuO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgYml0IGFycmF5XG4gICAgbGV0IGJpdEFyciA9IEFycmF5KGZpbmlzaCArIDIpO1xuXG4gICAgYml0QXJyW2ZpbmlzaCArIDFdID0gKDEgPDwgaSkgLSAxO1xuXG4gICAgZm9yIChsZXQgaiA9IGZpbmlzaDsgaiA+PSBzdGFydDsgaiAtPSAxKSB7XG4gICAgICBsZXQgY3VycmVudExvY2F0aW9uID0gaiAtIDE7XG4gICAgICBsZXQgY2hhck1hdGNoID0gcGF0dGVybkFscGhhYmV0W3RleHQuY2hhckF0KGN1cnJlbnRMb2NhdGlvbildO1xuXG4gICAgICBpZiAoY29tcHV0ZU1hdGNoZXMpIHtcbiAgICAgICAgLy8gU3BlZWQgdXA6IHF1aWNrIGJvb2wgdG8gaW50IGNvbnZlcnNpb24gKGkuZSwgYGNoYXJNYXRjaCA/IDEgOiAwYClcbiAgICAgICAgbWF0Y2hNYXNrW2N1cnJlbnRMb2NhdGlvbl0gPSArISFjaGFyTWF0Y2g7XG4gICAgICB9XG5cbiAgICAgIC8vIEZpcnN0IHBhc3M6IGV4YWN0IG1hdGNoXG4gICAgICBiaXRBcnJbal0gPSAoKGJpdEFycltqICsgMV0gPDwgMSkgfCAxKSAmIGNoYXJNYXRjaDtcblxuICAgICAgLy8gU3Vic2VxdWVudCBwYXNzZXM6IGZ1enp5IG1hdGNoXG4gICAgICBpZiAoaSkge1xuICAgICAgICBiaXRBcnJbal0gfD1cbiAgICAgICAgICAoKGxhc3RCaXRBcnJbaiArIDFdIHwgbGFzdEJpdEFycltqXSkgPDwgMSkgfCAxIHwgbGFzdEJpdEFycltqICsgMV07XG4gICAgICB9XG5cbiAgICAgIGlmIChiaXRBcnJbal0gJiBtYXNrKSB7XG4gICAgICAgIGZpbmFsU2NvcmUgPSBjb21wdXRlU2NvcmUkMShwYXR0ZXJuLCB7XG4gICAgICAgICAgZXJyb3JzOiBpLFxuICAgICAgICAgIGN1cnJlbnRMb2NhdGlvbixcbiAgICAgICAgICBleHBlY3RlZExvY2F0aW9uLFxuICAgICAgICAgIGRpc3RhbmNlLFxuICAgICAgICAgIGlnbm9yZUxvY2F0aW9uXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFRoaXMgbWF0Y2ggd2lsbCBhbG1vc3QgY2VydGFpbmx5IGJlIGJldHRlciB0aGFuIGFueSBleGlzdGluZyBtYXRjaC5cbiAgICAgICAgLy8gQnV0IGNoZWNrIGFueXdheS5cbiAgICAgICAgaWYgKGZpbmFsU2NvcmUgPD0gY3VycmVudFRocmVzaG9sZCkge1xuICAgICAgICAgIC8vIEluZGVlZCBpdCBpc1xuICAgICAgICAgIGN1cnJlbnRUaHJlc2hvbGQgPSBmaW5hbFNjb3JlO1xuICAgICAgICAgIGJlc3RMb2NhdGlvbiA9IGN1cnJlbnRMb2NhdGlvbjtcblxuICAgICAgICAgIC8vIEFscmVhZHkgcGFzc2VkIGBsb2NgLCBkb3duaGlsbCBmcm9tIGhlcmUgb24gaW4uXG4gICAgICAgICAgaWYgKGJlc3RMb2NhdGlvbiA8PSBleHBlY3RlZExvY2F0aW9uKSB7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFdoZW4gcGFzc2luZyBgYmVzdExvY2F0aW9uYCwgZG9uJ3QgZXhjZWVkIG91ciBjdXJyZW50IGRpc3RhbmNlIGZyb20gYGV4cGVjdGVkTG9jYXRpb25gLlxuICAgICAgICAgIHN0YXJ0ID0gTWF0aC5tYXgoMSwgMiAqIGV4cGVjdGVkTG9jYXRpb24gLSBiZXN0TG9jYXRpb24pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTm8gaG9wZSBmb3IgYSAoYmV0dGVyKSBtYXRjaCBhdCBncmVhdGVyIGVycm9yIGxldmVscy5cbiAgICBjb25zdCBzY29yZSA9IGNvbXB1dGVTY29yZSQxKHBhdHRlcm4sIHtcbiAgICAgIGVycm9yczogaSArIDEsXG4gICAgICBjdXJyZW50TG9jYXRpb246IGV4cGVjdGVkTG9jYXRpb24sXG4gICAgICBleHBlY3RlZExvY2F0aW9uLFxuICAgICAgZGlzdGFuY2UsXG4gICAgICBpZ25vcmVMb2NhdGlvblxuICAgIH0pO1xuXG4gICAgaWYgKHNjb3JlID4gY3VycmVudFRocmVzaG9sZCkge1xuICAgICAgYnJlYWtcbiAgICB9XG5cbiAgICBsYXN0Qml0QXJyID0gYml0QXJyO1xuICB9XG5cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIGlzTWF0Y2g6IGJlc3RMb2NhdGlvbiA+PSAwLFxuICAgIC8vIENvdW50IGV4YWN0IG1hdGNoZXMgKHRob3NlIHdpdGggYSBzY29yZSBvZiAwKSB0byBiZSBcImFsbW9zdFwiIGV4YWN0XG4gICAgc2NvcmU6IE1hdGgubWF4KDAuMDAxLCBmaW5hbFNjb3JlKVxuICB9O1xuXG4gIGlmIChjb21wdXRlTWF0Y2hlcykge1xuICAgIGNvbnN0IGluZGljZXMgPSBjb252ZXJ0TWFza1RvSW5kaWNlcyhtYXRjaE1hc2ssIG1pbk1hdGNoQ2hhckxlbmd0aCk7XG4gICAgaWYgKCFpbmRpY2VzLmxlbmd0aCkge1xuICAgICAgcmVzdWx0LmlzTWF0Y2ggPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGluY2x1ZGVNYXRjaGVzKSB7XG4gICAgICByZXN1bHQuaW5kaWNlcyA9IGluZGljZXM7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5mdW5jdGlvbiBjcmVhdGVQYXR0ZXJuQWxwaGFiZXQocGF0dGVybikge1xuICBsZXQgbWFzayA9IHt9O1xuXG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSBwYXR0ZXJuLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgY29uc3QgY2hhciA9IHBhdHRlcm4uY2hhckF0KGkpO1xuICAgIG1hc2tbY2hhcl0gPSAobWFza1tjaGFyXSB8fCAwKSB8ICgxIDw8IChsZW4gLSBpIC0gMSkpO1xuICB9XG5cbiAgcmV0dXJuIG1hc2tcbn1cblxuY2xhc3MgQml0YXBTZWFyY2gge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwYXR0ZXJuLFxuICAgIHtcbiAgICAgIGxvY2F0aW9uID0gQ29uZmlnLmxvY2F0aW9uLFxuICAgICAgdGhyZXNob2xkID0gQ29uZmlnLnRocmVzaG9sZCxcbiAgICAgIGRpc3RhbmNlID0gQ29uZmlnLmRpc3RhbmNlLFxuICAgICAgaW5jbHVkZU1hdGNoZXMgPSBDb25maWcuaW5jbHVkZU1hdGNoZXMsXG4gICAgICBmaW5kQWxsTWF0Y2hlcyA9IENvbmZpZy5maW5kQWxsTWF0Y2hlcyxcbiAgICAgIG1pbk1hdGNoQ2hhckxlbmd0aCA9IENvbmZpZy5taW5NYXRjaENoYXJMZW5ndGgsXG4gICAgICBpc0Nhc2VTZW5zaXRpdmUgPSBDb25maWcuaXNDYXNlU2Vuc2l0aXZlLFxuICAgICAgaWdub3JlTG9jYXRpb24gPSBDb25maWcuaWdub3JlTG9jYXRpb25cbiAgICB9ID0ge31cbiAgKSB7XG4gICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgbG9jYXRpb24sXG4gICAgICB0aHJlc2hvbGQsXG4gICAgICBkaXN0YW5jZSxcbiAgICAgIGluY2x1ZGVNYXRjaGVzLFxuICAgICAgZmluZEFsbE1hdGNoZXMsXG4gICAgICBtaW5NYXRjaENoYXJMZW5ndGgsXG4gICAgICBpc0Nhc2VTZW5zaXRpdmUsXG4gICAgICBpZ25vcmVMb2NhdGlvblxuICAgIH07XG5cbiAgICB0aGlzLnBhdHRlcm4gPSBpc0Nhc2VTZW5zaXRpdmUgPyBwYXR0ZXJuIDogcGF0dGVybi50b0xvd2VyQ2FzZSgpO1xuXG4gICAgdGhpcy5jaHVua3MgPSBbXTtcblxuICAgIGlmICghdGhpcy5wYXR0ZXJuLmxlbmd0aCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgYWRkQ2h1bmsgPSAocGF0dGVybiwgc3RhcnRJbmRleCkgPT4ge1xuICAgICAgdGhpcy5jaHVua3MucHVzaCh7XG4gICAgICAgIHBhdHRlcm4sXG4gICAgICAgIGFscGhhYmV0OiBjcmVhdGVQYXR0ZXJuQWxwaGFiZXQocGF0dGVybiksXG4gICAgICAgIHN0YXJ0SW5kZXhcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBjb25zdCBsZW4gPSB0aGlzLnBhdHRlcm4ubGVuZ3RoO1xuXG4gICAgaWYgKGxlbiA+IE1BWF9CSVRTKSB7XG4gICAgICBsZXQgaSA9IDA7XG4gICAgICBjb25zdCByZW1haW5kZXIgPSBsZW4gJSBNQVhfQklUUztcbiAgICAgIGNvbnN0IGVuZCA9IGxlbiAtIHJlbWFpbmRlcjtcblxuICAgICAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICAgICAgYWRkQ2h1bmsodGhpcy5wYXR0ZXJuLnN1YnN0cihpLCBNQVhfQklUUyksIGkpO1xuICAgICAgICBpICs9IE1BWF9CSVRTO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVtYWluZGVyKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0SW5kZXggPSBsZW4gLSBNQVhfQklUUztcbiAgICAgICAgYWRkQ2h1bmsodGhpcy5wYXR0ZXJuLnN1YnN0cihzdGFydEluZGV4KSwgc3RhcnRJbmRleCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGFkZENodW5rKHRoaXMucGF0dGVybiwgMCk7XG4gICAgfVxuICB9XG5cbiAgc2VhcmNoSW4odGV4dCkge1xuICAgIGNvbnN0IHsgaXNDYXNlU2Vuc2l0aXZlLCBpbmNsdWRlTWF0Y2hlcyB9ID0gdGhpcy5vcHRpb25zO1xuXG4gICAgaWYgKCFpc0Nhc2VTZW5zaXRpdmUpIHtcbiAgICAgIHRleHQgPSB0ZXh0LnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgLy8gRXhhY3QgbWF0Y2hcbiAgICBpZiAodGhpcy5wYXR0ZXJuID09PSB0ZXh0KSB7XG4gICAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgICBpc01hdGNoOiB0cnVlLFxuICAgICAgICBzY29yZTogMFxuICAgICAgfTtcblxuICAgICAgaWYgKGluY2x1ZGVNYXRjaGVzKSB7XG4gICAgICAgIHJlc3VsdC5pbmRpY2VzID0gW1swLCB0ZXh0Lmxlbmd0aCAtIDFdXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH1cblxuICAgIC8vIE90aGVyd2lzZSwgdXNlIEJpdGFwIGFsZ29yaXRobVxuICAgIGNvbnN0IHtcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgZGlzdGFuY2UsXG4gICAgICB0aHJlc2hvbGQsXG4gICAgICBmaW5kQWxsTWF0Y2hlcyxcbiAgICAgIG1pbk1hdGNoQ2hhckxlbmd0aCxcbiAgICAgIGlnbm9yZUxvY2F0aW9uXG4gICAgfSA9IHRoaXMub3B0aW9ucztcblxuICAgIGxldCBhbGxJbmRpY2VzID0gW107XG4gICAgbGV0IHRvdGFsU2NvcmUgPSAwO1xuICAgIGxldCBoYXNNYXRjaGVzID0gZmFsc2U7XG5cbiAgICB0aGlzLmNodW5rcy5mb3JFYWNoKCh7IHBhdHRlcm4sIGFscGhhYmV0LCBzdGFydEluZGV4IH0pID0+IHtcbiAgICAgIGNvbnN0IHsgaXNNYXRjaCwgc2NvcmUsIGluZGljZXMgfSA9IHNlYXJjaCh0ZXh0LCBwYXR0ZXJuLCBhbHBoYWJldCwge1xuICAgICAgICBsb2NhdGlvbjogbG9jYXRpb24gKyBzdGFydEluZGV4LFxuICAgICAgICBkaXN0YW5jZSxcbiAgICAgICAgdGhyZXNob2xkLFxuICAgICAgICBmaW5kQWxsTWF0Y2hlcyxcbiAgICAgICAgbWluTWF0Y2hDaGFyTGVuZ3RoLFxuICAgICAgICBpbmNsdWRlTWF0Y2hlcyxcbiAgICAgICAgaWdub3JlTG9jYXRpb25cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoaXNNYXRjaCkge1xuICAgICAgICBoYXNNYXRjaGVzID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdG90YWxTY29yZSArPSBzY29yZTtcblxuICAgICAgaWYgKGlzTWF0Y2ggJiYgaW5kaWNlcykge1xuICAgICAgICBhbGxJbmRpY2VzID0gWy4uLmFsbEluZGljZXMsIC4uLmluZGljZXNdO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgIGlzTWF0Y2g6IGhhc01hdGNoZXMsXG4gICAgICBzY29yZTogaGFzTWF0Y2hlcyA/IHRvdGFsU2NvcmUgLyB0aGlzLmNodW5rcy5sZW5ndGggOiAxXG4gICAgfTtcblxuICAgIGlmIChoYXNNYXRjaGVzICYmIGluY2x1ZGVNYXRjaGVzKSB7XG4gICAgICByZXN1bHQuaW5kaWNlcyA9IGFsbEluZGljZXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG59XG5cbmNsYXNzIEJhc2VNYXRjaCB7XG4gIGNvbnN0cnVjdG9yKHBhdHRlcm4pIHtcbiAgICB0aGlzLnBhdHRlcm4gPSBwYXR0ZXJuO1xuICB9XG4gIHN0YXRpYyBpc011bHRpTWF0Y2gocGF0dGVybikge1xuICAgIHJldHVybiBnZXRNYXRjaChwYXR0ZXJuLCB0aGlzLm11bHRpUmVnZXgpXG4gIH1cbiAgc3RhdGljIGlzU2luZ2xlTWF0Y2gocGF0dGVybikge1xuICAgIHJldHVybiBnZXRNYXRjaChwYXR0ZXJuLCB0aGlzLnNpbmdsZVJlZ2V4KVxuICB9XG4gIHNlYXJjaCgvKnRleHQqLykge31cbn1cblxuZnVuY3Rpb24gZ2V0TWF0Y2gocGF0dGVybiwgZXhwKSB7XG4gIGNvbnN0IG1hdGNoZXMgPSBwYXR0ZXJuLm1hdGNoKGV4cCk7XG4gIHJldHVybiBtYXRjaGVzID8gbWF0Y2hlc1sxXSA6IG51bGxcbn1cblxuLy8gVG9rZW46ICdmaWxlXG5cbmNsYXNzIEV4YWN0TWF0Y2ggZXh0ZW5kcyBCYXNlTWF0Y2gge1xuICBjb25zdHJ1Y3RvcihwYXR0ZXJuKSB7XG4gICAgc3VwZXIocGF0dGVybik7XG4gIH1cbiAgc3RhdGljIGdldCB0eXBlKCkge1xuICAgIHJldHVybiAnZXhhY3QnXG4gIH1cbiAgc3RhdGljIGdldCBtdWx0aVJlZ2V4KCkge1xuICAgIHJldHVybiAvXj1cIiguKilcIiQvXG4gIH1cbiAgc3RhdGljIGdldCBzaW5nbGVSZWdleCgpIHtcbiAgICByZXR1cm4gL149KC4qKSQvXG4gIH1cbiAgc2VhcmNoKHRleHQpIHtcbiAgICBjb25zdCBpc01hdGNoID0gdGV4dCA9PT0gdGhpcy5wYXR0ZXJuO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGlzTWF0Y2gsXG4gICAgICBzY29yZTogaXNNYXRjaCA/IDAgOiAxLFxuICAgICAgaW5kaWNlczogWzAsIHRoaXMucGF0dGVybi5sZW5ndGggLSAxXVxuICAgIH1cbiAgfVxufVxuXG4vLyBUb2tlbjogIWZpcmVcblxuY2xhc3MgSW52ZXJzZUV4YWN0TWF0Y2ggZXh0ZW5kcyBCYXNlTWF0Y2gge1xuICBjb25zdHJ1Y3RvcihwYXR0ZXJuKSB7XG4gICAgc3VwZXIocGF0dGVybik7XG4gIH1cbiAgc3RhdGljIGdldCB0eXBlKCkge1xuICAgIHJldHVybiAnaW52ZXJzZS1leGFjdCdcbiAgfVxuICBzdGF0aWMgZ2V0IG11bHRpUmVnZXgoKSB7XG4gICAgcmV0dXJuIC9eIVwiKC4qKVwiJC9cbiAgfVxuICBzdGF0aWMgZ2V0IHNpbmdsZVJlZ2V4KCkge1xuICAgIHJldHVybiAvXiEoLiopJC9cbiAgfVxuICBzZWFyY2godGV4dCkge1xuICAgIGNvbnN0IGluZGV4ID0gdGV4dC5pbmRleE9mKHRoaXMucGF0dGVybik7XG4gICAgY29uc3QgaXNNYXRjaCA9IGluZGV4ID09PSAtMTtcblxuICAgIHJldHVybiB7XG4gICAgICBpc01hdGNoLFxuICAgICAgc2NvcmU6IGlzTWF0Y2ggPyAwIDogMSxcbiAgICAgIGluZGljZXM6IFswLCB0ZXh0Lmxlbmd0aCAtIDFdXG4gICAgfVxuICB9XG59XG5cbi8vIFRva2VuOiBeZmlsZVxuXG5jbGFzcyBQcmVmaXhFeGFjdE1hdGNoIGV4dGVuZHMgQmFzZU1hdGNoIHtcbiAgY29uc3RydWN0b3IocGF0dGVybikge1xuICAgIHN1cGVyKHBhdHRlcm4pO1xuICB9XG4gIHN0YXRpYyBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gJ3ByZWZpeC1leGFjdCdcbiAgfVxuICBzdGF0aWMgZ2V0IG11bHRpUmVnZXgoKSB7XG4gICAgcmV0dXJuIC9eXFxeXCIoLiopXCIkL1xuICB9XG4gIHN0YXRpYyBnZXQgc2luZ2xlUmVnZXgoKSB7XG4gICAgcmV0dXJuIC9eXFxeKC4qKSQvXG4gIH1cbiAgc2VhcmNoKHRleHQpIHtcbiAgICBjb25zdCBpc01hdGNoID0gdGV4dC5zdGFydHNXaXRoKHRoaXMucGF0dGVybik7XG5cbiAgICByZXR1cm4ge1xuICAgICAgaXNNYXRjaCxcbiAgICAgIHNjb3JlOiBpc01hdGNoID8gMCA6IDEsXG4gICAgICBpbmRpY2VzOiBbMCwgdGhpcy5wYXR0ZXJuLmxlbmd0aCAtIDFdXG4gICAgfVxuICB9XG59XG5cbi8vIFRva2VuOiAhXmZpcmVcblxuY2xhc3MgSW52ZXJzZVByZWZpeEV4YWN0TWF0Y2ggZXh0ZW5kcyBCYXNlTWF0Y2gge1xuICBjb25zdHJ1Y3RvcihwYXR0ZXJuKSB7XG4gICAgc3VwZXIocGF0dGVybik7XG4gIH1cbiAgc3RhdGljIGdldCB0eXBlKCkge1xuICAgIHJldHVybiAnaW52ZXJzZS1wcmVmaXgtZXhhY3QnXG4gIH1cbiAgc3RhdGljIGdldCBtdWx0aVJlZ2V4KCkge1xuICAgIHJldHVybiAvXiFcXF5cIiguKilcIiQvXG4gIH1cbiAgc3RhdGljIGdldCBzaW5nbGVSZWdleCgpIHtcbiAgICByZXR1cm4gL14hXFxeKC4qKSQvXG4gIH1cbiAgc2VhcmNoKHRleHQpIHtcbiAgICBjb25zdCBpc01hdGNoID0gIXRleHQuc3RhcnRzV2l0aCh0aGlzLnBhdHRlcm4pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGlzTWF0Y2gsXG4gICAgICBzY29yZTogaXNNYXRjaCA/IDAgOiAxLFxuICAgICAgaW5kaWNlczogWzAsIHRleHQubGVuZ3RoIC0gMV1cbiAgICB9XG4gIH1cbn1cblxuLy8gVG9rZW46IC5maWxlJFxuXG5jbGFzcyBTdWZmaXhFeGFjdE1hdGNoIGV4dGVuZHMgQmFzZU1hdGNoIHtcbiAgY29uc3RydWN0b3IocGF0dGVybikge1xuICAgIHN1cGVyKHBhdHRlcm4pO1xuICB9XG4gIHN0YXRpYyBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gJ3N1ZmZpeC1leGFjdCdcbiAgfVxuICBzdGF0aWMgZ2V0IG11bHRpUmVnZXgoKSB7XG4gICAgcmV0dXJuIC9eXCIoLiopXCJcXCQkL1xuICB9XG4gIHN0YXRpYyBnZXQgc2luZ2xlUmVnZXgoKSB7XG4gICAgcmV0dXJuIC9eKC4qKVxcJCQvXG4gIH1cbiAgc2VhcmNoKHRleHQpIHtcbiAgICBjb25zdCBpc01hdGNoID0gdGV4dC5lbmRzV2l0aCh0aGlzLnBhdHRlcm4pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGlzTWF0Y2gsXG4gICAgICBzY29yZTogaXNNYXRjaCA/IDAgOiAxLFxuICAgICAgaW5kaWNlczogW3RleHQubGVuZ3RoIC0gdGhpcy5wYXR0ZXJuLmxlbmd0aCwgdGV4dC5sZW5ndGggLSAxXVxuICAgIH1cbiAgfVxufVxuXG4vLyBUb2tlbjogIS5maWxlJFxuXG5jbGFzcyBJbnZlcnNlU3VmZml4RXhhY3RNYXRjaCBleHRlbmRzIEJhc2VNYXRjaCB7XG4gIGNvbnN0cnVjdG9yKHBhdHRlcm4pIHtcbiAgICBzdXBlcihwYXR0ZXJuKTtcbiAgfVxuICBzdGF0aWMgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuICdpbnZlcnNlLXN1ZmZpeC1leGFjdCdcbiAgfVxuICBzdGF0aWMgZ2V0IG11bHRpUmVnZXgoKSB7XG4gICAgcmV0dXJuIC9eIVwiKC4qKVwiXFwkJC9cbiAgfVxuICBzdGF0aWMgZ2V0IHNpbmdsZVJlZ2V4KCkge1xuICAgIHJldHVybiAvXiEoLiopXFwkJC9cbiAgfVxuICBzZWFyY2godGV4dCkge1xuICAgIGNvbnN0IGlzTWF0Y2ggPSAhdGV4dC5lbmRzV2l0aCh0aGlzLnBhdHRlcm4pO1xuICAgIHJldHVybiB7XG4gICAgICBpc01hdGNoLFxuICAgICAgc2NvcmU6IGlzTWF0Y2ggPyAwIDogMSxcbiAgICAgIGluZGljZXM6IFswLCB0ZXh0Lmxlbmd0aCAtIDFdXG4gICAgfVxuICB9XG59XG5cbmNsYXNzIEZ1enp5TWF0Y2ggZXh0ZW5kcyBCYXNlTWF0Y2gge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwYXR0ZXJuLFxuICAgIHtcbiAgICAgIGxvY2F0aW9uID0gQ29uZmlnLmxvY2F0aW9uLFxuICAgICAgdGhyZXNob2xkID0gQ29uZmlnLnRocmVzaG9sZCxcbiAgICAgIGRpc3RhbmNlID0gQ29uZmlnLmRpc3RhbmNlLFxuICAgICAgaW5jbHVkZU1hdGNoZXMgPSBDb25maWcuaW5jbHVkZU1hdGNoZXMsXG4gICAgICBmaW5kQWxsTWF0Y2hlcyA9IENvbmZpZy5maW5kQWxsTWF0Y2hlcyxcbiAgICAgIG1pbk1hdGNoQ2hhckxlbmd0aCA9IENvbmZpZy5taW5NYXRjaENoYXJMZW5ndGgsXG4gICAgICBpc0Nhc2VTZW5zaXRpdmUgPSBDb25maWcuaXNDYXNlU2Vuc2l0aXZlLFxuICAgICAgaWdub3JlTG9jYXRpb24gPSBDb25maWcuaWdub3JlTG9jYXRpb25cbiAgICB9ID0ge31cbiAgKSB7XG4gICAgc3VwZXIocGF0dGVybik7XG4gICAgdGhpcy5fYml0YXBTZWFyY2ggPSBuZXcgQml0YXBTZWFyY2gocGF0dGVybiwge1xuICAgICAgbG9jYXRpb24sXG4gICAgICB0aHJlc2hvbGQsXG4gICAgICBkaXN0YW5jZSxcbiAgICAgIGluY2x1ZGVNYXRjaGVzLFxuICAgICAgZmluZEFsbE1hdGNoZXMsXG4gICAgICBtaW5NYXRjaENoYXJMZW5ndGgsXG4gICAgICBpc0Nhc2VTZW5zaXRpdmUsXG4gICAgICBpZ25vcmVMb2NhdGlvblxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gJ2Z1enp5J1xuICB9XG4gIHN0YXRpYyBnZXQgbXVsdGlSZWdleCgpIHtcbiAgICByZXR1cm4gL15cIiguKilcIiQvXG4gIH1cbiAgc3RhdGljIGdldCBzaW5nbGVSZWdleCgpIHtcbiAgICByZXR1cm4gL14oLiopJC9cbiAgfVxuICBzZWFyY2godGV4dCkge1xuICAgIHJldHVybiB0aGlzLl9iaXRhcFNlYXJjaC5zZWFyY2hJbih0ZXh0KVxuICB9XG59XG5cbi8vIFRva2VuOiAnZmlsZVxuXG5jbGFzcyBJbmNsdWRlTWF0Y2ggZXh0ZW5kcyBCYXNlTWF0Y2gge1xuICBjb25zdHJ1Y3RvcihwYXR0ZXJuKSB7XG4gICAgc3VwZXIocGF0dGVybik7XG4gIH1cbiAgc3RhdGljIGdldCB0eXBlKCkge1xuICAgIHJldHVybiAnaW5jbHVkZSdcbiAgfVxuICBzdGF0aWMgZ2V0IG11bHRpUmVnZXgoKSB7XG4gICAgcmV0dXJuIC9eJ1wiKC4qKVwiJC9cbiAgfVxuICBzdGF0aWMgZ2V0IHNpbmdsZVJlZ2V4KCkge1xuICAgIHJldHVybiAvXicoLiopJC9cbiAgfVxuICBzZWFyY2godGV4dCkge1xuICAgIGxldCBsb2NhdGlvbiA9IDA7XG4gICAgbGV0IGluZGV4O1xuXG4gICAgY29uc3QgaW5kaWNlcyA9IFtdO1xuICAgIGNvbnN0IHBhdHRlcm5MZW4gPSB0aGlzLnBhdHRlcm4ubGVuZ3RoO1xuXG4gICAgLy8gR2V0IGFsbCBleGFjdCBtYXRjaGVzXG4gICAgd2hpbGUgKChpbmRleCA9IHRleHQuaW5kZXhPZih0aGlzLnBhdHRlcm4sIGxvY2F0aW9uKSkgPiAtMSkge1xuICAgICAgbG9jYXRpb24gPSBpbmRleCArIHBhdHRlcm5MZW47XG4gICAgICBpbmRpY2VzLnB1c2goW2luZGV4LCBsb2NhdGlvbiAtIDFdKTtcbiAgICB9XG5cbiAgICBjb25zdCBpc01hdGNoID0gISFpbmRpY2VzLmxlbmd0aDtcblxuICAgIHJldHVybiB7XG4gICAgICBpc01hdGNoLFxuICAgICAgc2NvcmU6IGlzTWF0Y2ggPyAwIDogMSxcbiAgICAgIGluZGljZXNcbiAgICB9XG4gIH1cbn1cblxuLy8g4p2XT3JkZXIgaXMgaW1wb3J0YW50LiBETyBOT1QgQ0hBTkdFLlxuY29uc3Qgc2VhcmNoZXJzID0gW1xuICBFeGFjdE1hdGNoLFxuICBJbmNsdWRlTWF0Y2gsXG4gIFByZWZpeEV4YWN0TWF0Y2gsXG4gIEludmVyc2VQcmVmaXhFeGFjdE1hdGNoLFxuICBJbnZlcnNlU3VmZml4RXhhY3RNYXRjaCxcbiAgU3VmZml4RXhhY3RNYXRjaCxcbiAgSW52ZXJzZUV4YWN0TWF0Y2gsXG4gIEZ1enp5TWF0Y2hcbl07XG5cbmNvbnN0IHNlYXJjaGVyc0xlbiA9IHNlYXJjaGVycy5sZW5ndGg7XG5cbi8vIFJlZ2V4IHRvIHNwbGl0IGJ5IHNwYWNlcywgYnV0IGtlZXAgYW55dGhpbmcgaW4gcXVvdGVzIHRvZ2V0aGVyXG5jb25zdCBTUEFDRV9SRSA9IC8gKyg/PSg/OlteXFxcIl0qXFxcIlteXFxcIl0qXFxcIikqW15cXFwiXSokKS87XG5jb25zdCBPUl9UT0tFTiA9ICd8JztcblxuLy8gUmV0dXJuIGEgMkQgYXJyYXkgcmVwcmVzZW50YXRpb24gb2YgdGhlIHF1ZXJ5LCBmb3Igc2ltcGxlciBwYXJzaW5nLlxuLy8gRXhhbXBsZTpcbi8vIFwiXmNvcmUgZ28kIHwgcmIkIHwgcHkkIHh5JFwiID0+IFtbXCJeY29yZVwiLCBcImdvJFwiXSwgW1wicmIkXCJdLCBbXCJweSRcIiwgXCJ4eSRcIl1dXG5mdW5jdGlvbiBwYXJzZVF1ZXJ5KHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkge1xuICByZXR1cm4gcGF0dGVybi5zcGxpdChPUl9UT0tFTikubWFwKChpdGVtKSA9PiB7XG4gICAgbGV0IHF1ZXJ5ID0gaXRlbVxuICAgICAgLnRyaW0oKVxuICAgICAgLnNwbGl0KFNQQUNFX1JFKVxuICAgICAgLmZpbHRlcigoaXRlbSkgPT4gaXRlbSAmJiAhIWl0ZW0udHJpbSgpKTtcblxuICAgIGxldCByZXN1bHRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHF1ZXJ5Lmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBjb25zdCBxdWVyeUl0ZW0gPSBxdWVyeVtpXTtcblxuICAgICAgLy8gMS4gSGFuZGxlIG11bHRpcGxlIHF1ZXJ5IG1hdGNoIChpLmUsIG9uY2UgdGhhdCBhcmUgcXVvdGVkLCBsaWtlIGBcImhlbGxvIHdvcmxkXCJgKVxuICAgICAgbGV0IGZvdW5kID0gZmFsc2U7XG4gICAgICBsZXQgaWR4ID0gLTE7XG4gICAgICB3aGlsZSAoIWZvdW5kICYmICsraWR4IDwgc2VhcmNoZXJzTGVuKSB7XG4gICAgICAgIGNvbnN0IHNlYXJjaGVyID0gc2VhcmNoZXJzW2lkeF07XG4gICAgICAgIGxldCB0b2tlbiA9IHNlYXJjaGVyLmlzTXVsdGlNYXRjaChxdWVyeUl0ZW0pO1xuICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICByZXN1bHRzLnB1c2gobmV3IHNlYXJjaGVyKHRva2VuLCBvcHRpb25zKSk7XG4gICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmb3VuZCkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyLiBIYW5kbGUgc2luZ2xlIHF1ZXJ5IG1hdGNoZXMgKGkuZSwgb25jZSB0aGF0IGFyZSAqbm90KiBxdW90ZWQpXG4gICAgICBpZHggPSAtMTtcbiAgICAgIHdoaWxlICgrK2lkeCA8IHNlYXJjaGVyc0xlbikge1xuICAgICAgICBjb25zdCBzZWFyY2hlciA9IHNlYXJjaGVyc1tpZHhdO1xuICAgICAgICBsZXQgdG9rZW4gPSBzZWFyY2hlci5pc1NpbmdsZU1hdGNoKHF1ZXJ5SXRlbSk7XG4gICAgICAgIGlmICh0b2tlbikge1xuICAgICAgICAgIHJlc3VsdHMucHVzaChuZXcgc2VhcmNoZXIodG9rZW4sIG9wdGlvbnMpKTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdHNcbiAgfSlcbn1cblxuLy8gVGhlc2UgZXh0ZW5kZWQgbWF0Y2hlcnMgY2FuIHJldHVybiBhbiBhcnJheSBvZiBtYXRjaGVzLCBhcyBvcHBvc2VkXG4vLyB0byBhIHNpbmdsIG1hdGNoXG5jb25zdCBNdWx0aU1hdGNoU2V0ID0gbmV3IFNldChbRnV6enlNYXRjaC50eXBlLCBJbmNsdWRlTWF0Y2gudHlwZV0pO1xuXG4vKipcbiAqIENvbW1hbmQtbGlrZSBzZWFyY2hpbmdcbiAqID09PT09PT09PT09PT09PT09PT09PT1cbiAqXG4gKiBHaXZlbiBtdWx0aXBsZSBzZWFyY2ggdGVybXMgZGVsaW1pdGVkIGJ5IHNwYWNlcy5lLmcuIGBeanNjcmlwdCAucHl0aG9uJCBydWJ5ICFqYXZhYCxcbiAqIHNlYXJjaCBpbiBhIGdpdmVuIHRleHQuXG4gKlxuICogU2VhcmNoIHN5bnRheDpcbiAqXG4gKiB8IFRva2VuICAgICAgIHwgTWF0Y2ggdHlwZSAgICAgICAgICAgICAgICAgfCBEZXNjcmlwdGlvbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8IC0tLS0tLS0tLS0tIHwgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gfCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSB8XG4gKiB8IGBqc2NyaXB0YCAgIHwgZnV6enktbWF0Y2ggICAgICAgICAgICAgICAgfCBJdGVtcyB0aGF0IGZ1enp5IG1hdGNoIGBqc2NyaXB0YCAgICAgICB8XG4gKiB8IGA9c2NoZW1lYCAgIHwgZXhhY3QtbWF0Y2ggICAgICAgICAgICAgICAgfCBJdGVtcyB0aGF0IGFyZSBgc2NoZW1lYCAgICAgICAgICAgICAgICB8XG4gKiB8IGAncHl0aG9uYCAgIHwgaW5jbHVkZS1tYXRjaCAgICAgICAgICAgICAgfCBJdGVtcyB0aGF0IGluY2x1ZGUgYHB5dGhvbmAgICAgICAgICAgICB8XG4gKiB8IGAhcnVieWAgICAgIHwgaW52ZXJzZS1leGFjdC1tYXRjaCAgICAgICAgfCBJdGVtcyB0aGF0IGRvIG5vdCBpbmNsdWRlIGBydWJ5YCAgICAgICB8XG4gKiB8IGBeamF2YWAgICAgIHwgcHJlZml4LWV4YWN0LW1hdGNoICAgICAgICAgfCBJdGVtcyB0aGF0IHN0YXJ0IHdpdGggYGphdmFgICAgICAgICAgICB8XG4gKiB8IGAhXmVhcmxhbmdgIHwgaW52ZXJzZS1wcmVmaXgtZXhhY3QtbWF0Y2ggfCBJdGVtcyB0aGF0IGRvIG5vdCBzdGFydCB3aXRoIGBlYXJsYW5nYCB8XG4gKiB8IGAuanMkYCAgICAgIHwgc3VmZml4LWV4YWN0LW1hdGNoICAgICAgICAgfCBJdGVtcyB0aGF0IGVuZCB3aXRoIGAuanNgICAgICAgICAgICAgICB8XG4gKiB8IGAhLmdvJGAgICAgIHwgaW52ZXJzZS1zdWZmaXgtZXhhY3QtbWF0Y2ggfCBJdGVtcyB0aGF0IGRvIG5vdCBlbmQgd2l0aCBgLmdvYCAgICAgICB8XG4gKlxuICogQSBzaW5nbGUgcGlwZSBjaGFyYWN0ZXIgYWN0cyBhcyBhbiBPUiBvcGVyYXRvci4gRm9yIGV4YW1wbGUsIHRoZSBmb2xsb3dpbmdcbiAqIHF1ZXJ5IG1hdGNoZXMgZW50cmllcyB0aGF0IHN0YXJ0IHdpdGggYGNvcmVgIGFuZCBlbmQgd2l0aCBlaXRoZXJgZ29gLCBgcmJgLFxuICogb3JgcHlgLlxuICpcbiAqIGBgYFxuICogXmNvcmUgZ28kIHwgcmIkIHwgcHkkXG4gKiBgYGBcbiAqL1xuY2xhc3MgRXh0ZW5kZWRTZWFyY2gge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwYXR0ZXJuLFxuICAgIHtcbiAgICAgIGlzQ2FzZVNlbnNpdGl2ZSA9IENvbmZpZy5pc0Nhc2VTZW5zaXRpdmUsXG4gICAgICBpbmNsdWRlTWF0Y2hlcyA9IENvbmZpZy5pbmNsdWRlTWF0Y2hlcyxcbiAgICAgIG1pbk1hdGNoQ2hhckxlbmd0aCA9IENvbmZpZy5taW5NYXRjaENoYXJMZW5ndGgsXG4gICAgICBpZ25vcmVMb2NhdGlvbiA9IENvbmZpZy5pZ25vcmVMb2NhdGlvbixcbiAgICAgIGZpbmRBbGxNYXRjaGVzID0gQ29uZmlnLmZpbmRBbGxNYXRjaGVzLFxuICAgICAgbG9jYXRpb24gPSBDb25maWcubG9jYXRpb24sXG4gICAgICB0aHJlc2hvbGQgPSBDb25maWcudGhyZXNob2xkLFxuICAgICAgZGlzdGFuY2UgPSBDb25maWcuZGlzdGFuY2VcbiAgICB9ID0ge31cbiAgKSB7XG4gICAgdGhpcy5xdWVyeSA9IG51bGw7XG4gICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgaXNDYXNlU2Vuc2l0aXZlLFxuICAgICAgaW5jbHVkZU1hdGNoZXMsXG4gICAgICBtaW5NYXRjaENoYXJMZW5ndGgsXG4gICAgICBmaW5kQWxsTWF0Y2hlcyxcbiAgICAgIGlnbm9yZUxvY2F0aW9uLFxuICAgICAgbG9jYXRpb24sXG4gICAgICB0aHJlc2hvbGQsXG4gICAgICBkaXN0YW5jZVxuICAgIH07XG5cbiAgICB0aGlzLnBhdHRlcm4gPSBpc0Nhc2VTZW5zaXRpdmUgPyBwYXR0ZXJuIDogcGF0dGVybi50b0xvd2VyQ2FzZSgpO1xuICAgIHRoaXMucXVlcnkgPSBwYXJzZVF1ZXJ5KHRoaXMucGF0dGVybiwgdGhpcy5vcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBjb25kaXRpb24oXywgb3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zLnVzZUV4dGVuZGVkU2VhcmNoXG4gIH1cblxuICBzZWFyY2hJbih0ZXh0KSB7XG4gICAgY29uc3QgcXVlcnkgPSB0aGlzLnF1ZXJ5O1xuXG4gICAgaWYgKCFxdWVyeSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXNNYXRjaDogZmFsc2UsXG4gICAgICAgIHNjb3JlOiAxXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgeyBpbmNsdWRlTWF0Y2hlcywgaXNDYXNlU2Vuc2l0aXZlIH0gPSB0aGlzLm9wdGlvbnM7XG5cbiAgICB0ZXh0ID0gaXNDYXNlU2Vuc2l0aXZlID8gdGV4dCA6IHRleHQudG9Mb3dlckNhc2UoKTtcblxuICAgIGxldCBudW1NYXRjaGVzID0gMDtcbiAgICBsZXQgYWxsSW5kaWNlcyA9IFtdO1xuICAgIGxldCB0b3RhbFNjb3JlID0gMDtcblxuICAgIC8vIE9Sc1xuICAgIGZvciAobGV0IGkgPSAwLCBxTGVuID0gcXVlcnkubGVuZ3RoOyBpIDwgcUxlbjsgaSArPSAxKSB7XG4gICAgICBjb25zdCBzZWFyY2hlcnMgPSBxdWVyeVtpXTtcblxuICAgICAgLy8gUmVzZXQgaW5kaWNlc1xuICAgICAgYWxsSW5kaWNlcy5sZW5ndGggPSAwO1xuICAgICAgbnVtTWF0Y2hlcyA9IDA7XG5cbiAgICAgIC8vIEFORHNcbiAgICAgIGZvciAobGV0IGogPSAwLCBwTGVuID0gc2VhcmNoZXJzLmxlbmd0aDsgaiA8IHBMZW47IGogKz0gMSkge1xuICAgICAgICBjb25zdCBzZWFyY2hlciA9IHNlYXJjaGVyc1tqXTtcbiAgICAgICAgY29uc3QgeyBpc01hdGNoLCBpbmRpY2VzLCBzY29yZSB9ID0gc2VhcmNoZXIuc2VhcmNoKHRleHQpO1xuXG4gICAgICAgIGlmIChpc01hdGNoKSB7XG4gICAgICAgICAgbnVtTWF0Y2hlcyArPSAxO1xuICAgICAgICAgIHRvdGFsU2NvcmUgKz0gc2NvcmU7XG4gICAgICAgICAgaWYgKGluY2x1ZGVNYXRjaGVzKSB7XG4gICAgICAgICAgICBjb25zdCB0eXBlID0gc2VhcmNoZXIuY29uc3RydWN0b3IudHlwZTtcbiAgICAgICAgICAgIGlmIChNdWx0aU1hdGNoU2V0Lmhhcyh0eXBlKSkge1xuICAgICAgICAgICAgICBhbGxJbmRpY2VzID0gWy4uLmFsbEluZGljZXMsIC4uLmluZGljZXNdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYWxsSW5kaWNlcy5wdXNoKGluZGljZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0b3RhbFNjb3JlID0gMDtcbiAgICAgICAgICBudW1NYXRjaGVzID0gMDtcbiAgICAgICAgICBhbGxJbmRpY2VzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBPUiBjb25kaXRpb24sIHNvIGlmIFRSVUUsIHJldHVyblxuICAgICAgaWYgKG51bU1hdGNoZXMpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgICAgICBpc01hdGNoOiB0cnVlLFxuICAgICAgICAgIHNjb3JlOiB0b3RhbFNjb3JlIC8gbnVtTWF0Y2hlc1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChpbmNsdWRlTWF0Y2hlcykge1xuICAgICAgICAgIHJlc3VsdC5pbmRpY2VzID0gYWxsSW5kaWNlcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBOb3RoaW5nIHdhcyBtYXRjaGVkXG4gICAgcmV0dXJuIHtcbiAgICAgIGlzTWF0Y2g6IGZhbHNlLFxuICAgICAgc2NvcmU6IDFcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgcmVnaXN0ZXJlZFNlYXJjaGVycyA9IFtdO1xuXG5mdW5jdGlvbiByZWdpc3RlciguLi5hcmdzKSB7XG4gIHJlZ2lzdGVyZWRTZWFyY2hlcnMucHVzaCguLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlU2VhcmNoZXIocGF0dGVybiwgb3B0aW9ucykge1xuICBmb3IgKGxldCBpID0gMCwgbGVuID0gcmVnaXN0ZXJlZFNlYXJjaGVycy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgIGxldCBzZWFyY2hlckNsYXNzID0gcmVnaXN0ZXJlZFNlYXJjaGVyc1tpXTtcbiAgICBpZiAoc2VhcmNoZXJDbGFzcy5jb25kaXRpb24ocGF0dGVybiwgb3B0aW9ucykpIHtcbiAgICAgIHJldHVybiBuZXcgc2VhcmNoZXJDbGFzcyhwYXR0ZXJuLCBvcHRpb25zKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgQml0YXBTZWFyY2gocGF0dGVybiwgb3B0aW9ucylcbn1cblxuY29uc3QgTG9naWNhbE9wZXJhdG9yID0ge1xuICBBTkQ6ICckYW5kJyxcbiAgT1I6ICckb3InXG59O1xuXG5jb25zdCBLZXlUeXBlID0ge1xuICBQQVRIOiAnJHBhdGgnLFxuICBQQVRURVJOOiAnJHZhbCdcbn07XG5cbmNvbnN0IGlzRXhwcmVzc2lvbiA9IChxdWVyeSkgPT5cbiAgISEocXVlcnlbTG9naWNhbE9wZXJhdG9yLkFORF0gfHwgcXVlcnlbTG9naWNhbE9wZXJhdG9yLk9SXSk7XG5cbmNvbnN0IGlzUGF0aCA9IChxdWVyeSkgPT4gISFxdWVyeVtLZXlUeXBlLlBBVEhdO1xuXG5jb25zdCBpc0xlYWYgPSAocXVlcnkpID0+XG4gICFpc0FycmF5KHF1ZXJ5KSAmJiBpc09iamVjdChxdWVyeSkgJiYgIWlzRXhwcmVzc2lvbihxdWVyeSk7XG5cbmNvbnN0IGNvbnZlcnRUb0V4cGxpY2l0ID0gKHF1ZXJ5KSA9PiAoe1xuICBbTG9naWNhbE9wZXJhdG9yLkFORF06IE9iamVjdC5rZXlzKHF1ZXJ5KS5tYXAoKGtleSkgPT4gKHtcbiAgICBba2V5XTogcXVlcnlba2V5XVxuICB9KSlcbn0pO1xuXG4vLyBXaGVuIGBhdXRvYCBpcyBgdHJ1ZWAsIHRoZSBwYXJzZSBmdW5jdGlvbiB3aWxsIGluZmVyIGFuZCBpbml0aWFsaXplIGFuZCBhZGRcbi8vIHRoZSBhcHByb3ByaWF0ZSBgU2VhcmNoZXJgIGluc3RhbmNlXG5mdW5jdGlvbiBwYXJzZShxdWVyeSwgb3B0aW9ucywgeyBhdXRvID0gdHJ1ZSB9ID0ge30pIHtcbiAgY29uc3QgbmV4dCA9IChxdWVyeSkgPT4ge1xuICAgIGxldCBrZXlzID0gT2JqZWN0LmtleXMocXVlcnkpO1xuXG4gICAgY29uc3QgaXNRdWVyeVBhdGggPSBpc1BhdGgocXVlcnkpO1xuXG4gICAgaWYgKCFpc1F1ZXJ5UGF0aCAmJiBrZXlzLmxlbmd0aCA+IDEgJiYgIWlzRXhwcmVzc2lvbihxdWVyeSkpIHtcbiAgICAgIHJldHVybiBuZXh0KGNvbnZlcnRUb0V4cGxpY2l0KHF1ZXJ5KSlcbiAgICB9XG5cbiAgICBpZiAoaXNMZWFmKHF1ZXJ5KSkge1xuICAgICAgY29uc3Qga2V5ID0gaXNRdWVyeVBhdGggPyBxdWVyeVtLZXlUeXBlLlBBVEhdIDoga2V5c1swXTtcblxuICAgICAgY29uc3QgcGF0dGVybiA9IGlzUXVlcnlQYXRoID8gcXVlcnlbS2V5VHlwZS5QQVRURVJOXSA6IHF1ZXJ5W2tleV07XG5cbiAgICAgIGlmICghaXNTdHJpbmcocGF0dGVybikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKExPR0lDQUxfU0VBUkNIX0lOVkFMSURfUVVFUllfRk9SX0tFWShrZXkpKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBvYmogPSB7XG4gICAgICAgIGtleUlkOiBjcmVhdGVLZXlJZChrZXkpLFxuICAgICAgICBwYXR0ZXJuXG4gICAgICB9O1xuXG4gICAgICBpZiAoYXV0bykge1xuICAgICAgICBvYmouc2VhcmNoZXIgPSBjcmVhdGVTZWFyY2hlcihwYXR0ZXJuLCBvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9ialxuICAgIH1cblxuICAgIGxldCBub2RlID0ge1xuICAgICAgY2hpbGRyZW46IFtdLFxuICAgICAgb3BlcmF0b3I6IGtleXNbMF1cbiAgICB9O1xuXG4gICAga2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlID0gcXVlcnlba2V5XTtcblxuICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgICBub2RlLmNoaWxkcmVuLnB1c2gobmV4dChpdGVtKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIG5vZGVcbiAgfTtcblxuICBpZiAoIWlzRXhwcmVzc2lvbihxdWVyeSkpIHtcbiAgICBxdWVyeSA9IGNvbnZlcnRUb0V4cGxpY2l0KHF1ZXJ5KTtcbiAgfVxuXG4gIHJldHVybiBuZXh0KHF1ZXJ5KVxufVxuXG4vLyBQcmFjdGljYWwgc2NvcmluZyBmdW5jdGlvblxuZnVuY3Rpb24gY29tcHV0ZVNjb3JlKFxuICByZXN1bHRzLFxuICB7IGlnbm9yZUZpZWxkTm9ybSA9IENvbmZpZy5pZ25vcmVGaWVsZE5vcm0gfVxuKSB7XG4gIHJlc3VsdHMuZm9yRWFjaCgocmVzdWx0KSA9PiB7XG4gICAgbGV0IHRvdGFsU2NvcmUgPSAxO1xuXG4gICAgcmVzdWx0Lm1hdGNoZXMuZm9yRWFjaCgoeyBrZXksIG5vcm0sIHNjb3JlIH0pID0+IHtcbiAgICAgIGNvbnN0IHdlaWdodCA9IGtleSA/IGtleS53ZWlnaHQgOiBudWxsO1xuXG4gICAgICB0b3RhbFNjb3JlICo9IE1hdGgucG93KFxuICAgICAgICBzY29yZSA9PT0gMCAmJiB3ZWlnaHQgPyBOdW1iZXIuRVBTSUxPTiA6IHNjb3JlLFxuICAgICAgICAod2VpZ2h0IHx8IDEpICogKGlnbm9yZUZpZWxkTm9ybSA/IDEgOiBub3JtKVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIHJlc3VsdC5zY29yZSA9IHRvdGFsU2NvcmU7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1NYXRjaGVzKHJlc3VsdCwgZGF0YSkge1xuICBjb25zdCBtYXRjaGVzID0gcmVzdWx0Lm1hdGNoZXM7XG4gIGRhdGEubWF0Y2hlcyA9IFtdO1xuXG4gIGlmICghaXNEZWZpbmVkKG1hdGNoZXMpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBtYXRjaGVzLmZvckVhY2goKG1hdGNoKSA9PiB7XG4gICAgaWYgKCFpc0RlZmluZWQobWF0Y2guaW5kaWNlcykgfHwgIW1hdGNoLmluZGljZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCB7IGluZGljZXMsIHZhbHVlIH0gPSBtYXRjaDtcblxuICAgIGxldCBvYmogPSB7XG4gICAgICBpbmRpY2VzLFxuICAgICAgdmFsdWVcbiAgICB9O1xuXG4gICAgaWYgKG1hdGNoLmtleSkge1xuICAgICAgb2JqLmtleSA9IG1hdGNoLmtleS5zcmM7XG4gICAgfVxuXG4gICAgaWYgKG1hdGNoLmlkeCA+IC0xKSB7XG4gICAgICBvYmoucmVmSW5kZXggPSBtYXRjaC5pZHg7XG4gICAgfVxuXG4gICAgZGF0YS5tYXRjaGVzLnB1c2gob2JqKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVNjb3JlKHJlc3VsdCwgZGF0YSkge1xuICBkYXRhLnNjb3JlID0gcmVzdWx0LnNjb3JlO1xufVxuXG5mdW5jdGlvbiBmb3JtYXQoXG4gIHJlc3VsdHMsXG4gIGRvY3MsXG4gIHtcbiAgICBpbmNsdWRlTWF0Y2hlcyA9IENvbmZpZy5pbmNsdWRlTWF0Y2hlcyxcbiAgICBpbmNsdWRlU2NvcmUgPSBDb25maWcuaW5jbHVkZVNjb3JlXG4gIH0gPSB7fVxuKSB7XG4gIGNvbnN0IHRyYW5zZm9ybWVycyA9IFtdO1xuXG4gIGlmIChpbmNsdWRlTWF0Y2hlcykgdHJhbnNmb3JtZXJzLnB1c2godHJhbnNmb3JtTWF0Y2hlcyk7XG4gIGlmIChpbmNsdWRlU2NvcmUpIHRyYW5zZm9ybWVycy5wdXNoKHRyYW5zZm9ybVNjb3JlKTtcblxuICByZXR1cm4gcmVzdWx0cy5tYXAoKHJlc3VsdCkgPT4ge1xuICAgIGNvbnN0IHsgaWR4IH0gPSByZXN1bHQ7XG5cbiAgICBjb25zdCBkYXRhID0ge1xuICAgICAgaXRlbTogZG9jc1tpZHhdLFxuICAgICAgcmVmSW5kZXg6IGlkeFxuICAgIH07XG5cbiAgICBpZiAodHJhbnNmb3JtZXJzLmxlbmd0aCkge1xuICAgICAgdHJhbnNmb3JtZXJzLmZvckVhY2goKHRyYW5zZm9ybWVyKSA9PiB7XG4gICAgICAgIHRyYW5zZm9ybWVyKHJlc3VsdCwgZGF0YSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YVxuICB9KVxufVxuXG5jbGFzcyBGdXNlIHtcbiAgY29uc3RydWN0b3IoZG9jcywgb3B0aW9ucyA9IHt9LCBpbmRleCkge1xuICAgIHRoaXMub3B0aW9ucyA9IHsgLi4uQ29uZmlnLCAuLi5vcHRpb25zIH07XG5cbiAgICBpZiAoXG4gICAgICB0aGlzLm9wdGlvbnMudXNlRXh0ZW5kZWRTZWFyY2ggJiZcbiAgICAgICF0cnVlXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoRVhURU5ERURfU0VBUkNIX1VOQVZBSUxBQkxFKVxuICAgIH1cblxuICAgIHRoaXMuX2tleVN0b3JlID0gbmV3IEtleVN0b3JlKHRoaXMub3B0aW9ucy5rZXlzKTtcblxuICAgIHRoaXMuc2V0Q29sbGVjdGlvbihkb2NzLCBpbmRleCk7XG4gIH1cblxuICBzZXRDb2xsZWN0aW9uKGRvY3MsIGluZGV4KSB7XG4gICAgdGhpcy5fZG9jcyA9IGRvY3M7XG5cbiAgICBpZiAoaW5kZXggJiYgIShpbmRleCBpbnN0YW5jZW9mIEZ1c2VJbmRleCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihJTkNPUlJFQ1RfSU5ERVhfVFlQRSlcbiAgICB9XG5cbiAgICB0aGlzLl9teUluZGV4ID1cbiAgICAgIGluZGV4IHx8XG4gICAgICBjcmVhdGVJbmRleCh0aGlzLm9wdGlvbnMua2V5cywgdGhpcy5fZG9jcywge1xuICAgICAgICBnZXRGbjogdGhpcy5vcHRpb25zLmdldEZuLFxuICAgICAgICBmaWVsZE5vcm1XZWlnaHQ6IHRoaXMub3B0aW9ucy5maWVsZE5vcm1XZWlnaHRcbiAgICAgIH0pO1xuICB9XG5cbiAgYWRkKGRvYykge1xuICAgIGlmICghaXNEZWZpbmVkKGRvYykpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuX2RvY3MucHVzaChkb2MpO1xuICAgIHRoaXMuX215SW5kZXguYWRkKGRvYyk7XG4gIH1cblxuICByZW1vdmUocHJlZGljYXRlID0gKC8qIGRvYywgaWR4ICovKSA9PiBmYWxzZSkge1xuICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB0aGlzLl9kb2NzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBjb25zdCBkb2MgPSB0aGlzLl9kb2NzW2ldO1xuICAgICAgaWYgKHByZWRpY2F0ZShkb2MsIGkpKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlQXQoaSk7XG4gICAgICAgIGkgLT0gMTtcbiAgICAgICAgbGVuIC09IDE7XG5cbiAgICAgICAgcmVzdWx0cy5wdXNoKGRvYyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdHNcbiAgfVxuXG4gIHJlbW92ZUF0KGlkeCkge1xuICAgIHRoaXMuX2RvY3Muc3BsaWNlKGlkeCwgMSk7XG4gICAgdGhpcy5fbXlJbmRleC5yZW1vdmVBdChpZHgpO1xuICB9XG5cbiAgZ2V0SW5kZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX215SW5kZXhcbiAgfVxuXG4gIHNlYXJjaChxdWVyeSwgeyBsaW1pdCA9IC0xIH0gPSB7fSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGluY2x1ZGVNYXRjaGVzLFxuICAgICAgaW5jbHVkZVNjb3JlLFxuICAgICAgc2hvdWxkU29ydCxcbiAgICAgIHNvcnRGbixcbiAgICAgIGlnbm9yZUZpZWxkTm9ybVxuICAgIH0gPSB0aGlzLm9wdGlvbnM7XG5cbiAgICBsZXQgcmVzdWx0cyA9IGlzU3RyaW5nKHF1ZXJ5KVxuICAgICAgPyBpc1N0cmluZyh0aGlzLl9kb2NzWzBdKVxuICAgICAgICA/IHRoaXMuX3NlYXJjaFN0cmluZ0xpc3QocXVlcnkpXG4gICAgICAgIDogdGhpcy5fc2VhcmNoT2JqZWN0TGlzdChxdWVyeSlcbiAgICAgIDogdGhpcy5fc2VhcmNoTG9naWNhbChxdWVyeSk7XG5cbiAgICBjb21wdXRlU2NvcmUocmVzdWx0cywgeyBpZ25vcmVGaWVsZE5vcm0gfSk7XG5cbiAgICBpZiAoc2hvdWxkU29ydCkge1xuICAgICAgcmVzdWx0cy5zb3J0KHNvcnRGbik7XG4gICAgfVxuXG4gICAgaWYgKGlzTnVtYmVyKGxpbWl0KSAmJiBsaW1pdCA+IC0xKSB7XG4gICAgICByZXN1bHRzID0gcmVzdWx0cy5zbGljZSgwLCBsaW1pdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZvcm1hdChyZXN1bHRzLCB0aGlzLl9kb2NzLCB7XG4gICAgICBpbmNsdWRlTWF0Y2hlcyxcbiAgICAgIGluY2x1ZGVTY29yZVxuICAgIH0pXG4gIH1cblxuICBfc2VhcmNoU3RyaW5nTGlzdChxdWVyeSkge1xuICAgIGNvbnN0IHNlYXJjaGVyID0gY3JlYXRlU2VhcmNoZXIocXVlcnksIHRoaXMub3B0aW9ucyk7XG4gICAgY29uc3QgeyByZWNvcmRzIH0gPSB0aGlzLl9teUluZGV4O1xuICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcblxuICAgIC8vIEl0ZXJhdGUgb3ZlciBldmVyeSBzdHJpbmcgaW4gdGhlIGluZGV4XG4gICAgcmVjb3Jkcy5mb3JFYWNoKCh7IHY6IHRleHQsIGk6IGlkeCwgbjogbm9ybSB9KSA9PiB7XG4gICAgICBpZiAoIWlzRGVmaW5lZCh0ZXh0KSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgY29uc3QgeyBpc01hdGNoLCBzY29yZSwgaW5kaWNlcyB9ID0gc2VhcmNoZXIuc2VhcmNoSW4odGV4dCk7XG5cbiAgICAgIGlmIChpc01hdGNoKSB7XG4gICAgICAgIHJlc3VsdHMucHVzaCh7XG4gICAgICAgICAgaXRlbTogdGV4dCxcbiAgICAgICAgICBpZHgsXG4gICAgICAgICAgbWF0Y2hlczogW3sgc2NvcmUsIHZhbHVlOiB0ZXh0LCBub3JtLCBpbmRpY2VzIH1dXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdHNcbiAgfVxuXG4gIF9zZWFyY2hMb2dpY2FsKHF1ZXJ5KSB7XG5cbiAgICBjb25zdCBleHByZXNzaW9uID0gcGFyc2UocXVlcnksIHRoaXMub3B0aW9ucyk7XG5cbiAgICBjb25zdCBldmFsdWF0ZSA9IChub2RlLCBpdGVtLCBpZHgpID0+IHtcbiAgICAgIGlmICghbm9kZS5jaGlsZHJlbikge1xuICAgICAgICBjb25zdCB7IGtleUlkLCBzZWFyY2hlciB9ID0gbm9kZTtcblxuICAgICAgICBjb25zdCBtYXRjaGVzID0gdGhpcy5fZmluZE1hdGNoZXMoe1xuICAgICAgICAgIGtleTogdGhpcy5fa2V5U3RvcmUuZ2V0KGtleUlkKSxcbiAgICAgICAgICB2YWx1ZTogdGhpcy5fbXlJbmRleC5nZXRWYWx1ZUZvckl0ZW1BdEtleUlkKGl0ZW0sIGtleUlkKSxcbiAgICAgICAgICBzZWFyY2hlclxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAobWF0Y2hlcyAmJiBtYXRjaGVzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlkeCxcbiAgICAgICAgICAgICAgaXRlbSxcbiAgICAgICAgICAgICAgbWF0Y2hlc1xuICAgICAgICAgICAgfVxuICAgICAgICAgIF1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbXVxuICAgICAgfVxuXG4gICAgICBjb25zdCByZXMgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gZXZhbHVhdGUoY2hpbGQsIGl0ZW0sIGlkeCk7XG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoKSB7XG4gICAgICAgICAgcmVzLnB1c2goLi4ucmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIGlmIChub2RlLm9wZXJhdG9yID09PSBMb2dpY2FsT3BlcmF0b3IuQU5EKSB7XG4gICAgICAgICAgcmV0dXJuIFtdXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXNcbiAgICB9O1xuXG4gICAgY29uc3QgcmVjb3JkcyA9IHRoaXMuX215SW5kZXgucmVjb3JkcztcbiAgICBjb25zdCByZXN1bHRNYXAgPSB7fTtcbiAgICBjb25zdCByZXN1bHRzID0gW107XG5cbiAgICByZWNvcmRzLmZvckVhY2goKHsgJDogaXRlbSwgaTogaWR4IH0pID0+IHtcbiAgICAgIGlmIChpc0RlZmluZWQoaXRlbSkpIHtcbiAgICAgICAgbGV0IGV4cFJlc3VsdHMgPSBldmFsdWF0ZShleHByZXNzaW9uLCBpdGVtLCBpZHgpO1xuXG4gICAgICAgIGlmIChleHBSZXN1bHRzLmxlbmd0aCkge1xuICAgICAgICAgIC8vIERlZHVwZSB3aGVuIGFkZGluZ1xuICAgICAgICAgIGlmICghcmVzdWx0TWFwW2lkeF0pIHtcbiAgICAgICAgICAgIHJlc3VsdE1hcFtpZHhdID0geyBpZHgsIGl0ZW0sIG1hdGNoZXM6IFtdIH07XG4gICAgICAgICAgICByZXN1bHRzLnB1c2gocmVzdWx0TWFwW2lkeF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBleHBSZXN1bHRzLmZvckVhY2goKHsgbWF0Y2hlcyB9KSA9PiB7XG4gICAgICAgICAgICByZXN1bHRNYXBbaWR4XS5tYXRjaGVzLnB1c2goLi4ubWF0Y2hlcyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHRzXG4gIH1cblxuICBfc2VhcmNoT2JqZWN0TGlzdChxdWVyeSkge1xuICAgIGNvbnN0IHNlYXJjaGVyID0gY3JlYXRlU2VhcmNoZXIocXVlcnksIHRoaXMub3B0aW9ucyk7XG4gICAgY29uc3QgeyBrZXlzLCByZWNvcmRzIH0gPSB0aGlzLl9teUluZGV4O1xuICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcblxuICAgIC8vIExpc3QgaXMgQXJyYXk8T2JqZWN0PlxuICAgIHJlY29yZHMuZm9yRWFjaCgoeyAkOiBpdGVtLCBpOiBpZHggfSkgPT4ge1xuICAgICAgaWYgKCFpc0RlZmluZWQoaXRlbSkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGxldCBtYXRjaGVzID0gW107XG5cbiAgICAgIC8vIEl0ZXJhdGUgb3ZlciBldmVyeSBrZXkgKGkuZSwgcGF0aCksIGFuZCBmZXRjaCB0aGUgdmFsdWUgYXQgdGhhdCBrZXlcbiAgICAgIGtleXMuZm9yRWFjaCgoa2V5LCBrZXlJbmRleCkgPT4ge1xuICAgICAgICBtYXRjaGVzLnB1c2goXG4gICAgICAgICAgLi4udGhpcy5fZmluZE1hdGNoZXMoe1xuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgdmFsdWU6IGl0ZW1ba2V5SW5kZXhdLFxuICAgICAgICAgICAgc2VhcmNoZXJcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChtYXRjaGVzLmxlbmd0aCkge1xuICAgICAgICByZXN1bHRzLnB1c2goe1xuICAgICAgICAgIGlkeCxcbiAgICAgICAgICBpdGVtLFxuICAgICAgICAgIG1hdGNoZXNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0c1xuICB9XG4gIF9maW5kTWF0Y2hlcyh7IGtleSwgdmFsdWUsIHNlYXJjaGVyIH0pIHtcbiAgICBpZiAoIWlzRGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBbXVxuICAgIH1cblxuICAgIGxldCBtYXRjaGVzID0gW107XG5cbiAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHZhbHVlLmZvckVhY2goKHsgdjogdGV4dCwgaTogaWR4LCBuOiBub3JtIH0pID0+IHtcbiAgICAgICAgaWYgKCFpc0RlZmluZWQodGV4dCkpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHsgaXNNYXRjaCwgc2NvcmUsIGluZGljZXMgfSA9IHNlYXJjaGVyLnNlYXJjaEluKHRleHQpO1xuXG4gICAgICAgIGlmIChpc01hdGNoKSB7XG4gICAgICAgICAgbWF0Y2hlcy5wdXNoKHtcbiAgICAgICAgICAgIHNjb3JlLFxuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgdmFsdWU6IHRleHQsXG4gICAgICAgICAgICBpZHgsXG4gICAgICAgICAgICBub3JtLFxuICAgICAgICAgICAgaW5kaWNlc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgeyB2OiB0ZXh0LCBuOiBub3JtIH0gPSB2YWx1ZTtcblxuICAgICAgY29uc3QgeyBpc01hdGNoLCBzY29yZSwgaW5kaWNlcyB9ID0gc2VhcmNoZXIuc2VhcmNoSW4odGV4dCk7XG5cbiAgICAgIGlmIChpc01hdGNoKSB7XG4gICAgICAgIG1hdGNoZXMucHVzaCh7IHNjb3JlLCBrZXksIHZhbHVlOiB0ZXh0LCBub3JtLCBpbmRpY2VzIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtYXRjaGVzXG4gIH1cbn1cblxuRnVzZS52ZXJzaW9uID0gJzcuMC4wJztcbkZ1c2UuY3JlYXRlSW5kZXggPSBjcmVhdGVJbmRleDtcbkZ1c2UucGFyc2VJbmRleCA9IHBhcnNlSW5kZXg7XG5GdXNlLmNvbmZpZyA9IENvbmZpZztcblxue1xuICBGdXNlLnBhcnNlUXVlcnkgPSBwYXJzZTtcbn1cblxue1xuICByZWdpc3RlcihFeHRlbmRlZFNlYXJjaCk7XG59XG5cbmV4cG9ydCB7IEZ1c2UgYXMgZGVmYXVsdCB9O1xuIl0sIm5hbWVzIjpbImlzQXJyYXkiLCJ2YWx1ZSIsIkFycmF5IiwiZ2V0VGFnIiwiSU5GSU5JVFkiLCJiYXNlVG9TdHJpbmciLCJyZXN1bHQiLCJ0b1N0cmluZyIsImlzU3RyaW5nIiwiaXNOdW1iZXIiLCJpc0Jvb2xlYW4iLCJpc09iamVjdExpa2UiLCJpc09iamVjdCIsImlzRGVmaW5lZCIsInVuZGVmaW5lZCIsImlzQmxhbmsiLCJ0cmltIiwibGVuZ3RoIiwiT2JqZWN0IiwicHJvdG90eXBlIiwiY2FsbCIsIkVYVEVOREVEX1NFQVJDSF9VTkFWQUlMQUJMRSIsIklOQ09SUkVDVF9JTkRFWF9UWVBFIiwiTE9HSUNBTF9TRUFSQ0hfSU5WQUxJRF9RVUVSWV9GT1JfS0VZIiwia2V5IiwiUEFUVEVSTl9MRU5HVEhfVE9PX0xBUkdFIiwibWF4IiwiTUlTU0lOR19LRVlfUFJPUEVSVFkiLCJuYW1lIiwiSU5WQUxJRF9LRVlfV0VJR0hUX1ZBTFVFIiwiaGFzT3duIiwiaGFzT3duUHJvcGVydHkiLCJLZXlTdG9yZSIsImNvbnN0cnVjdG9yIiwia2V5cyIsIl9rZXlzIiwiX2tleU1hcCIsInRvdGFsV2VpZ2h0IiwiZm9yRWFjaCIsIm9iaiIsImNyZWF0ZUtleSIsInB1c2giLCJpZCIsIndlaWdodCIsImdldCIsImtleUlkIiwidG9KU09OIiwiSlNPTiIsInN0cmluZ2lmeSIsInBhdGgiLCJzcmMiLCJnZXRGbiIsImNyZWF0ZUtleVBhdGgiLCJjcmVhdGVLZXlJZCIsIkVycm9yIiwic3BsaXQiLCJqb2luIiwibGlzdCIsImFyciIsImRlZXBHZXQiLCJpbmRleCIsImkiLCJsZW4iLCJNYXRjaE9wdGlvbnMiLCJpbmNsdWRlTWF0Y2hlcyIsImZpbmRBbGxNYXRjaGVzIiwibWluTWF0Y2hDaGFyTGVuZ3RoIiwiQmFzaWNPcHRpb25zIiwiaXNDYXNlU2Vuc2l0aXZlIiwiaW5jbHVkZVNjb3JlIiwic2hvdWxkU29ydCIsInNvcnRGbiIsImEiLCJiIiwic2NvcmUiLCJpZHgiLCJGdXp6eU9wdGlvbnMiLCJsb2NhdGlvbiIsInRocmVzaG9sZCIsImRpc3RhbmNlIiwiQWR2YW5jZWRPcHRpb25zIiwidXNlRXh0ZW5kZWRTZWFyY2giLCJpZ25vcmVMb2NhdGlvbiIsImlnbm9yZUZpZWxkTm9ybSIsImZpZWxkTm9ybVdlaWdodCIsIkNvbmZpZyIsIlNQQUNFIiwibm9ybSIsIm1hbnRpc3NhIiwiY2FjaGUiLCJNYXAiLCJtIiwiTWF0aCIsInBvdyIsIm51bVRva2VucyIsIm1hdGNoIiwiaGFzIiwibiIsInBhcnNlRmxvYXQiLCJyb3VuZCIsInNldCIsImNsZWFyIiwiRnVzZUluZGV4IiwiaXNDcmVhdGVkIiwic2V0SW5kZXhSZWNvcmRzIiwic2V0U291cmNlcyIsImRvY3MiLCJyZWNvcmRzIiwic2V0S2V5cyIsIl9rZXlzTWFwIiwiY3JlYXRlIiwiZG9jIiwiZG9jSW5kZXgiLCJfYWRkU3RyaW5nIiwiX2FkZE9iamVjdCIsImFkZCIsInNpemUiLCJyZW1vdmVBdCIsInNwbGljZSIsImdldFZhbHVlRm9ySXRlbUF0S2V5SWQiLCJpdGVtIiwicmVjb3JkIiwidiIsIiQiLCJrZXlJbmRleCIsInN1YlJlY29yZHMiLCJzdGFjayIsIm5lc3RlZEFyckluZGV4IiwicG9wIiwic3ViUmVjb3JkIiwiayIsImNyZWF0ZUluZGV4IiwibXlJbmRleCIsIm1hcCIsInBhcnNlSW5kZXgiLCJkYXRhIiwiY29tcHV0ZVNjb3JlJDEiLCJwYXR0ZXJuIiwiZXJyb3JzIiwiY3VycmVudExvY2F0aW9uIiwiZXhwZWN0ZWRMb2NhdGlvbiIsImFjY3VyYWN5IiwicHJveGltaXR5IiwiYWJzIiwiY29udmVydE1hc2tUb0luZGljZXMiLCJtYXRjaG1hc2siLCJpbmRpY2VzIiwic3RhcnQiLCJlbmQiLCJNQVhfQklUUyIsInNlYXJjaCIsInRleHQiLCJwYXR0ZXJuQWxwaGFiZXQiLCJwYXR0ZXJuTGVuIiwidGV4dExlbiIsIm1pbiIsImN1cnJlbnRUaHJlc2hvbGQiLCJiZXN0TG9jYXRpb24iLCJjb21wdXRlTWF0Y2hlcyIsIm1hdGNoTWFzayIsImluZGV4T2YiLCJsYXN0Qml0QXJyIiwiZmluYWxTY29yZSIsImJpbk1heCIsIm1hc2siLCJiaW5NaW4iLCJiaW5NaWQiLCJmbG9vciIsImZpbmlzaCIsImJpdEFyciIsImoiLCJjaGFyTWF0Y2giLCJjaGFyQXQiLCJpc01hdGNoIiwiY3JlYXRlUGF0dGVybkFscGhhYmV0IiwiY2hhciIsIkJpdGFwU2VhcmNoIiwib3B0aW9ucyIsInRvTG93ZXJDYXNlIiwiY2h1bmtzIiwiYWRkQ2h1bmsiLCJzdGFydEluZGV4IiwiYWxwaGFiZXQiLCJyZW1haW5kZXIiLCJzdWJzdHIiLCJzZWFyY2hJbiIsImFsbEluZGljZXMiLCJ0b3RhbFNjb3JlIiwiaGFzTWF0Y2hlcyIsIkJhc2VNYXRjaCIsImlzTXVsdGlNYXRjaCIsImdldE1hdGNoIiwibXVsdGlSZWdleCIsImlzU2luZ2xlTWF0Y2giLCJzaW5nbGVSZWdleCIsImV4cCIsIm1hdGNoZXMiLCJFeGFjdE1hdGNoIiwidHlwZSIsIkludmVyc2VFeGFjdE1hdGNoIiwiUHJlZml4RXhhY3RNYXRjaCIsInN0YXJ0c1dpdGgiLCJJbnZlcnNlUHJlZml4RXhhY3RNYXRjaCIsIlN1ZmZpeEV4YWN0TWF0Y2giLCJlbmRzV2l0aCIsIkludmVyc2VTdWZmaXhFeGFjdE1hdGNoIiwiRnV6enlNYXRjaCIsIl9iaXRhcFNlYXJjaCIsIkluY2x1ZGVNYXRjaCIsInNlYXJjaGVycyIsInNlYXJjaGVyc0xlbiIsIlNQQUNFX1JFIiwiT1JfVE9LRU4iLCJwYXJzZVF1ZXJ5IiwicXVlcnkiLCJmaWx0ZXIiLCJyZXN1bHRzIiwicXVlcnlJdGVtIiwiZm91bmQiLCJzZWFyY2hlciIsInRva2VuIiwiTXVsdGlNYXRjaFNldCIsIlNldCIsIkV4dGVuZGVkU2VhcmNoIiwiY29uZGl0aW9uIiwiXyIsIm51bU1hdGNoZXMiLCJxTGVuIiwicExlbiIsInJlZ2lzdGVyZWRTZWFyY2hlcnMiLCJyZWdpc3RlciIsImFyZ3MiLCJjcmVhdGVTZWFyY2hlciIsInNlYXJjaGVyQ2xhc3MiLCJMb2dpY2FsT3BlcmF0b3IiLCJBTkQiLCJPUiIsIktleVR5cGUiLCJQQVRIIiwiUEFUVEVSTiIsImlzRXhwcmVzc2lvbiIsImlzUGF0aCIsImlzTGVhZiIsImNvbnZlcnRUb0V4cGxpY2l0IiwicGFyc2UiLCJhdXRvIiwibmV4dCIsImlzUXVlcnlQYXRoIiwibm9kZSIsImNoaWxkcmVuIiwib3BlcmF0b3IiLCJjb21wdXRlU2NvcmUiLCJOdW1iZXIiLCJFUFNJTE9OIiwidHJhbnNmb3JtTWF0Y2hlcyIsInJlZkluZGV4IiwidHJhbnNmb3JtU2NvcmUiLCJmb3JtYXQiLCJ0cmFuc2Zvcm1lcnMiLCJ0cmFuc2Zvcm1lciIsIkZ1c2UiLCJfa2V5U3RvcmUiLCJzZXRDb2xsZWN0aW9uIiwiX2RvY3MiLCJfbXlJbmRleCIsInJlbW92ZSIsInByZWRpY2F0ZSIsImdldEluZGV4IiwibGltaXQiLCJfc2VhcmNoU3RyaW5nTGlzdCIsIl9zZWFyY2hPYmplY3RMaXN0IiwiX3NlYXJjaExvZ2ljYWwiLCJzb3J0Iiwic2xpY2UiLCJleHByZXNzaW9uIiwiZXZhbHVhdGUiLCJfZmluZE1hdGNoZXMiLCJyZXMiLCJjaGlsZCIsInJlc3VsdE1hcCIsImV4cFJlc3VsdHMiLCJ2ZXJzaW9uIiwiY29uZmlnIiwiZGVmYXVsdCJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/fuse.js@7.0.0/node_modules/fuse.js/dist/fuse.mjs\n");

/***/ })

};
;